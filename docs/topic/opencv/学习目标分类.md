---
title: 学习目标分类
copyright: true
date: 2017-05-18 17:58:12
categories:
- Cpp
tags:
- Cpp
- OpenCV
---

#### Overview

还是*OpenCV By Example*， 承接上文的目标分割和检测，这里用SVM进行了分类的学习。由于从PACKT下载的代码是基于QT的，而我。。开始编译OpenCV没有选QT支持，重新编译也一致出错，就暂时没去用QT的按钮那些功能，也就没QT进行编译了。。扯多了，回到正题。代码应该是有一些bug的，折腾了一下午才调试好...

原理还是比较简单的，处理的流程也较为清晰。对图片主要是进行了中值滤波，去除光纹，和灰度二值化提取轮廓的操作。抽取螺丝环，螺母，螺丝钉的面积和长宽比这两个特征进行训练，测试误差在2%以下，看书上的截图，原作的误差在7%左右...可能和OpenCV的改进有关吧。



#### Code


{% codeblock lang:cpp %}

    //
    // Created by shensir on 17-5-17.
    //

    #include <iostream>
    #include "opencv2/highgui.hpp"
    #include "opencv2/imgproc.hpp"
    #include "opencv2/ml.hpp"

    using namespace std;
    using namespace cv;
    using namespace cv::ml;

    // 一些全局变量
    Mat light_pattern;
    Ptr<SVM> svm;
    Scalar green(0,255,0), blue (255,0,0), red (0,0,255);

    // 光纹去除
    Mat removeLight(Mat img, Mat pattern)
    {
        Mat aux;
        // Require change our image to 32 float for division
        Mat img32, pattern32;
        img.convertTo(img32, CV_32F);
        pattern.convertTo(pattern32, CV_32F);
        // Divide the imabe by the pattern
        aux= 255*(1-(img32/pattern32));
        // Convert 8 bits format
        aux.convertTo(aux, CV_8U);

        return aux;
    }



    // 特征抽取，这里抽取面积及宽高比
    vector<vector<float> > ExtractFeatures(Mat img, vector<int>*left=NULL, vector<int>*top=NULL)
    {
    //    count_num +=1;
        vector<vector<float>> output;
        vector<vector<Point>> contours;
        Mat input = img.clone();

        vector<Vec4i>hierarchy;
        findContours(input, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);
        // 检查被检测到的物体个数
        if(contours.size() == 0) return output;

        for(int i=0; i<contours.size(); i++){
            Mat mask = Mat::zeros(img.rows, img.cols, CV_8UC1);
            drawContours(mask, contours, i, Scalar(1), FILLED, LINE_8, hierarchy, 1);
            Scalar area_s = sum(mask);
            float area = area_s[0];

            if(area>500){// 如果area大于面积最小阀值
                RotatedRect r = minAreaRect(contours[i]);
                float width = r.size.width;
                float height = r.size.height;
                float ar = (width<height)?height/width:width/height;

                // 存储特征数据
                vector<float> row;
                row.push_back(area);
                row.push_back(ar);
                output.push_back(row);
                // 用于添加文字时候的定位
                if(left!=NULL){
                    left->push_back(int(r.center.x));
                }
                if(top!=NULL){
                    top->push_back(int(r.center.y));
                }
                // 显示特征抽取的结果
                imshow("Extract Features", mask*255);
                waitKey(10);
            }
        }
        return output;
    }



    // 图片预处理
    Mat preprocessImage(Mat input)
    {
        // 灰度化
        if(input.channels()!=1)
            cvtColor(input, input, COLOR_BGR2GRAY);

        Mat result;
        // Remove noise
        Mat img_noise;
        medianBlur(input, img_noise, 3);
        //Apply the light pattern
        Mat img_no_light;
        img_noise.copyTo(img_no_light);
        // 去除光纹
        img_no_light= removeLight(img_noise, light_pattern);


        // Binarize image for segment
        threshold(img_no_light, result, 30, 255, THRESH_BINARY);

        return result;
    }


    // 从文件批量读取图片，并进行特征抽取
    bool readFolderAndExtractFeatures(string folder, int label, int num_for_test,
                                        vector<float>&trainingData, vector<int>&responeseData,
                                        vector<float>&testData, vector<float>&testResponsesData)
    {
        VideoCapture images(folder);
        if(images.open(folder) == false){
            cout<<"Can not open the folder images"<<endl;
            return false;
        }

        Mat frame;
        int img_index=0;
        while(images.read(frame)){

            // 预处理图像
            images>>frame;  //  书上参考代码没有这句，貌似bug...
            if(!frame.empty()){

                // 预处理
                Mat pre = preprocessImage(frame);
                // 提取特征
                vector<vector<float>> features = ExtractFeatures(pre);
                for(int i=0; i<features.size(); i++){
                    if(img_index >= num_for_test){
                        trainingData.push_back(features[i][0]);
                        trainingData.push_back(features[i][1]);
                        responeseData.push_back(label);

                    }else{
                        testData.push_back(features[i][0]);
                        testData.push_back(features[i][1]);
                        testResponsesData.push_back(float(label));
                    }
                }
                img_index ++;

            }

        }
        return true;

    };


    // 做图
    void plotTrainData(Mat trainData, Mat labels, float *error=NULL)
    {
        float area_max, ar_max, area_min, ar_min;
        area_max= ar_max= 0;
        area_min= ar_min= 99999999;
        // Get the min and max of each feature for normalize plot image
        for(int i=0; i< trainData.rows; i++){
            float area= trainData.at<float>(i,0);
            float ar= trainData.at<float>(i,1);
            if(area > area_max)
                area_max= area;
            if( ar > ar_max )
                ar_max= ar;
            if(area < area_min)
                area_min= area;
            if(ar < ar_min)
                ar_min= ar;
        }

        // Create Image for plot
        Mat plot= Mat::zeros(512,512,CV_8UC3);
        // Plot each of two features in a 2D graph using an image
        // where x is area and y is aspect ratio
        for(int i=0; i< trainData.rows; i++){
            // Set the X y pos for each data
            float area= trainData.at<float>(i,0);
            float ar= trainData.at<float>(i,1);
            int x= (int)(512.0f*((area-area_min)/(area_max-area_min)));
            int y= (int)(512.0f*((ar-ar_min)/(ar_max-ar_min)));

            // Get label
            int label= labels.at<int>(i);
            // Set color depend of label
            Scalar color;
            if(label==0)
                color= green; // NUT
            else if(label==1)
                color= blue; // ring
            else if(label==2)
                color= red; // SCREW

            circle( plot,  Point(x, y), 3,  color, -1, 8);
        }

        if(error!=NULL){
            stringstream ss;
            ss << "Error: " << *error << "%";
            putText(plot, ss.str().c_str(), Point(20,512-40), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(200,200,200), 1, LINE_AA);
        }
        imshow("plot", plot);
    //    waitKey(0);

    }


    // 训练并测试误差
    void trainAndTest() {
        vector<float> trainingData;
        vector<int> responsesData;
        vector<float> testData;
        vector<float> testResponsesData;

        int num_for_test = 20;


        // 获取螺母图像
        readFolderAndExtractFeatures("/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/"
                                             "B04283_06_code/data/nut/tuerca_%04d.pgm", 0,
                                     num_for_test, trainingData, responsesData, testData, testResponsesData);

        // 获取螺丝圈图像
        readFolderAndExtractFeatures("/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/"
                                             "B04283_06_code/data/ring/arandela_%04d.pgm", 1,
                                     num_for_test, trainingData, responsesData, testData, testResponsesData);


        // 获取并处理螺丝
        readFolderAndExtractFeatures("/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/"
                                             "9781785280948_Code/B04283_06_code/data/screw/tornillo_%04d.pgm", 2,
                                     num_for_test, trainingData, responsesData, testData, testResponsesData);

        cout<<"Num of train samples: "<<responsesData.size()<<endl;

        cout<<"Num of test samples: "<<testResponsesData.size()<<endl;

        // 合并
        // Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);

        Mat trainingDataMat(trainingData.size()/2 ,2, CV_32FC1, &trainingData[0]);
        Mat responses(responsesData.size(), 1, CV_32SC1, &responsesData[0]);

        Mat testDataMat(testData.size()/2, 2, CV_32FC1, &testData[0]);
        Mat testRespones(testResponsesData.size(), 1, CV_32FC1, &testResponsesData[0]);

        svm = SVM::create();
        svm->setType(SVM::C_SVC);
        svm->setKernel(SVM::CHI2);
        svm->setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));

        svm->train(trainingDataMat, ROW_SAMPLE, responses);

        if(testResponsesData.size() >0){
            cout<<"Evaluation"<<endl;
            cout<<"============"<<endl;
            // test the ML model
            Mat testPredict;
            svm->predict(testDataMat, testPredict);
            cout<<"Prediction Done"<<endl;
            // error handle
            Mat errorMat = testPredict != testRespones;
            float error = 100.0f * countNonZero(errorMat) / testResponsesData.size();
            cout<<"Error: "<<error<<"%"<<endl;
            //plot data
            plotTrainData(trainingDataMat, responses, &error);

        }else{
            plotTrainData(trainingDataMat, responses);
        }
    }



    int main( int argc, const char** argv )
    {

        // Load image to process
        Mat img= imread("/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/B04283_06_code/data/test.pgm", IMREAD_GRAYSCALE);
        if(img.data==NULL){
            cout << "Error loading image "<< endl;
            return 0;
        }
        imshow("img", img);


        // Load image to process
        light_pattern= imread("/home/shensir/Documents/MyPrograming/Cpp/Clions/data/light.pgm", 0);
        if(light_pattern.data==NULL){
            // Calculate light pattern
            cout << "ERROR: Not light patter loaded" << endl;
            return 0;
        }

        medianBlur(light_pattern, light_pattern, 3);

        trainAndTest();

        //// Preprocess image
        Mat pre= preprocessImage(img);
        ////End preprocess

        // Extract features
        vector<int> pos_top, pos_left;
        vector< vector<float> > features= ExtractFeatures(pre, &pos_left, &pos_top);

        cout << "Num objects extracted features " << features.size() << endl;

        Mat img_output= img.clone();
        cvtColor(img_output, img_output, COLOR_GRAY2BGR);

        for(int i=0; i< features.size(); i++){

            cout << "Data Area AR: " << features[i][0] << " " << features[i][1] << endl;

            Mat trainingDataMat(1, 2, CV_32FC1, &features[i][0]);
            cout << "Features to predict: " << trainingDataMat << endl;
            float result= svm->predict(trainingDataMat);
            cout << result << endl;


            stringstream ss;
            Scalar color;
            if(result==0){
                color= green; // NUT
                ss << "NUT";
            }
            else if(result==1){
                color= blue; // RING
                ss << "RING" ;
            }
            else if(result==2){
                color= red; // SCREW
                ss << "SCREW";
            }

            putText(img_output,
                    ss.str(),
                    Point2d(pos_left[i], pos_top[i]),
                    FONT_HERSHEY_SIMPLEX,
                    0.4,
                    color);

        }
        //vector<int> results= evaluate(features);

        // Show images
        imshow("Binary image", pre);
        imshow("Result", img_output);
        waitKey(0);
        return 0;

    }


{% endcodeblock %}



>此处的测试结果还是不错的，5个部件全部识别成功了。

输出：

    Num of train samples: 146
    Num of test samples: 67
    Evaluation
    ============
    Prediction Done
    Error: 1.49254%
    Num objects extracted features 5
    Data Area AR: 2084 1.54013
    Features to predict: [2084, 1.54013]
    2
    Data Area AR: 1171 1.12195
    Features to predict: [1171, 1.1219512]
    0
    Data Area AR: 1045 1.97279
    Features to predict: [1045, 1.9727893]
    0
    Data Area AR: 1486 1.12069
    Features to predict: [1486, 1.1206896]
    2
    Data Area AR: 1620 1
    Features to predict: [1620, 1]
    1

![](http://blog-1252464519.costj.myqcloud.com/170518/Selection_051804.png)




