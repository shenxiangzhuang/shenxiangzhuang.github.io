---
title: 自动光学检测，目标分割和检测
copyright: true
date: 2017-05-18 00:49:33
categories:
- Cpp
tags:
- Cpp
- OpenCV
---

#### Overview

在复习CookBook的闲暇，看了看*OpenCV By Example*, 里面的示例很不错，这里做下记录。此处实现了目标的背景去除，目标的分割和检测，以工厂螺母为例。就是下面的图啦。

![](http://blog-1252464519.costj.myqcloud.com/170518/light.png)
![](http://blog-1252464519.costj.myqcloud.com/170518/test.png)

#### Code

{% codeblock lang:cpp %}


    //
    // Created by shensir on 17-5-17.
    //

    #include <iostream>
    #include "opencv2/highgui.hpp"
    #include "opencv2/imgproc.hpp"

    using namespace std;
    using namespace cv;

    // 光纹去除
    Mat removeLight(Mat img, Mat pattern, int method){
        Mat aux;
        // 如果方法是归一化
        if(method==1){
            // 相除时需要将图像改为32位浮点型
            Mat img32, pattern32;
            img.convertTo(img32, CV_32F);
            pattern.convertTo(pattern32, CV_32F);
            // 图像相除模式
            aux = 255*(1-(img32/pattern32));
            // 换回8bit
            aux.convertTo(aux, CV_8U);
        }
        else{
            aux = pattern - img;
        }
        return aux;
    }

    // 估计背景图像，大尺寸核矩阵模糊
    Mat calculateLightPattern(Mat img){
        Mat pattern;
        blur(img, pattern, Size(img.cols/3, img.rows/3));
        return pattern;
    }


    // 先进行形态学操作[在背景色是核函数模糊得到的时候，很有必要]，再二值化
    Mat getBinary(Mat img_no_light, int method_light){
        Mat img_thr;
        if(method_light!=2){
            threshold(img_no_light, img_thr, 30, 255, THRESH_BINARY);
        } else{
            threshold(img_no_light, img_thr, 140, 255, THRESH_BINARY_INV);
        }

        // 进行形态学操作去除边缘不规则噪点
        cv::Mat closed;
        cv::Mat element5(5 ,5, CV_8U, cv::Scalar(1));
        cv::morphologyEx(img_thr, closed,   // input and output
                         cv::MORPH_CLOSE,  // operator code
                         element5);  // structuring element

        // Opening
        cv::Mat opening;
        cv::morphologyEx(closed, opening,   // input and output
                         cv::MORPH_OPEN,  // operator code
                         element5);  // structuring element


        imshow("img_thr_closed-opening", opening);

        return opening;
    }

    static Scalar randomColor( RNG& rng )
    {
        int icolor = (unsigned) rng;
        return Scalar( icolor&255, (icolor>>8)&255, (icolor>>16)&255 );
    }

    // 连通区域算法
    void ConnectedComponents(Mat img){
        // 使用连通区域分离符合要求部分图像Mat标签
        Mat labels;
        int num_objects = connectedComponents(img, labels);
        // 检查检测到的目标数目
        if(num_objects<2){
            cout<<"No objects detected"<<endl;
            return;
        } else{
            cout<<"Number of objects detected: "<< num_objects-1<<endl;
        }
        // 创建彩色目标的输出图像
        Mat output=Mat::zeros(img.rows, img.cols, CV_8UC3);
        RNG rng(0xFFFFFFFF);
        for(int i=1; i<num_objects; i++){
            Mat mask = labels==i;
            output.setTo(randomColor(rng), mask);
        }
        imshow("Result", output);
    }


    // 连通区域算法
    void ConnectedComponentsStats(Mat img){
        // 连通区域统计信息
        Mat labels, stats, centroids;
        int num_objects = connectedComponentsWithStats(img, labels, stats, centroids);

        // 检测物体数目判别
        if(num_objects<2){
            cout<<"No objects detedcted"<<endl;
            return;
        } else{
            cout<<"Number of objects detected: "<<num_objects-1<<endl;
        }
        // 创建彩色对象的输出图像并显示区域
        Mat output = Mat::zeros(img.rows, img.cols, CV_8UC3);
        RNG rng(0xFFFFFFFF);

        for(int i=1; i<num_objects; i++){
            cout<<"Object "<<i<<" with pos: "<<centroids.at<Point2d>(i)
                                             <<" with area "<<stats.at<int>(i, CC_STAT_AREA)<<endl;
            Mat mask = labels==i;
            output.setTo(randomColor(rng), mask);

            // 使用区域绘制文本
            stringstream ss;
            ss<<"area: "<<stats.at<int>(i, CC_STAT_AREA);

            putText(output, ss.str(), centroids.at<Point2d>(i), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255,255,255));
        }
        imshow("Result", output);
    }


    //  边缘检测算法
    void FindContoursBasic(Mat img){
        vector<vector<Point>> contours;
        findContours(img, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
        Mat output = Mat::zeros(img.rows, img.cols, CV_8UC3);
        // 检查检测到的对象的数目
        if(contours.size() == 0){
            cout<<"No objects detected"<<endl;
            return;
        } else{
            cout<<"Number of objects detected: "<<contours.size()<<endl;
        }

        RNG rng(0xFFFFFFFF);
        for(int i=0;i<contours.size();i++){
            drawContours(output, contours, i, randomColor(rng));
        }
        imshow("Contours", output);
    }



    int main(){
        Mat img = imread("/home/shensir/Documents/MyPrograming/Cpp/Clions/data/industry.pgm", IMREAD_GRAYSCALE);
        imshow("Original Image", img);

        Mat pattern = imread("/home/shensir/Documents/MyPrograming/Cpp/Clions/data/light.pgm",0);
        imshow("Back", pattern);
    //    Mat pattern = calculateLightPattern(img);
        Mat img_no_light = removeLight(img, pattern, 1);
        imshow("removelight--minus", img_no_light);

        Mat img_thr = getBinary(img_no_light,1);
    //    ConnectedComponents(img_thr);
        ConnectedComponentsStats(img_thr);

        FindContoursBasic(img_thr);
        waitKey(0);
        return 0;
    }


{% endcodeblock %}



输出：

>Number of objects detected: 4
Object 1 with pos: [160.203, 143.822] with area 2315
Object 2 with pos: [263.535, 131.804] with area 1820
Object 3 with pos: [52.7045, 143.926] with area 1171
Object 4 with pos: [68.233, 202.819] with area 1618
Number of objects detected: 4


![](http://blog-1252464519.costj.myqcloud.com/170518/Selection_051801.png)


#### 待改进的地方

在没有背景色图的时候，我们直接通过大尺寸核矩阵模糊化得到的效果很差，得到的objects大于50左右，后面自己加上了形态学的操作，降到了5个，但是还是多了一个。






