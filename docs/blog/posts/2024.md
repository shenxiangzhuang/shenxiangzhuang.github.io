---
title: 2024
draft: true
date: 2024-12-28
authors: [mathew]
slug: 2024_summary
description: >
    2024 年度总结。
categories:
  - 随笔
  - 回忆录
  - 终身学习
---

# 2024

总结一下 2024 年。

<!-- more -->

## 工作和学习

### GitHub 上的 6 个里程碑

在 2024 年初的时候决定 All in GitHub 来记录各项事宜：博客，读书计划，项目计划……
同时在年初的时候为 2024 年列了 6 个里程碑来大致确定这一年学习的方向。

6 个里程碑如下，分别是后端 (Python 技术栈)，前端 (React&Nextjs)，语言学习 (Rust & Elixir)，大语言模型 (LLMPaper 阅读)，最佳工程实践 (输出博客):

- [2024-Backend: Python develop stack/tools](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/7): 学习，实践，总结 Python 后端开发技术栈
- [2024-Frontend: React](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/8): 学习 React(Next.js)，总结相关工具，以开发简单 Web 页面为阶段性目标
- [2024-Language Learning: Rust](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/5): Rust 语言学习：初步了解学习，以完成一个项目为阶段目标
- [2024-Language Learning: Elixir](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/6): Elixir 语言学习：初步学习，深入了解 Actor 模型，以完成一个项目为阶段性目标
- [2024-Engineering: Best Practice](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/9): 总结 SDE & MLE 最佳工程实践，以几篇代表性的 Blog 为阶段性目标
- [2024-LLM: Read all the papers in reading list](https://github.com/shenxiangzhuang/shenxiangzhuang.github.io/milestone/4): 大量阅读 LLM 相关论文

先做个简要的总结：前 4 个里程碑基本上是达成了的；最佳工程实践这部分算是差强人意；最后 LLM 论文的里程碑基本算作未达成。

#### Backend: Python develop stack/tools

Python 相关的后端开发主要是工作中用的多一些，这部分的学习和应用比我想象中要简单一些，当然这也要归功于 FastAPI 优秀的文档。
相关的学习资料记录在[Backend/Python](https://datahonor.com/se/backend/python/)。
期间为了加深对 Async 的理解，又读完了[Python Concurrency with asyncio](https://datahonor.com/se/backend/python/#books)这本书。

#### Frontend: React

由于 LLM 辅助编程工具的大量涌现，前端的学习变得更加简单。2024 年和前端有关的学习和实践都在[AI Glimpse](https://aiglimpse.datahonor.com/)的官网。
主要的改动是 Docs 和 Blog 部分的集成，这里采用的是[fumadocs](https://github.com/fuma-nama/fumadocs)，集成过程相当丝滑。
得益于优秀的框架和前端丰富的第三方库，目前网站 Docs/Blog 已经对 MDX 有了很好的支持：
数学公式和代码的友好显示，浏览器本地运行 Python 代码，BibTex 集成，评论系统集成……
至此，总算搭建起一个基础的面向教育的站点框架，接下来就是内容的逐渐丰富了。

#### Language Learning: Rust

Rust 的学习和实践过程是比较令我惊喜的。久闻 Rust 有着极为陡峭的学习曲线，我在 2023 年的尝试也并不顺利——是的，它没有那么好学。
在今年的学习过程中，我的策略是少看一些书，多写一些代码。


所以我在 4 月份着手写了第一个 Rust 库：[bleuscore](https://github.com/shenxiangzhuang/bleuscore)。
写这个库的原因有两个：一是 BLEU 分数是一个比较经典且并不复杂的算法，适合作为 Rust 的入门练习；
二是我发现 Huggingface 的 Evaluate 库对 BLEU 的支持并不好 ([#10](https://github.com/shenxiangzhuang/bleuscore/issues/10))。
其实我觉着 Huggingface 对这个库的维护态度很值得商榷，看 GitHub 上的 [Issue](https://github.com/huggingface/evaluate/issues)
就能看出来，很多重要的 Issue 都没有得到解决，这也是我写这个库的原因之一。
这个库从设计到实现，再到测试发布都是花了一些心思的。
首先整个库的架构是 Rust 做核心实现，同时作为独立的库发布到 crate.io；
之后通过 PyO3 增加 Python Binding，发布到 PyPI。（后续打算增加 JS Binding 并发布到 NPM）

至于 Python 库接口的设计，为了方便用户从 Evaluate 库迁移，我参考了 Huggingface 的 Evaluate 库的接口设计，最后的调用方式和参数基本一致：

```diff
- import evaluate
+ import bleuscore

predictions = ["hello there general kenobi", "foo bar foobar"]
references = [
    ["hello there general kenobi", "hello there !"],
    ["foo bar foobar"]
]

- bleu = evaluate.load("bleu")
- results = bleu.compute(predictions=predictions, references=references)
+ results = bleuscore.compute(predictions=predictions, references=references)

print(results)
# {'bleu': 1.0, 'precisions': [1.0, 1.0, 1.0, 1.0], 'brevity_penalty': 1.0,
# 'length_ratio': 1.1666666666666667, 'translation_length': 7, 'reference_length': 6}

```

另外一个比较有意思的地方就是测试部分。首先基本的单元测试和集成测试在 Rust 内部测试就够了。
但是我在写这个库的时候更关系的是算法实现的正确性，我需要 100% 确保我实现的 BLEU 算法和 Huggingface 的 Evaluate 库的 BLEU 算法是一致的。
这点其实非常重要，因为 BLEU 算法的流程虽然简单，但是有很多细节需要注意，尤其一些正则表达式的处理。
这就需要做一些类似 Property-based Testing 的测试，[具体做法](https://github.com/shenxiangzhuang/bleuscore/blob/5619351a4f22486151be6ec57421484e8e25f50d/tests/test_bleu_score.py)
是用 Python 的 Hypothesis 库在大量随机输入上测试 bleuscore 和 Evaluate 库的输出是否一致。
后来我发现有别的库也在做类似的事情，比如 [evalica](https://github.com/dustalov/evalica)(这里的方法甚至还能更加优雅一些！)。

总的来说，这个库的设计和实现过程让我对 Rust 有了更深的理解，也让我对 BLEU 算法有了更深的理解，是个很不错的体验。

#### Language Learning: Elixir

