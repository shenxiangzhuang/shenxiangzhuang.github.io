<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019</title>
    <url>/2019/12/30/2019/</url>
    <content><![CDATA[<h2 id="2019">2019</h2>
<p>​	去年在小岛上过年的时候，我完全没有想到自己的2019年会过得那么快。最近几年我都会写下总结，但是像今年这样心情复杂还是第一次。<br>
在小岛上一个人过年也挺开心，冬天的海南阳光正好，空气也好。考研也刚刚结束，时间多得是，一个人看看动漫，去看海，去打球。宿舍就我一个人，也可以通宵写代码，无拘无束。那个冬天是我读书以来最开心的一段时间，没有之一。</p>
<p>​	虽然我已经在准备调剂了，但好在扩招进了复试。期间HY介绍我和一起考研的朋友准备复试，大家帮助我很多。也向程学长和姚学姐请教了很多问题，Tomorrow学长也和初试学Casella的时候一样很热心地给我解答问题。我真的感谢这些朋友。复试的一幕幕我都还清晰的记得，记得大家一起在教室焦急地等待面试，记得YQ刚回到酒店就给我们写考到的概率题，记得Tukey在我前一个面试，出来的时候还特意帮我把门关上并嘱咐我先敲门再进比较好…我就像记得五年前在城西的傍晚和我打招呼的那位同学一样，记得她穿的是棕色的外套，记得每一个细节。</p>
<p>​	我不知道从什么时候开始，也许是小岛过年的那段时间，我开始非常珍惜每一个当下，每一个此时此刻。大四时理想的破灭，面对伫立在面前的事实，我思考了很久很久，也不知道思考什么，更不知道思考出什么结果出来，但是我能感到自己的变化，这种时刻凝视此时此刻而非抬头看天空的变化。但是我仍然不知道自己为什么会变，也不知道自己变成了什么样。</p>
<p>​	后来，毕业，各奔东西，度过了一个平淡的暑假。旅行？那已经是高中时代的期望了。之后开学，上了一周课，思考了很多，也明白了很多，也许本来就不该期待的。</p>
<p>​	对于课程和成绩等等，从大二开始我的想法就已经收敛了。任何一个人好好思考这些东西的人，都会想的很清楚，只要对自己足够诚实。</p>
<p>​	近来有和之前的朋友联系，也认识了新的朋友。我也渐渐地明白，原来大家都已经长大了，都不再是当年了。佳佳姐还是那么认真，来了广州考完试就回去备考期末了。转眼间瑶姐也不再是那个可爱的小姑娘了，开始工作了，看得出同样很认真，帮我解答很多银行的问题。静静也不再是那个曾经的国服第八了，开始谈教育问题了。废帝也不是那个即将去UCI的少年了，一路帮我那么多，转眼也都去读博了。有那么一瞬间我突然想起来他是在自动化所的，做的是Humanoid而不是我一直问他的Data Mining了…刚认识的二哥，一个人撑起一片天，让我们见识到了上古ACMer的强大和谦虚。后面包括简历的修改，学习方向的指点，可以说对我此后一生的发展都有着很大的意义。还有搞FP的大佬们细致地帮忙解答问题，直到我彻底明白。在他们身上学到的知识不是看几本书能抵得上的。有些时候，走在一条路上，能看到走在前面的前辈回头打声招呼，是很幸福的一件事。</p>
<p>​	就这样，日子一天一天过，我也跟着一天一天变，变成什么样自己也不知道。不过可以确信的一点就是自己已经不再是那个20岁少年了——那个口口声声改变世界的少年。但好在并没变成自己年轻时讨厌的样子，也没有认为自己成熟了，看开了，更没有觉得自己以前很幼稚，毕竟我似乎从未脱离幼稚。自己还是像以前一样自说自话，不顾别人的感受，立场和时区…还是一样不懂得察言观色，即使看了很多书，也一样不能明白对方言行举止到底代表着什么，更不知道该怎么表达自己想法。虽然一直在改，但是很明显没什么效果…</p>
<p>​	但是也突然明白了很多以前不懂的东西。明白了“天下就没有偶然”；也明白了盖茨比为何伟大，堂·吉诃德勇气的意义；真正明白了Catch-22；明白了木心为什么为约翰·克利斯朵夫式的朋友惋惜…原来会这么奇妙，原来可以在某一个瞬间明白这么多东西。</p>
<p>​	所以现在我是怎么样的状态呢？大概就是在考试周还有空写这个总结，走在路上还是想问中大校园飘散的这种香味到底是什么，还是会拼命思考校园那个神秘的踢毽子运动到底是怎么来的。</p>
<p>​	来年的我，就要开始工作，就要走上社会了吧。不知道这残存的棱角和好奇还能留下多少呢？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>About Hexo</title>
    <url>/2017/02/25/About-Hexo/</url>
    <content><![CDATA[<h6 id="自动开启编辑器">自动开启编辑器</h6>
<p>为Hexo 3增加新功能： hexo new “title” 后自动使用指定编辑器打开新建的md文件.<br>
System: Ubuntu16.04 64bit<br>
Editor: Haroopad</p>
<p>在hexo根目录下的<code>scripts</code>文件夹下面新建<code>open.js</code>文件，添加下面的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">spawn</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hexo 3</span></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="title function_">spawn</span>(<span class="string">&#x27;haroopad&#x27;</span>, [data.<span class="property">path</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="迁移">迁移</h6>
<p>之前的系统崩了，将完整的hexo文件备份，重装系统，将文件拷到电脑，安装nvm,配置node,记得版本不要最新的，官方推荐稳定版本即可。配置git,npm, 再hexo文件重新安装hexo，只进行一次安装命令即可[也就是不用hexo init这些初始化和配置的命令]</p>
<h6 id="更换评论系统">更换评论系统</h6>
<p>多说要崩，换Disqus, 但是要FQ才能加载出来，。对技术爱好者来说FQ是基本技能，所以还是选择了它。</p>
<h6 id="文末增加版权信息">文末增加版权信息</h6>
<p>参考<a href="https://www.jianshu.com/p/428244cd2caa">这里</a></p>
<h6 id="页脚居中">页脚居中</h6>
<p>参考<a href="http://www.wuxubj.cn/2016/07/footer-beautify-of-nexT/">这里</a></p>
<h6 id="点击心型特效">点击心型特效</h6>
<p>在<code>...\themes\next\source\js\src\</code>下新建<code>love.js</code>，代码如下：</p>
<blockquote>
<p>!function(e,t,a){function n(){c(“.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: ‘’;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}”),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y–,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=“left:”+d[e].x+“px;top:”+d[e].y+“px;opacity:”+d[e].alpha+“;transform:scale(”+d[e].scale+“,”+d[e].scale+“) rotate(45deg);background:”+d[e].color+“;z-index:99999”);requestAnimationFrame®}function o(){var t=“function”==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(“div”);a.className=“heart”,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(“style”);a.type=“text/css”;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(“head”)[0].appendChild(a)}function s(){return&quot;rgb(“+<s>(255*Math.random())+“,”+</s>(255<em>Math.random())+“,”+~~(255</em>Math.random())+”)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);</p>
</blockquote>
<p>在<code>...\themes\next\layout\_layout.swig</code>的最下方，<code>&lt;/body&gt;</code>前面添加<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></p>
<p>参考<a href="https://mapan.tech/posts/76c9.html">这里</a></p>
<h6 id="雪花特效">雪花特效</h6>
<p>参考<a href="https://www.smwenku.com/a/5c335416bd9eee35b21ce125">这里</a></p>
<h6 id="添加About菜单即相应页面">添加About菜单即相应页面</h6>
<p>参考<a href="http://www.jianshu.com/p/6c1196f12302">这里</a></p>
<p>next主题设置如下，将about的注释去掉即可：</p>
<pre><code># ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)
menu:
  home: /
  categories: /categories
  archives: /archives
  tags: /tags
  about: /about
  #sitemap: /sitemap.xml
  #commonweal: /404.html
</code></pre>
<p>之后<code>hexo new page about</code>，生成<code>source/about/index.md</code>，编辑相应内容即可。</p>
<h6 id="添加Jupyter-Notebook支持">添加Jupyter Notebook支持</h6>
<p>参考<a href="http://www.jianshu.com/p/6c1196f12302">这里</a></p>
<p>在<a href="http://nbviewer.jupyter.org/">nbviewer</a>，输入你的github用户名，找到项目文件，之后复制上面的url。<br>
在md文件直接添加<br>
<code>&lt;iframe src=&quot;your_URL&quot; width=&quot;700&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt;</code><br>
将your_URL换为上面已经复制的即可。</p>
<p>========2019.07.06更新==========</p>
<p>还是感觉上面的嵌入略丑…所以换成使用<code>hexo-jupyter-notebook</code>库来做嵌入，具体方法参考<a href="http://huanyouchen.github.io/2018/05/30/hexo-support-jupyter-notebook-in-blog/">这里</a></p>
<h6 id="行内公式问题">行内公式问题</h6>
<p>写个公式总是有问题，参考<a href="https://blog.csdn.net/wgshun616/article/details/81019687">这里</a>改了几个配置，暂时可以了。</p>
<p>(2019.6.13更新)</p>
<p>突然又显示不了公式，通过在文件中加入<code>mathjax: true</code>解决。</p>
<h6 id="不蒜子计数-网站浏览量-新版问题修复">不蒜子计数(网站浏览量)[新版问题修复]</h6>
<p>基本的方法比较简单，参考<a href="https://www.jianshu.com/p/c311d31265e0">这里</a>即可，next主主题尤为简单。</p>
<p>不过之前配置的方法已经不行了（所以早些时候的教程就不能用了，不过稍微改动一下就可以）。(Github)(<a href="https://github.com/iissnan/hexo-theme-next/issues/2174">https://github.com/iissnan/hexo-theme-next/issues/2174</a>)已经有人提了issue并解决了，修改<code>busuanzi-counter.swig</code>文件：</p>
<blockquote>
<p>注意，这里Github上给出的路径是<code>/next/layout/_third-party/analytics/busuanzi-counter.swig</code>不过我这里是在<code>/home/shensir/hexo/themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig</code>，可能不同系统不一样？不过我这里改了也是可以的。</p>
</blockquote>
<p>将这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>改为下面这行即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>另外，新版的next对其支持很好。</p>
<h6 id="升级hexo">升级hexo</h6>
<p>参考<a href="https://tommy.net.cn/2018/02/26/upgrade-hexo-to-v3-5-0/">这里</a></p>
<p>另外，由于七牛云的一些问题，会出现<code>ERROR Plugin load failed: hexo-qiniu-sync</code>，参考<a href="https://github.com/gyk001/hexo-qiniu-sync/issues/48">Github</a>,只需要：</p>
<blockquote>
<ul>
<li>删除_config.yml中的hexo-qiniu-sync配置字段</li>
<li>删除node_modules/文件夹下的qiniu文件夹和hexo-qiniu-sync 文件夹</li>
</ul>
</blockquote>
<p>即可。</p>
<h6 id="Valine-js评论系统">Valine.js评论系统</h6>
<p>参考<a href="https://11.tt/posts/2018/add-valine-to-your-blog/">这里</a></p>
<p>如果在<code>leancloud.</code>设置了<code>Web 安全域名</code>，那么需要将本地域名加进去，如<code>http://localhost:4000</code>，下面才不会显示请求错误。</p>
<h6 id="Comic">Comic</h6>
<p>参考<a href="https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/">这里</a></p>
<h6 id="域名解析">域名解析</h6>
<p>在执行<code>hexo g -d</code>之后访问域名<code>datahonor.com</code>发现404了，查了下发现是因为Github上对的github.io项目自动把设置的域名给清空了。这里直接把<code>datahonor.com</code>填回去保存就可以了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>About if __name__==&#39;__main__&#39; in Python</title>
    <url>/2017/05/08/About-if-name-main-in-Python/</url>
    <content><![CDATA[<h5 id="Overview">Overview</h5>
<p>关于<code>if __name__ == '__main__'</code>,一直想写个笔记，但是老忘，这里总结下。</p>
<p>总的来说，这句代码的作用是<strong>既能保证当前的py文件直接运行，也能保证其可以作为模块被其他py文件导入</strong>。</p>
<p>怎么理解这句话呢？我们通过几个小例子来看下。</p>
<h5 id="Code">Code</h5>
<h6 id="name">__name__</h6>
<p>首先任意创建一个py文件，仅输入一行代码</p>
<p><code>print(__name__)</code></p>
<p>然后运行，输出：</p>
<blockquote>
<p><strong>main</strong></p>
</blockquote>
<p>这说明，<code>__name__</code>本身是一个变量，但是不是一般的变量。它是在程序执行前就创建并赋值的，而赋值的机制是这里的关键。</p>
<p>在当前程序被当作主程序被执行的时候，<code>__name__</code>自动被赋值为固定的字符串<code>__main__</code>，当作为模块被其他文件调用的时候，自动被赋值为模块所在的文件名。</p>
<p>看下面一段程序,新建name_main.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==  <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printHello()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Hello World!<br>
<strong>main</strong></p>
</blockquote>
<p>那么，我们知道<code>__name__</code>此处是被赋值为<code>__main__</code>的，那么程序的逻辑就很清楚了。先是定义了一个函数，然后判断语句，最后判断通过执行函数。也许会问，不要这个判断，程序不是一样执行吗？当然，一样是可以的，我们完全可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(__name__)</span><br><span class="line"></span><br><span class="line">printHello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，问题就在与，当其作为模块被调用的时候。看下面一节的解释。</p>
<h6 id="from-xxx-import-xxx">from xxx import xxx</h6>
<p>保持name_main.py文件没有if语句，新建main_name1.py文件，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> name_main <span class="keyword">import</span> printHello</span><br><span class="line">printHello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>想一下，会发生什么？先看输出：</p>
<blockquote>
<p>Hello World!<br>
name_main<br>
Hello World!<br>
name_main</p>
</blockquote>
<p>首先，我们知道，作为模块调入，<code>—__name__</code> 自动被赋值为模块所在文件名，这点在意料之中。但是，我们明显看到，函数被执行了两次，这就关键所在！因为，在没有判断语句的时候，name_main在被调入的过程中就自动执行了一次（因为name_main本身就包含执行函数的部分），被调入后我们又主动调用一次，所以是两次。</p>
<p>那么，现在if语句的作用已经十分明确了，就是保证不重复执行函数。也就有了下面py文件的一般写法：</p>
<p><strong>name_main.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==  <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    printHello()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>name_main1.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> name_main <span class="keyword">import</span> printHello</span><br><span class="line">printHello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，我们单独运行name_main.py:</p>
<blockquote>
<p>Hello World!<br>
<strong>main</strong></p>
</blockquote>
<p>单独运行name_main1.py:</p>
<blockquote>
<p>Hello World!<br>
name_main</p>
</blockquote>
<p>可以看到，printHello函数都可以正常执行！这就是<code>if __name__== '__main__'</code>语句的作用。<br>
它保证我们既可以单独调试一个文件的函数和类等，有不影响其他文件的调用。</p>
<p>再次看下开头的那句话：</p>
<p><strong>既能保证当前的py文件直接运行，也能保证其可以作为模块被其他py文件导入</strong></p>
<h5 id="Reference">Reference</h5>
<p><a href="http://stackoverflow.com/questions/419163/what-does-if-name-main-do">stackoverflow</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记五：Accessing pixel values</title>
    <url>/2017/04/28/Accessing-pixel-values/</url>
    <content><![CDATA[<h5 id="Overview-2">Overview</h5>
<p>图片本就是由一个一个的像素点组成，我们有时候需要对一些特殊的像素点就行操作，而操作像素点的第一个问题就是如何获取到这些像素点。OpenCV为我们提供了at方法。</p>
<h5 id="Code-2">Code</h5>
<h6 id="Mat">Mat</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">salt</span><span class="params">(cv::Mat image, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// C++11 random number generator</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomRow</span><span class="params">(<span class="number">0</span>, image.rows <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomCol</span><span class="params">(<span class="number">0</span>, image.cols <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">        <span class="comment">// random image coordinate</span></span><br><span class="line">        i = <span class="built_in">randomCol</span>(generator);</span><br><span class="line">        j = <span class="built_in">randomRow</span>(generator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(image.<span class="built_in">type</span>() == CV_8UC1)&#123;</span><br><span class="line">            <span class="comment">// gray image, single-channel 8-bit image</span></span><br><span class="line">            image.<span class="built_in">at</span>&lt;uchar&gt;(j,i) = <span class="number">255</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)&#123;</span><br><span class="line">            <span class="comment">// color image, 3-channel image</span></span><br><span class="line">            image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">            image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">            image.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">            <span class="comment">// or in this way</span></span><br><span class="line">            <span class="comment">//image.at&lt;cv::Vec3b&gt;(j,i) = cv::Vec3b(255,255,255);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    <span class="built_in">salt</span>(image, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;salt-lake.jpg&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170427/3.png" alt=""></p>
<h6 id="Mat-2">Mat_</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for color image</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">salt</span><span class="params">(cv::Mat_&lt;cv::Vec3b&gt; image, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// C++11 random number generator</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomRow</span><span class="params">(<span class="number">0</span>, image.rows <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomCol</span><span class="params">(<span class="number">0</span>, image.cols <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">        <span class="comment">// random image coordinate</span></span><br><span class="line">        i = <span class="built_in">randomCol</span>(generator);</span><br><span class="line">        j = <span class="built_in">randomRow</span>(generator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// color image, 3-channel image</span></span><br><span class="line">        <span class="built_in">image</span>(j,i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">        <span class="built_in">image</span>(j,i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">        <span class="built_in">image</span>(j,i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">        <span class="comment">// or in this way</span></span><br><span class="line">        <span class="comment">//image(j,i) = cv::Vec3b(255,255,255);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// overload for gray image</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">salt</span><span class="params">(cv::Mat_&lt;uchar&gt; image, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// C++11 random number generator</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomRow</span><span class="params">(<span class="number">0</span>, image.rows <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">randomCol</span><span class="params">(<span class="number">0</span>, image.cols <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">        <span class="comment">// random image coordinate</span></span><br><span class="line">        i = <span class="built_in">randomCol</span>(generator);</span><br><span class="line">        j = <span class="built_in">randomRow</span>(generator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// gray image, single-channel 8-bit image</span></span><br><span class="line">        <span class="built_in">image</span>(j,i) = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// color</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt; image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">salt</span>(image, <span class="number">3000</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Salted Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gray</span></span><br><span class="line">    cv::Mat_&lt;uchar&gt; gray;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Gray&quot;</span>, gray);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">salt</span>(gray, <span class="number">3000</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Salted Gray&quot;</span>, gray);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170427/4.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十七：Adaptive thresholding</title>
    <url>/2017/05/15/Adaptive-thresholding/</url>
    <content><![CDATA[<h4 id="Overview-3">Overview</h4>
<p>在介绍Adaptive thresholding之前，让我们来看看Integral Image的概念：</p>
<blockquote>
<p>Integral images have been introduced as an efficient way of summing<br>
pixels in image regions of interest. They are widely used in applications<br>
that involve, for example, computations over sliding windows at multiple<br>
scales.</p>
</blockquote>
<p>可以看到，Integral Image是避免重复计算多个ROI像素值和的一种方法。接下来，我们实现的就是简单的矩形ROI，使得Integral Image上的每一个点的值为：该点和图像左上角形成的矩形区域像素值之和。</p>
<p>而Adaptive thresholding 是相对于fixed thresholding而言的。fixed就是我们之前常用的固定阀值，而Adaptive的阀值是由一个固定阀值和一个变化的均值决定的，这个均值，就是某像素点周围一些像素点的均值。</p>
<h4 id="Code-3">Code</h4>
<h5 id="integral-h">integral.h</h5>
<p>实际上，OpenCV已经提供了计算Integral Image的函数<code>cv::integral</code>，但是书上也自己实现了一边，我们这里也贴上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined IINTEGRAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IINTEGRAL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntegralImage</span> &#123;</span><br><span class="line"></span><br><span class="line">      cv::Mat integralImage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="built_in">IntegralImage</span>(cv::Mat image) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (costly) computation of the integral image</span></span><br><span class="line">        cv::<span class="built_in">integral</span>(image,integralImage,cv::DataType&lt;T&gt;::type);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// compute sum over sub-regions of any size from 4 pixel access</span></span><br><span class="line">      <span class="function">cv::Vec&lt;T,N&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> xo, <span class="type">int</span> yo, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// window at (xo,yo) of size width by height</span></span><br><span class="line">          <span class="keyword">return</span> (integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(yo+height,xo+width)</span><br><span class="line">                  -integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(yo+height,xo)</span><br><span class="line">                  -integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(yo,xo+width)</span><br><span class="line">                  +integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(yo,xo));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// compute sum over sub-regions of any size from 4 pixel access</span></span><br><span class="line">      <span class="function">cv::Vec&lt;T,N&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// square window centered at (x,y) of size 2*radius+1</span></span><br><span class="line">          <span class="keyword">return</span> (integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(y+radius+<span class="number">1</span>,x+radius+<span class="number">1</span>)</span><br><span class="line">                  -integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(y+radius+<span class="number">1</span>,x-radius)</span><br><span class="line">                  -integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(y-radius,x+radius+<span class="number">1</span>)</span><br><span class="line">                  +integralImage.at&lt;cv::Vec&lt;T,N&gt; &gt;(y-radius,x-radius));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert to a multi-channel image made of binary planes</span></span><br><span class="line"><span class="comment">// nPlanes must be a power of 2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">convertToBinaryPlanes</span><span class="params">(<span class="type">const</span> cv::Mat&amp; input, cv::Mat&amp; output, <span class="type">int</span> nPlanes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// number of bits to mask out</span></span><br><span class="line">        <span class="type">int</span> n= <span class="number">8</span>-<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(nPlanes))/<span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">        <span class="comment">// mask used to eliminate least significant bits</span></span><br><span class="line">        uchar mask= <span class="number">0xFF</span>&lt;&lt;n; <span class="comment">// e.g. for div=16, mask= 0xF0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a vector of 16 binary images</span></span><br><span class="line">        std::vector&lt;cv::Mat&gt; planes;</span><br><span class="line">        <span class="comment">// reduce to nBins bins by eliminating least significant bits</span></span><br><span class="line">        cv::Mat reduced= input&amp;mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute each binary image plane</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nPlanes; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 for each pixel equals to i&lt;&lt;shift</span></span><br><span class="line">            planes.<span class="built_in">push_back</span>((reduced==(i&lt;&lt;n))&amp;<span class="number">0x1</span>);  <span class="comment">// i&lt;&lt;n  --&gt; 16, 32, 48, ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create multi-channel image</span></span><br><span class="line">        cv::<span class="built_in">merge</span>(planes,output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-cpp">main.cpp</h5>
<p>这里介绍了，OpenCV自带的fixed thresholding， Adaptive thresholding, boxFilter的用法，同时运用Integral Image重新实现了一遍Adaptive thresholding.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;integral.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/book.png&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// display original image</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Original Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using a fixed threshold</span></span><br><span class="line">    cv::Mat binaryFixed;</span><br><span class="line">    cv::Mat binaryAdaptive;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(image, binaryFixed,<span class="number">70</span>,<span class="number">255</span>,cv::THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//using as adaptive threshold</span></span><br><span class="line">    <span class="type">int</span> blockSize=<span class="number">21</span>;  <span class="comment">//size of the neighborhood</span></span><br><span class="line">    <span class="type">int</span> threshold=<span class="number">10</span>;  <span class="comment">// pixel will be compare to (mean-threshold)</span></span><br><span class="line"></span><br><span class="line">    int64 time;</span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">    cv::<span class="built_in">adaptiveThreshold</span>(</span><br><span class="line">            image,  <span class="comment">//input image</span></span><br><span class="line">            binaryAdaptive, <span class="comment">// output binary image</span></span><br><span class="line">            <span class="number">255</span>,  <span class="comment">//max value for output</span></span><br><span class="line">            cv::ADAPTIVE_THRESH_GAUSSIAN_C, <span class="comment">// adaptive method</span></span><br><span class="line">            cv::THRESH_BINARY, <span class="comment">//threshold type</span></span><br><span class="line">            blockSize,</span><br><span class="line">            threshold</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>() - time;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;time (adaptiveThreshold) =  &quot;</span>&lt;&lt;time&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute integral image</span></span><br><span class="line">    IntegralImage&lt;<span class="type">int</span>, <span class="number">1</span>&gt;<span class="built_in">integral</span>(image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test integral image</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;sum = &quot;&lt;&lt;integral(18, 45,30, 50)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    cv::Mat test(image, cv::Rect(18,45,30,50));</span></span><br><span class="line"><span class="comment">//    cv::Scalar t = cv::sum(test);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;sum test = &quot;&lt;&lt;t[0]&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Fixed Threshold&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Fixed Threshold&quot;</span>, binaryFixed);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Adaptive Threshold&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Adaptive Threshold&quot;</span>, binaryAdaptive);</span><br><span class="line"></span><br><span class="line">    cv::Mat binary = image.<span class="built_in">clone</span>();</span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">    <span class="type">int</span> nl = binary.rows; <span class="comment">// number of lines</span></span><br><span class="line">    <span class="type">int</span> nc = binary.cols; <span class="comment">// total number of elements per line</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute integral image</span></span><br><span class="line">    cv::Mat iimage;</span><br><span class="line">    cv::<span class="built_in">integral</span>(image, iimage, CV_32S);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for each row</span></span><br><span class="line">    <span class="type">int</span> halfSize = blockSize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=halfSize; j&lt;nl - halfSize <span class="number">-1</span>;j++ )&#123;</span><br><span class="line">        <span class="comment">// get the address of row j</span></span><br><span class="line">        uchar* data = binary.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="type">int</span>* idata1 = iimage.<span class="built_in">ptr</span>&lt;<span class="type">int</span>&gt;(j-halfSize); <span class="comment">// 滑动窗口上边</span></span><br><span class="line">        <span class="type">int</span>* idata2 = iimage.<span class="built_in">ptr</span>&lt;<span class="type">int</span>&gt;(j+halfSize+<span class="number">1</span>); <span class="comment">// 滑动窗口下边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//for pixel of a line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=halfSize; i&lt;nc-halfSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//compute pix_mean</span></span><br><span class="line">            <span class="type">int</span> pix_mean = (idata2[i+halfSize+<span class="number">1</span>]-idata2[i-halfSize]-idata1[i+halfSize+<span class="number">1</span>]</span><br><span class="line">            +idata1[i-halfSize])/(blockSize*blockSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//apply adaptive threshold</span></span><br><span class="line">            <span class="keyword">if</span>(data[i]&lt;(pix_mean-threshold))</span><br><span class="line">                data[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                data[i]  =<span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add white border</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;halfSize;j++)&#123;</span><br><span class="line">        uchar *data = binary.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;binary.cols;i++)</span><br><span class="line">            data[i] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=binary.rows-halfSize<span class="number">-1</span>;j&lt;binary.rows;j++)&#123;</span><br><span class="line">        uchar * data = binary.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;binary.cols;i++)&#123;</span><br><span class="line">            data[i] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=halfSize;j&lt;nl-halfSize<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        uchar* data = binary.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;halfSize;i++)</span><br><span class="line">            data[i] = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=binary.cols-halfSize<span class="number">-1</span>;i&lt;binary.cols;i++)</span><br><span class="line">            data[i] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>()-time;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time integral= &quot;</span>&lt;&lt;time&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Adaptive Threshold (integral)&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Adaptive Threshold (integral)&quot;</span>, binary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adaptive threshold using image operators</span></span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">    cv::Mat filtered;</span><br><span class="line">    cv::Mat binaryFiltered;</span><br><span class="line">    <span class="comment">// box filter compute avg of pixels over a rectangle region</span></span><br><span class="line">    cv::<span class="built_in">boxFilter</span>(image, filtered, CV_8U, cv::<span class="built_in">Size</span>(blockSize,blockSize));</span><br><span class="line">    <span class="comment">// check if pixel greater than (mean+shreshold)</span></span><br><span class="line">    binaryFiltered = image&gt;=(filtered-threshold);</span><br><span class="line">    time = cv::<span class="built_in">getTickCount</span>()-time;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time filtered= &quot;</span>&lt;&lt;time&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Adaptive filtered&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Adaptive filtered&quot;</span>, binaryFiltered);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170515/AdF.png" alt=""></p>
<blockquote>
<p>time (adaptiveThreshold) =  2305893<br>
time integral= 7118664<br>
time filtered= 1179760</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda使用笔记</title>
    <url>/2017/03/02/Anaconda%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-conda-search-and-conda-install">1. conda search and conda install</h2>
<p>在我们用conda install 安装包时，可能会出现像下面这种找不到的情况。<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/1.png" alt=""><br>
这样我们就按照提示操作进行搜索：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/2.png" alt=""><br>
这时根据自己的系统找到对应的包进行如下尝试[之所以说尝试是因为，有时候会因依赖冲突等问题安装不成功]，进行安装：</p>
<p>比如我的系统是linux64, 我尝试安装这个版本的包<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/3.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/4.png" alt=""><br>
之后就是确认安装了：</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/5.png" alt=""><br>
打开ipython进行检验：</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/Anaconda/6.png" alt=""><br>
可以看到安装成功。</p>
<h2 id="2-重装Anaconda">2. 重装Anaconda</h2>
<p>因为之前混着用<code>pip install</code>和<code>conda install</code>，把base环境搞坏掉了，没法更新。试了很多方法感觉都不行，所以干脆重装了。</p>
<p>首先是按照<a href="https://docs.anaconda.com/anaconda/install/uninstall/">官网指引</a>进行卸载。之后也是看<a href="https://docs.anaconda.com/anaconda/install/linux/">文档</a>重新安装即可。这次吸取的教训就是没事不要去动base，否则后面冲突的话很麻烦。有需要就新建一个环境。</p>
<h2 id="3-换源">3.换源</h2>
<p>使用清华源，参考<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">文档</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Argparse&amp;Test&amp;Logging</title>
    <url>/2019/06/15/Argparse-unittest-doctest-logging/</url>
    <content><![CDATA[<h3 id="argparse">argparse</h3>
<p><a href="https://docs.python.org/3/howto/argparse.html?highlight=argparse">Argparse Tutorial</a>: This tutorial is intended to be a gentle introduction to argparse, the recommended command-line parsing module in the Python standard library.</p>
<p>A demo:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;x&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;the base&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;y&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;the exponent&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-v&quot;</span>, <span class="string">&quot;--verbosity&quot;</span>, action=<span class="string">&quot;count&quot;</span>, default=<span class="number">0</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">answer = args.x**args.y</span><br><span class="line"><span class="keyword">if</span> args.verbosity &gt;= <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Running &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(__file__))</span><br><span class="line"><span class="keyword">if</span> args.verbosity &gt;= <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;^&#123;&#125; == &quot;</span>.<span class="built_in">format</span>(args.x, args.y), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -v</span><br><span class="line"><span class="number">4</span>^<span class="number">2</span> == <span class="number">16</span></span><br><span class="line">$ python3 prog.py <span class="number">4</span> <span class="number">2</span> -vv</span><br><span class="line">Running <span class="string">&#x27;prog.py&#x27;</span></span><br><span class="line"><span class="number">4</span>^<span class="number">2</span> == <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>补充<code>vars</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">&#x27;--foo&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = parser.parse_args([<span class="string">&#x27;--foo&#x27;</span>, <span class="string">&#x27;BAR&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">vars</span>(args)</span><br><span class="line">&#123;<span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;BAR&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test">Test</h3>
<p>主要介绍四种测试工具，分别是<code>doctest</code>, <code>unitest</code>, <code>hypethesis</code>和<code>pytest</code>。其中，前三种均可以和<code>pytest</code>结合使用.(注意其检测的是文件名为<code>test_xxx.py</code>或者<code>xxx_test.py</code>的文件，具体参考文档)</p>
<p>此外，<code>hypothesis</code>还可以和<code>unittest</code>结合使用。</p>
<h4 id="doctest">doctest</h4>
<p><a href="https://docs.python.org/3/library/doctest.html">doctest</a> — Test interactive Python examples</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the factorial of n, an exact integer &gt;= 0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be &gt;= 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Factorials of floats are OK, but the float must be an exact integer:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be exact integer</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.0)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It must also not be ridiculously large:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(1e100)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    OverflowError: n too large</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;n must be &gt;= 0&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> math.floor(n) != n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;n must be exact integer&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> n+<span class="number">1</span> == n:  <span class="comment"># catch a value like 1e300</span></span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">&quot;n too large&quot;</span>)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> factor &lt;= n:</span><br><span class="line">        result *= factor</span><br><span class="line">        factor += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里我们不仅可以进行测试，也可以在顶部对函数进行注释。当然，下面的测试也会自动加入文档注释之中。</p>
</blockquote>
<p>补充，终端下测试：<code>python -m doctest -v example.py</code></p>
<p>与<code>pytest</code>结合，终端运行：<code>pytest --doctest-modules</code>,注意其作用为“run doctests in all .py modules”。</p>
<h4 id="unittest">unittest</h4>
<p><a href="https://docs.python.org/3/library/unittest.html">unittest</a>——Unit testing framework</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStringMethods</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_upper</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertEqual(<span class="string">&#x27;foo&#x27;</span>.upper(), <span class="string">&#x27;FOO&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_isupper</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertTrue(<span class="string">&#x27;FOO&#x27;</span>.isupper())</span><br><span class="line">        self.assertFalse(<span class="string">&#x27;Foo&#x27;</span>.isupper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_split</span>(<span class="params">self</span>):</span><br><span class="line">        s = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        self.assertEqual(s.split(), [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>])</span><br><span class="line">        <span class="comment"># check that s.split fails when the separator is not a string</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            s.split(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意一点，这里使用unittest可以在<code>test_xxx</code>函数内部任意位置调用<code>self.assertEqual</code>等命令来进行测试，于此不同的是<code>doctest</code>一般是对整个函数进行测试，也是通过计算结果与预期结果的对比。</p>
</blockquote>
<p>补充<code>@unittest.skipIf(*condition*, *reason*)</code>：</p>
<blockquote>
<p>Skip the decorated test if <em>condition</em> is true.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestSVM</span>(unittest.TestCase):</span><br><span class="line">    skip_flag = <span class="literal">False</span></span><br><span class="line"><span class="meta">    @unittest.skipIf(<span class="params">skip_flag, <span class="string">&quot;debug&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_e71</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="hypothesis"><a href="https://github.com/HypothesisWorks/hypothesis/tree/master/hypothesis-python">hypothesis</a></h4>
<p><code>hypothesis</code>是类似于<code>haskell</code>中<code>QuickCheck</code>的“property-based testing”，但是还是有些不同的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hypothesis <span class="keyword">import</span> given</span><br><span class="line"><span class="keyword">import</span> hypothesis.strategies <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@given(<span class="params">x=st.integers(<span class="params"></span>), y=st.integers(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_ints_cancel</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">assert</span> (x + y) - y == x</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestCommutative</span>(unittest.TestCase):</span><br><span class="line"><span class="meta">    @given(<span class="params">x=st.integers(<span class="params"></span>), y=st.integers(<span class="params"></span>)</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_ints_are_commutative</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.assertEqual(x+y, y+x)</span><br></pre></td></tr></table></figure>
<p>第一种方法是原生的写法，后面一种是和<code>unittest</code>结合的写法，两种写法均可，且均可以直接在终端运行<code>pytest</code>完成检测。注意文件名要用<code>xxx_test.py</code>和<code>test_xxx.py</code>的格式，此外还有其他可选的参数。</p>
<h4 id="pytest"><a href="https://docs.pytest.org/en/latest/index.html">pytest</a></h4>
<blockquote>
<p>Due to <code>pytest</code>’s detailed assertion introspection, only plain <code>assert</code> statements are used.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># content of test_sample.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_answer</span>():</span><br><span class="line">    <span class="keyword">assert</span> inc(<span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>执行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pytest</span><br><span class="line">=========================== test session starts ============================</span><br><span class="line">platform linux -- Python 3.x.y, pytest-4.x.y, py-1.x.y, pluggy-0.x.y</span><br><span class="line">cachedir: $PYTHON_PREFIX/.pytest_cache</span><br><span class="line">rootdir: $REGENDOC_TMPDIR</span><br><span class="line">collected 1 item</span><br><span class="line"></span><br><span class="line">test_sample.py F                                                     [100%]</span><br><span class="line"></span><br><span class="line">================================= FAILURES =================================</span><br><span class="line">_______________________________ test_answer ________________________________</span><br><span class="line"></span><br><span class="line">    def test_answer():</span><br><span class="line">&gt;       assert inc(3) == 5</span><br><span class="line">E       assert 4 == 5</span><br><span class="line">E        +  where 4 = inc(3)</span><br><span class="line"></span><br><span class="line">test_sample.py:6: AssertionError</span><br><span class="line">========================= 1 failed in 0.12 seconds =========================</span><br></pre></td></tr></table></figure>
<h3 id="logging">logging</h3>
<p><a href="https://docs.python.org/3/howto/logging.html#logging-basic-tutorial">Logging HOWTO——Basic Logging Tutorial</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestSVM</span>(unittest.TestCase):</span><br><span class="line">    skip_flag = <span class="literal">False</span></span><br><span class="line"><span class="meta">    @unittest.skipIf(<span class="params">skip_flag, <span class="string">&quot;debug&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_e71</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#...</span></span><br><span class="line">        logger.info(<span class="string">&quot;\n res is \n %s \n x is \n %s\n&quot;</span> % (<span class="built_in">str</span>(res), res[<span class="string">&quot;x&quot;</span>]))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">    logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<h3 id="Reference-2">Reference</h3>
<p><a href="https://docs.python.org/3/library/">Python doc</a></p>
<p><a href="https://hypothesis.readthedocs.io/en/latest/quickstart.html#writing-tests">hypothesis doc</a></p>
<p><a href="https://docs.python-guide.org/writing/tests/">python-guide.org</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Atom使用</title>
    <url>/2018/01/28/Atom%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Overview-4">Overview</h4>
<p>关于Atom使用的一些记录。</p>
<h4 id="快捷键">快捷键</h4>
<p><code>Ctrl+，</code>打开setting.</p>
<p><code>Ctrl+Shift+B</code>，使用Script插件运行程序</p>
<h4 id="字体大小调整">字体大小调整</h4>
<p>一般Editor的字体的调整，直接去Setting-&gt;Editor改就行了。至于插件的字体调整，如果插件本身无法设置，可以去stylesheet设置。可以Edit-&gt;Stylesheet或者Setting-&gt;Theme-&gt;stylesheet。</p>
<p>比如设置Script运行程序后的输出字体大小为16px，只需要在文件最后加上：</p>
<blockquote>
<p>.script-view .line {<br>
font-size: 16px;<br>
}</p>
</blockquote>
<p>参考<a href="https://discuss.atom.io/t/change-font-size-in-console-when-using-script-package/19656/3">这里</a></p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>Awesome Tools in Github</title>
    <url>/2019/06/16/Awesome-Tools-in-Github/</url>
    <content><![CDATA[<h3 id="tldr"><a href="https://github.com/tldr-pages/tldr">tldr</a></h3>
<p>非常好用的命令行辅助工具。</p>
<p><img src="https://raw.githubusercontent.com/tldr-pages/tldr/master/screenshot.png" alt=""></p>
<h3 id="learnGitBranching"><a href="https://github.com/pcottle/learnGitBranching">learnGitBranching</a></h3>
<p><a href="https://pcottle.github.com/learnGitBranching/">官网</a>给出了非常友好的学习Git分支的教程。</p>
<h3 id="howdoi"><a href="https://github.com/gleitz/howdoi">howdoi</a></h3>
<p>需要配合<code>proxychains</code>才能用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ howdoi <span class="built_in">print</span> stack trace python</span><br><span class="line">&gt; <span class="keyword">import</span> traceback</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt;     <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">&gt; <span class="keyword">except</span>:</span><br><span class="line">&gt;     <span class="built_in">print</span> <span class="string">&#x27;&gt;&gt;&gt; traceback &lt;&lt;&lt;&#x27;</span></span><br><span class="line">&gt;     traceback.print_exc()</span><br><span class="line">&gt;     <span class="built_in">print</span> <span class="string">&#x27;&gt;&gt;&gt; end of traceback &lt;&lt;&lt;&#x27;</span></span><br><span class="line">&gt; traceback.print_exc()</span><br></pre></td></tr></table></figure>
<h3 id="PySnooper"><a href="https://github.com/cool-RR/PySnooper">PySnooper</a></h3>
<p>Never use print for debugging again!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pysnooper</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        lst.append(random.randrange(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> pysnooper.snoop():</span><br><span class="line">        lower = <span class="built_in">min</span>(lst)</span><br><span class="line">        upper = <span class="built_in">max</span>(lst)</span><br><span class="line">        mid = (lower + upper) / <span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(lower, mid, upper)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New var:....... i = 9</span><br><span class="line">New var:....... lst = [681, 267, 74, 832, 284, 678, ...]</span><br><span class="line">09:37:35.881721 line        10         lower = min(lst)</span><br><span class="line">New var:....... lower = 74</span><br><span class="line">09:37:35.882137 line        11         upper = max(lst)</span><br><span class="line">New var:....... upper = 832</span><br><span class="line">09:37:35.882304 line        12         mid = (lower + upper) / 2</span><br><span class="line">74 453.0 832</span><br><span class="line">New var:....... mid = 453.0</span><br><span class="line">09:37:35.882486 line        13         print(lower, mid, upper)</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="https://github.com/yihui/animation"><strong>animation</strong></a></h3>
<p>A gallery of animations in statistics and utilities to create animations.</p>
<p>非常好用的R包。</p>
<h3 id="swirl"><a href="https://github.com/swirldev/swirl">swirl</a></h3>
<p>Learn R, in R: <a href="http://swirlstats.com">http://swirlstats.com</a></p>
<p>&lt;未竟&gt;</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>BST&amp;BT in Cpp</title>
    <url>/2017/08/05/BST-in-Cpp/</url>
    <content><![CDATA[<h4 id="Overview-5">Overview</h4>
<p>时间比较段，看数学来不及，就继续找来Youtube视频学习数据结构了。视频真的不错，讲解很透彻，用C/Cpp实现的，<a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;index=29&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">传送门</a>。今天看的是BST（Binary Search Tree）,即二叉排序树。</p>
<h4 id="Code-4">Code</h4>
<h5 id="BST">BST</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// BST Node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BstNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    BstNode *left;</span><br><span class="line">    BstNode *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BstNode *<span class="title">GetNewNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    BstNode *newNode = <span class="keyword">new</span> <span class="built_in">BstNode</span>();</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BstNode *<span class="title">Insert</span><span class="params">(BstNode *root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="built_in">GetNewNode</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt;= root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(BstNode *root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data == data) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt;= root-&gt;data) <span class="built_in">Search</span>(root-&gt;left, data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FindElement</span><span class="params">(BstNode *root, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Search</span>(root, number)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Min-Max--&gt;By Loops</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMin</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于这里root只是局部变量，所以可以直接让其一直进入左枝即可</span></span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMax</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于这里root只是局部变量，所以可以直接让其一直进入右枝即可</span></span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Min-Max--&gt;By recursion</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FinMinRec</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FinMinRec</span>(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FinMaxRec</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FinMaxRec</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最小值对应的内存地址</span></span><br><span class="line"><span class="function">BstNode* <span class="title">FindMinAddrRec</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FindMinAddrRec</span>(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Breadth First Travel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BstNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;BstNode *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        BstNode *current = Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete a node from a binary tree</span></span><br><span class="line"><span class="function">BstNode* <span class="title">Delete</span><span class="params">(BstNode* root, <span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; root-&gt;data) root-&gt;left = <span class="built_in">Delete</span>(root-&gt;left, data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; root-&gt;data) root-&gt;right = <span class="built_in">Delete</span>(root-&gt;right, data);</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">// Wohoo...I found you. Get ready to be deleted</span></span><br><span class="line">        <span class="comment">// Case1: No child</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2: One child</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            BstNode* temp;</span><br><span class="line">            temp = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            BstNode* temp;</span><br><span class="line">            temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BstNode* temp = <span class="built_in">FindMinAddrRec</span>(root-&gt;right);</span><br><span class="line">            root-&gt;data = temp-&gt;data;</span><br><span class="line">            root-&gt;right = <span class="built_in">Delete</span>(root-&gt;right, temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return value&#x27;s addr</span></span><br><span class="line"><span class="function">BstNode* <span class="title">Find</span><span class="params">(BstNode *root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data == data) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt;= root-&gt;data) <span class="built_in">Find</span>(root-&gt;left, data);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Find</span>(root-&gt;right, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to find Inorder Successor in a BST</span></span><br><span class="line"></span><br><span class="line"><span class="function">BstNode* <span class="title">Getsuccessor</span><span class="params">(BstNode* root, <span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Serch the Node</span></span><br><span class="line">    BstNode* current = <span class="built_in">Find</span>(root, data);</span><br><span class="line">    <span class="keyword">if</span>(current == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// Case 1: Node has right substree</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FindMinAddrRec</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  <span class="comment">// Case 2: No right substree</span></span><br><span class="line">        BstNode* successor = <span class="literal">NULL</span>;</span><br><span class="line">        BstNode* ancestor = root;</span><br><span class="line">        <span class="keyword">while</span>(ancestor != current)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;data &lt; ancestor-&gt;data)&#123;</span><br><span class="line">                successor = ancestor;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ancestor = ancestor-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BstNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">15</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">10</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">25</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">8</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">12</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">17</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is 8 in the BST: &quot;</span> &lt;&lt; <span class="built_in">FindElement</span>(root, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Find Min By Loops: &quot;</span> &lt;&lt; <span class="built_in">FindMin</span>(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Find Max By Loops: &quot;</span> &lt;&lt; <span class="built_in">FindMax</span>(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Find Min By Recursion: &quot;</span> &lt;&lt; <span class="built_in">FinMinRec</span>(root) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Find Max By Recursion: &quot;</span> &lt;&lt; <span class="built_in">FinMaxRec</span>(root) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before the deletion: &quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(root);</span><br><span class="line">    <span class="built_in">Delete</span>(root, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After the delation: &quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The successor of 12: &quot;</span>;</span><br><span class="line">    BstNode* successor = <span class="built_in">Getsuccessor</span>(root, <span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; successor-&gt;data &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行输出：</p>
<pre><code>Is 8 in the BST: 1
Find Min By Loops: 8
Find Max By Loops: 25
Find Min By Recursion: 8
Find Max By Recursion: 25
Before the deletion: 15 10 20 8 12 17 25 
After the delation: 15 12 20 8 17 25 
The successor of 12: 15
</code></pre>
<h5 id="BT">BT</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// BST Node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">GetNewNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里其实是普通二叉树，为了方便我们还是用原来的顺序插入方式</span></span><br><span class="line"><span class="function">Node *<span class="title">Insert</span><span class="params">(Node *root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="built_in">GetNewNode</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt;= root-&gt;data) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the height if the binary tree</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindHeight</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 这里返回-1是为了恰好使得leaf的height为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">FindHeight</span>(root-&gt;left), <span class="built_in">FindHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Breadth First Travel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tree is empty\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node *&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *current = Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Depth First Travel --&gt; Preorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Depth First Travel --&gt; Inorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Depth First Travel --&gt; Postorder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if a binary tree is a binary search tree of not</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Way1</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSubtreeLesser</span><span class="params">(Node *root, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        root-&gt;data &lt;= value</span><br><span class="line">        &amp;&amp; <span class="built_in">IsSubtreeLesser</span>(root-&gt;left, value)</span><br><span class="line">        &amp;&amp; <span class="built_in">IsSubtreeLesser</span>(root-&gt;right, value)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSubtreeGreater</span><span class="params">(Node *root, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">            root-&gt;data &gt; value</span><br><span class="line">            &amp;&amp; <span class="built_in">IsSubtreeGreater</span>(root-&gt;left, value)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsSubtreeGreater</span>(root-&gt;right, value)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">            <span class="built_in">IsSubtreeLesser</span>(root-&gt;left, root-&gt;data)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsSubtreeGreater</span>(root-&gt;right, root-&gt;data)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsBinarySearchTree</span>(root-&gt;left)</span><br><span class="line">            &amp;&amp; <span class="built_in">IsBinarySearchTree</span>(root-&gt;right))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way2</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBstUtil</span><span class="params">(Node* root, <span class="type">int</span> minValue, <span class="type">int</span> maxValue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        root-&gt;data &gt;= minValue</span><br><span class="line">        &amp;&amp; root-&gt;data &lt; maxValue</span><br><span class="line">        &amp;&amp; <span class="built_in">IsBstUtil</span>(root-&gt;left, minValue, root-&gt;data)</span><br><span class="line">        &amp;&amp; <span class="built_in">IsBstUtil</span>(root-&gt;right, root-&gt;data, maxValue)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree_ByBound</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">IsBstUtil</span>(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way3</span></span><br><span class="line"><span class="comment">// 如果是BST那么Inorder遍历之后，对应的数组应该是从小到大顺序排列</span></span><br><span class="line"><span class="comment">// reload the Inorder function for our checking</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(Node *root, std::vector&lt;<span class="type">int</span>&gt;&amp; InorderArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;left, InorderArray);</span><br><span class="line">    InorderArray.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;right, InorderArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree_ByDftInOrder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; InorderArray;</span><br><span class="line">    <span class="built_in">Inorder</span>(root, InorderArray);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;InorderArray.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(InorderArray[i] &gt; InorderArray[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">15</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">10</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">20</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">25</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">8</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">12</span>);</span><br><span class="line">    root = <span class="built_in">Insert</span>(root, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; <span class="built_in">FindHeight</span>(root) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFT: &quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFT: Preorder: &quot;</span>;</span><br><span class="line">    <span class="built_in">Preorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFT: Inorder&quot;</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFT: Postorder: &quot;</span>;</span><br><span class="line">    <span class="built_in">Postorder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Check is a BST or not way1: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">IsBinarySearchTree</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Check is a BST or not way2: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">IsBinarySearchTree_ByBound</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Check is a BST or not way3: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">IsBinarySearchTree_ByDftInOrder</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Height: 2
BFT: 15 10 20 8 12 17 25 
DFT: Preorder: 15 10 8 12 20 17 25 
DFT: Inorder8 10 12 15 17 20 25 
DFT: Postorder: 8 12 10 17 25 20 15 
Check is a BST or not way1: 1
Check is a BST or not way2: 1
Check is a BST or not way3: 1
</code></pre>
<h4 id="Reference-3">Reference</h4>
<p><a href="https://www.youtube.com/watch?v=gXgEDyodOJU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=38">mycodeschool</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十五：Backprojecting a histogram to detect specific image content</title>
    <url>/2017/05/04/Backprojecting-a-histogram-to/</url>
    <content><![CDATA[<h5 id="Overview-6">Overview</h5>
<p>之前，我们在 <a href="http://datahonor.com/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%9D%EF%BC%9AComparing-colors-using-the-Strategy-design-pattern/">OpenCV系列笔记九：Comparing colors using the Strategy design pattern</a><br>
, 和<a href="http://datahonor.com/2017/05/02/Using-colors-for-detection-skin-tone-detection/">OpenCV系列笔记十二：Using colors for detection - skin tone detection</a>里面分别介绍了在不同的颜色空间下，通过计算颜色距离，来进行the detection of specific image content.这里，我们将要介绍的histogram backprojection是一种新的进行detection的方法。</p>
<blockquote>
<p>A histogram is an important characteristic of an image’s content. If you look at an image area that shows a particular texture or a particular object, then the histogram of this area can be seen as a function that gives the probability that a given pixel belongs to this specific texture or object.</p>
</blockquote>
<p>简单讲就是说，我们通过指定一块具有代表性的区域，来检测图片中具有相同特征的所有区域。而检测的根据就是直方图，根据直方图的相似度来进行判别。</p>
<h5 id="Code-5">Code</h5>
<h6 id="colorhistogram-h">colorhistogram.h</h6>
<p>可以看到这里面很多函数在此处是用不到的，但是还是贴出来，好进一步的学习。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_COLORHISTOGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_COLORHISTOGRAM_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorHistogram</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> histSize[<span class="number">3</span>];        <span class="comment">// size of each dimension</span></span><br><span class="line">    <span class="type">float</span> hranges[<span class="number">2</span>];       <span class="comment">// range of values (same for the 3 dimensions)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* ranges[<span class="number">3</span>]; <span class="comment">// array of ranges for each dimension</span></span><br><span class="line">    <span class="type">int</span> channels[<span class="number">3</span>];        <span class="comment">// channel to be considered</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ColorHistogram</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare default arguments for a color histogram</span></span><br><span class="line">        <span class="comment">// each dimension has equal size and range</span></span><br><span class="line">        histSize[<span class="number">0</span>]= histSize[<span class="number">1</span>]= histSize[<span class="number">2</span>]= <span class="number">256</span>;</span><br><span class="line">        hranges[<span class="number">0</span>]= <span class="number">0.0</span>;    <span class="comment">// BRG range from 0 to 256</span></span><br><span class="line">        hranges[<span class="number">1</span>]= <span class="number">256.0</span>;</span><br><span class="line">        ranges[<span class="number">0</span>]= hranges; <span class="comment">// in this class,</span></span><br><span class="line">        ranges[<span class="number">1</span>]= hranges; <span class="comment">// all channels have the same range</span></span><br><span class="line">        ranges[<span class="number">2</span>]= hranges;</span><br><span class="line">        channels[<span class="number">0</span>]= <span class="number">0</span>;		<span class="comment">// the three channels: B</span></span><br><span class="line">        channels[<span class="number">1</span>]= <span class="number">1</span>;     <span class="comment">// G</span></span><br><span class="line">        channels[<span class="number">2</span>]= <span class="number">2</span>;     <span class="comment">// R</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set histogram size for each dimension</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// each dimension has equal size</span></span><br><span class="line">        histSize[<span class="number">0</span>]= histSize[<span class="number">1</span>]= histSize[<span class="number">2</span>]= size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the histogram.</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        cv::Mat hist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BGR color histogram</span></span><br><span class="line">        hranges[<span class="number">0</span>]= <span class="number">0.0</span>;    <span class="comment">// BRG range</span></span><br><span class="line">        hranges[<span class="number">1</span>]= <span class="number">256.0</span>;</span><br><span class="line">        channels[<span class="number">0</span>]= <span class="number">0</span>;		<span class="comment">// the three channels</span></span><br><span class="line">        channels[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        channels[<span class="number">2</span>]= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute histogram</span></span><br><span class="line">        cv::<span class="built_in">calcHist</span>(&amp;image,</span><br><span class="line">            <span class="number">1</span>,			<span class="comment">// histogram of 1 image only</span></span><br><span class="line">            channels,	<span class="comment">// the channel used</span></span><br><span class="line">            cv::<span class="built_in">Mat</span>(),	<span class="comment">// no mask is used</span></span><br><span class="line">            hist,		<span class="comment">// the resulting histogram</span></span><br><span class="line">            <span class="number">3</span>,			<span class="comment">// it is a 3D histogram</span></span><br><span class="line">            histSize,	<span class="comment">// number of bins</span></span><br><span class="line">            ranges		<span class="comment">// pixel value range</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the histogram.</span></span><br><span class="line">    <span class="function">cv::SparseMat <span class="title">getSparseHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">cv::SparseMat <span class="title">hist</span><span class="params">(<span class="number">3</span>,        <span class="comment">// number of dimensions</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           histSize, <span class="comment">// size of each dimension</span></span></span></span><br><span class="line"><span class="params"><span class="function">                           CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BGR color histogram</span></span><br><span class="line">        hranges[<span class="number">0</span>]= <span class="number">0.0</span>;    <span class="comment">// BRG range</span></span><br><span class="line">        hranges[<span class="number">1</span>]= <span class="number">256.0</span>;</span><br><span class="line">        channels[<span class="number">0</span>]= <span class="number">0</span>;		<span class="comment">// the three channels</span></span><br><span class="line">        channels[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        channels[<span class="number">2</span>]= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute histogram</span></span><br><span class="line">        cv::<span class="built_in">calcHist</span>(&amp;image,</span><br><span class="line">            <span class="number">1</span>,			<span class="comment">// histogram of 1 image only</span></span><br><span class="line">            channels,	<span class="comment">// the channel used</span></span><br><span class="line">            cv::<span class="built_in">Mat</span>(),	<span class="comment">// no mask is used</span></span><br><span class="line">            hist,		<span class="comment">// the resulting histogram</span></span><br><span class="line">            <span class="number">3</span>,			<span class="comment">// it is a 3D histogram</span></span><br><span class="line">            histSize,	<span class="comment">// number of bins</span></span><br><span class="line">            ranges		<span class="comment">// pixel value range</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the 1D Hue histogram.</span></span><br><span class="line">    <span class="comment">// BGR source image is converted to HSV</span></span><br><span class="line">    <span class="comment">// Pixels with low saturation are ignored</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getHueHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> minSaturation=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        cv::Mat hist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to HSV colour space</span></span><br><span class="line">        cv::Mat hsv;</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, hsv, CV_BGR2HSV);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mask to be used (or not)</span></span><br><span class="line">        cv::Mat mask;</span><br><span class="line">        <span class="comment">// creating the mask if required</span></span><br><span class="line">        <span class="keyword">if</span> (minSaturation&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Spliting the 3 channels into 3 images</span></span><br><span class="line">            std::vector&lt;cv::Mat&gt; v;</span><br><span class="line">            cv::<span class="built_in">split</span>(hsv,v);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mask out the low saturated pixels</span></span><br><span class="line">            cv::<span class="built_in">threshold</span>(v[<span class="number">1</span>],mask,minSaturation,<span class="number">255</span>,</span><br><span class="line">                                 cv::THRESH_BINARY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare arguments for a 1D hue histogram</span></span><br><span class="line">        hranges[<span class="number">0</span>]= <span class="number">0.0</span>;    <span class="comment">// range is from 0 to 180</span></span><br><span class="line">        hranges[<span class="number">1</span>]= <span class="number">180.0</span>;</span><br><span class="line">        channels[<span class="number">0</span>]= <span class="number">0</span>;    <span class="comment">// the hue channel</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute histogram</span></span><br><span class="line">        cv::<span class="built_in">calcHist</span>(&amp;hsv,</span><br><span class="line">            <span class="number">1</span>,			<span class="comment">// histogram of 1 image only</span></span><br><span class="line">            channels,	<span class="comment">// the channel used</span></span><br><span class="line">            mask,		<span class="comment">// binary mask</span></span><br><span class="line">            hist,		<span class="comment">// the resulting histogram</span></span><br><span class="line">            <span class="number">1</span>,			<span class="comment">// it is a 1D histogram</span></span><br><span class="line">            histSize,	<span class="comment">// number of bins</span></span><br><span class="line">            ranges		<span class="comment">// pixel value range</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the 2D ab histogram.</span></span><br><span class="line">    <span class="comment">// BGR source image is converted to Lab</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getabHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        cv::Mat hist;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to Lab color space</span></span><br><span class="line">        cv::Mat lab;</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, lab, CV_BGR2Lab);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare arguments for a 2D color histogram</span></span><br><span class="line">        hranges[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        hranges[<span class="number">1</span>]= <span class="number">256.0</span>;</span><br><span class="line">        channels[<span class="number">0</span>]= <span class="number">1</span>; <span class="comment">// the two channels used are ab</span></span><br><span class="line">        channels[<span class="number">1</span>]= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute histogram</span></span><br><span class="line">        cv::<span class="built_in">calcHist</span>(&amp;lab,</span><br><span class="line">            <span class="number">1</span>,			<span class="comment">// histogram of 1 image only</span></span><br><span class="line">            channels,	<span class="comment">// the channel used</span></span><br><span class="line">            cv::<span class="built_in">Mat</span>(),	<span class="comment">// no mask is used</span></span><br><span class="line">            hist,		<span class="comment">// the resulting histogram</span></span><br><span class="line">            <span class="number">2</span>,			<span class="comment">// it is a 2D histogram</span></span><br><span class="line">            histSize,	<span class="comment">// number of bins</span></span><br><span class="line">            ranges		<span class="comment">// pixel value range</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_COLORHISTOGRAM_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="contenfinder-h">contenfinder.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_CONTENTFINDER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_CONTENTFINDER_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentFinder</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// histogram parameters</span></span><br><span class="line">    <span class="type">float</span> hranges[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* ranges[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> channels[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> threshold; <span class="comment">//decision threshold</span></span><br><span class="line">    cv::Mat histogram;  <span class="comment">// input histogram</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ContentFinder</span>():<span class="built_in">threshold</span>(<span class="number">0.1f</span>)&#123;</span><br><span class="line">        <span class="comment">// in this class, all channels have the same range</span></span><br><span class="line">        ranges[<span class="number">0</span>] = hranges;</span><br><span class="line">        ranges[<span class="number">1</span>] = hranges;</span><br><span class="line">        ranges[<span class="number">2</span>] = hranges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the refrence histogram</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHistogram</span><span class="params">(<span class="type">const</span> cv::Mat&amp; h)</span></span>&#123;</span><br><span class="line">        histogram = h;</span><br><span class="line">        cv::<span class="built_in">normalize</span>(histogram, histogram, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the threshold</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setThreshold</span><span class="params">(<span class="type">float</span> f)</span></span>&#123;</span><br><span class="line">        threshold = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Simplified version in which</span></span><br><span class="line">    <span class="comment">//all channels used, with range[0,256]</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">find</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image)</span></span>&#123;</span><br><span class="line">        cv::Mat result;</span><br><span class="line">        hranges[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">        hranges[<span class="number">1</span>] = <span class="number">256.0</span>;</span><br><span class="line">        channels[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        channels[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        channels[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(image, hranges[<span class="number">0</span>], hranges[<span class="number">1</span>], channels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finds the pixel belonging to the histogram</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">find</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image, <span class="type">float</span> minValue, <span class="type">float</span> maxValue, <span class="type">int</span> * channels)</span></span>&#123;</span><br><span class="line">        cv::Mat result;</span><br><span class="line">        hranges[<span class="number">0</span>] = minValue;</span><br><span class="line">        hranges[<span class="number">1</span>] = maxValue;</span><br><span class="line">        <span class="comment">// histogram dim matches channel list</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;histogram.dims; i++)</span><br><span class="line">            <span class="keyword">this</span>-&gt;channels[i]=channels[i];</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">calcBackProject</span>(&amp;image, <span class="number">1</span>,</span><br><span class="line">                            channels,</span><br><span class="line">                            histogram,</span><br><span class="line">                            result,</span><br><span class="line">                            ranges, <span class="number">255.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(threshold&gt;<span class="number">0.0</span>)</span><br><span class="line">            cv::<span class="built_in">threshold</span>(result, result, <span class="number">255.0</span>*threshold, <span class="number">255.0</span>,cv::THRESH_BINARY);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_CONTENTFINDER_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-2">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;colorhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contentfinder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ColorHistogram hc;</span><br><span class="line">    cv::Mat color = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/waves.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat imageROI;</span><br><span class="line">    imageROI = <span class="built_in">color</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">45</span>)); <span class="comment">// sky region</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//image with rectangle</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(color, cv::<span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">45</span>), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image with rect&quot;</span>, color);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get 3D color histogram (8 bins per channel)</span></span><br><span class="line">    hc.<span class="built_in">setSize</span>(<span class="number">8</span>);</span><br><span class="line">    cv::Mat shist = hc.<span class="built_in">getHistogram</span>(imageROI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the content finder</span></span><br><span class="line">    ContentFinder finder;</span><br><span class="line">    <span class="comment">// set histogram to be bask-projected</span></span><br><span class="line">    finder.<span class="built_in">setHistogram</span>(shist);</span><br><span class="line">    finder.<span class="built_in">setThreshold</span>(<span class="number">0.05f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get back-projection of color histogram</span></span><br><span class="line">    cv::Mat result = finder.<span class="built_in">find</span>(color);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Color Detection Result&quot;</span>, result);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170504/Selection_050415%3A23%3A52.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Bubble Sort</title>
    <url>/2017/02/25/Bubble-Sort/</url>
    <content><![CDATA[<h5 id="Theory">Theory</h5>
<p>关于，冒泡排序的原理及其实现。<br>
关于原理：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-25%2016-53-55.png" alt=""></p>
<blockquote>
<p>有序序列中每一对相邻元素都是顺序的；反之，所有相邻元素均顺序的序列<br>
也必然整体有序。</p>
</blockquote>
<h5 id="Code-6">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理： 有序序列中每一对相邻元素都是顺序的；反之，所有相邻元素均顺序的序列</span></span><br><span class="line"><span class="comment">// 也必然整体有序。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort1A</span><span class="params">( <span class="type">int</span> A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;  <span class="comment">// 整体排序标志，首先假定尚未进行排序</span></span><br><span class="line">    <span class="keyword">while</span>(!sorted)&#123;  <span class="comment">//在尚未确认已经全局排序之前，逐趟进行扫描交换</span></span><br><span class="line">        sorted = <span class="literal">true</span>;  <span class="comment">// 假定已经排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt; n; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i])&#123; <span class="comment">// 一旦A[i-1]与A[i]逆序，则</span></span><br><span class="line">                <span class="built_in">swap</span>( A[i<span class="number">-1</span>], A[i]); <span class="comment">// 交换之</span></span><br><span class="line">                sorted = <span class="literal">false</span>;<span class="comment">// 因整体排序不能保证，需要清除排序标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	n--;  <span class="comment">// 至此末位元素必然就位， 故可以缩短排序序列的有效长度。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">// 借助布尔值标志位sorted, 可以及时提前退出，而不至于总是忙里地做n-1次扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造打印数组的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">printvector</span>(a, n);</span><br><span class="line">    <span class="built_in">bubblesort1A</span>(a, n);</span><br><span class="line">    <span class="built_in">printvector</span>(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="关于时间复杂度">关于时间复杂度</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-25%2017-27-54.png" alt=""></p>
<p>参考：TsinghuaX: 30240184.1x Data Structures and Algorithm Design Part I 数据结构与算法设计(上)</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>By reference | By pointer</title>
    <url>/2017/08/28/By-reference-By-pointer/</url>
    <content><![CDATA[<p>在看<em>c++ primer plus 6th</em>, 发现给函数传参的时候，By reference和Pointer都是一样可以改变实参的，于是查了下他们的不同之处。</p>
<blockquote>
<p>1.指针是一个实体，而引用仅是个别名；</p>
</blockquote>
<blockquote>
<p>2.引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）</p>
<p>3.不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）</p>
</blockquote>
<blockquote>
<p>4.一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）</p>
<p>5.“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p>
</blockquote>
<p>参考： <a href="http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html">C++ 值传递、指针传递、引用传递详解</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>CW&amp;Regular expression</title>
    <url>/2018/02/24/CW-Regualr-expression/</url>
    <content><![CDATA[<h4 id="Overview-7">Overview</h4>
<p>前几天终于撸完了那么C的数据结构…所以来刷下CodeWars，感觉一个3kyu的题目挺有意思，<a href="https://www.codewars.com/kata/calculator/train/python">传送门</a>。就是评估一个四则运算的表达式，给出结果。</p>
<h4 id="Code-7">Code</h4>
<p>这里首选的是用正则表达式，好久没写过都手生了…查了下文档和一些资料，发现用<code>re.sub</code>就能解决了，所以代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">symIn</span>(<span class="params">self, string</span>):</span><br><span class="line">		<span class="keyword">if</span> re.findall(<span class="string">r&#x27;\+|-|\*|\/&#x27;</span>, string) == []:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">if</span> string[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> string:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, string</span>):</span><br><span class="line">		<span class="comment"># print(string)</span></span><br><span class="line">		<span class="keyword">while</span> self.symIn(string):</span><br><span class="line">			<span class="comment"># *</span></span><br><span class="line">			<span class="keyword">def</span> <span class="title function_">_mul</span>(<span class="params">matched</span>):</span><br><span class="line">				num = <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num1&#x27;</span>)) * <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num2&#x27;</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line">			string = re.sub(<span class="string">r&#x27;(?P&lt;num1&gt;[-\d.]+) \* (?P&lt;num2&gt;[-\d.]+)&#x27;</span>, repl=_mul, string=string,count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># /</span></span><br><span class="line">			<span class="keyword">def</span> <span class="title function_">_div</span>(<span class="params">matched</span>):</span><br><span class="line">				num = <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num1&#x27;</span>)) / <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num2&#x27;</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line">			string = re.sub(<span class="string">r&#x27;(?P&lt;num1&gt;[-\d.]+) \/ (?P&lt;num2&gt;[-\d.]+)&#x27;</span>, repl=_div, string=string,count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># +</span></span><br><span class="line">			<span class="keyword">def</span> <span class="title function_">_add</span>(<span class="params">matched</span>):</span><br><span class="line">				num = <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num1&#x27;</span>)) + <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num2&#x27;</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line">			string = re.sub(<span class="string">r&#x27;(?P&lt;num1&gt;[-\d.]+) \+ (?P&lt;num2&gt;[-\d.]+)&#x27;</span>, repl=_add, string=string,count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment"># -</span></span><br><span class="line">			<span class="keyword">def</span> <span class="title function_">_sub</span>(<span class="params">matched</span>):</span><br><span class="line">				num = <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num1&#x27;</span>)) - <span class="built_in">float</span>(matched.group(<span class="string">&#x27;num2&#x27;</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line">			string = re.sub(<span class="string">r&#x27;(?P&lt;num1&gt;[-\d.]+) - (?P&lt;num2&gt;[-\d.]+)&#x27;</span>, repl=_sub, string=string,count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">float</span>(string)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>感觉思路还是比较清晰的。嗯，然后提交后看大佬们的操作,发现了竟然有用eval的…另外，之后还打算做个NLP的东西，之前一定要再重新过一遍正则 :(</p>
<h4 id="Reference-4">Reference</h4>
<p><a href="https://docs.python.org/2/library/re.html">Python Doc</a><br>
<a href="https://www.crifan.com/python_re_sub_detailed_introduction/">Blog</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CodeWas</tag>
        <tag>Regular expression</tag>
      </tags>
  </entry>
  <entry>
    <title>Classifying News Headlines with scikit-learn</title>
    <url>/2017/03/05/Classifying-News-Headlines-with-scikit-learn/</url>
    <content><![CDATA[<h5 id="概览">概览</h5>
<p>Kaggle案例学习，练习使用sklearn进行新闻的分类，主要使用了朴素贝叶斯进行分类。</p>
<h5 id="学习">学习</h5>
<blockquote>
<p>学习使用正则来清洗数据<br>
掌握sklearn准备训练集和测试集的方法[LabelEncoder， train_test_split等的使用]<br>
学习使用sklearn调用朴素贝叶斯算法进行分类预测</p>
</blockquote>
<h5 id="代码">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get some libraries that will be useful</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the Naive Bayes model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="comment"># function to split the data for cross-validation</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># function for transforming documents into counts</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="comment"># function for encoding categories</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># grab the data</span></span><br><span class="line">news = pd.read_csv(<span class="string">&quot;uci-news-aggregator.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># let&#x27;s take a look at our data</span></span><br><span class="line"><span class="built_in">print</span>(news.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对新闻标题的处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize_text</span>(<span class="params">s</span>):</span><br><span class="line">    s = s.lower()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove punctuation that is not word-internal (e.g., hyphens, apostrophes)</span></span><br><span class="line">    s = re.sub(<span class="string">&#x27;\s\W&#x27;</span>, <span class="string">&#x27; &#x27;</span>, s)</span><br><span class="line">    s = re.sub(<span class="string">&#x27;\W\s&#x27;</span>, <span class="string">&#x27; &#x27;</span>, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make sure we didn&#x27;t introduce any double spaces</span></span><br><span class="line">    s = re.sub(<span class="string">&#x27;\s+&#x27;</span>, <span class="string">&#x27; &#x27;</span>, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">news[<span class="string">&#x27;TEXT&#x27;</span>] = [normalize_text(s) <span class="keyword">for</span> s <span class="keyword">in</span> news[<span class="string">&#x27;TITLE&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(news[<span class="string">&#x27;TITLE&#x27;</span>].head())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练集和测试集</span></span><br><span class="line"><span class="comment"># pull the data into vectors</span></span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">x = vectorizer.fit_transform(news[<span class="string">&#x27;TEXT&#x27;</span>])</span><br><span class="line"></span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">y = encoder.fit_transform(news[<span class="string">&#x27;CATEGORY&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># split into train and test sets</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># take a look at the shape of each of these</span></span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line"><span class="built_in">print</span>(y_train.shape)</span><br><span class="line"><span class="built_in">print</span>(x_test.shape)</span><br><span class="line"><span class="built_in">print</span>(y_test.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始预测</span></span><br><span class="line">nb = MultinomialNB()</span><br><span class="line">nb.fit(x_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(nb.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="补充">补充</h5>
<p>关于正则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in</span><br><span class="line">         bytes patterns or string patterns with the ASCII flag.</span><br><span class="line">         In string patterns without the ASCII flag, it will match the whole</span><br><span class="line">         range of Unicode whitespace characters.</span><br><span class="line">\S       Matches any non-whitespace character; equivalent to [^\s].</span><br><span class="line">\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]</span><br><span class="line">         in bytes patterns or string patterns with the ASCII flag.</span><br><span class="line">         In string patterns without the ASCII flag, it will match the</span><br><span class="line">         range of Unicode alphanumeric characters (letters plus digits</span><br><span class="line">         plus underscore).</span><br><span class="line">         With LOCALE, it will match the set [0-9_] plus characters defined</span><br><span class="line">         as letters for the current locale.</span><br><span class="line">\W       Matches the complement of \w.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于LabelEncoder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LabelEncoder(sklearn.base.BaseEstimator, sklearn.base.TransformerMixin)</span><br><span class="line">|  Encode labels with value between 0 and n_classes-1.</span><br><span class="line">|</span><br><span class="line">|  Read more in the :ref:`User Guide &lt;preprocessing_targets&gt;`.</span><br><span class="line">|</span><br><span class="line">|  Attributes</span><br><span class="line">|  ----------</span><br><span class="line">|  classes_ : array of shape (n_class,)</span><br><span class="line">|      Holds the label for each class.</span><br><span class="line">|</span><br><span class="line">|  Examples</span><br><span class="line">|  --------</span><br><span class="line">|  `LabelEncoder` can be used to normalize labels.</span><br><span class="line">|  &gt;&gt;&gt; from sklearn import preprocessing</span><br><span class="line">|  &gt;&gt;&gt; le = preprocessing.LabelEncoder()</span><br><span class="line">|  &gt;&gt;&gt; le.fit([1, 2, 2, 6])</span><br><span class="line">|  LabelEncoder()</span><br><span class="line">|  &gt;&gt;&gt; le.classes_</span><br><span class="line">|  array([1, 2, 6])</span><br><span class="line">|  &gt;&gt;&gt; le.transform([1, 1, 2, 6]) #doctest: +ELLIPSIS</span><br><span class="line">|  array([0, 0, 1, 2]...)</span><br><span class="line">|  &gt;&gt;&gt; le.inverse_transform([0, 0, 1, 2])</span><br><span class="line">|  array([1, 1, 2, 6])</span><br><span class="line">|</span><br><span class="line">|  It can also be used to transform non-numerical labels (as long as they are</span><br><span class="line">|  hashable and comparable) to numerical labels.</span><br><span class="line">|</span><br><span class="line">|  &gt;&gt;&gt; le = preprocessing.LabelEncoder()</span><br><span class="line">|  &gt;&gt;&gt; le.fit([&quot;paris&quot;, &quot;paris&quot;, &quot;tokyo&quot;, &quot;amsterdam&quot;])</span><br><span class="line">|  LabelEncoder()</span><br><span class="line">|  &gt;&gt;&gt; list(le.classes_)</span><br><span class="line">|  [&#x27;amsterdam&#x27;, &#x27;paris&#x27;, &#x27;tokyo&#x27;]</span><br><span class="line">|  &gt;&gt;&gt; le.transform([&quot;tokyo&quot;, &quot;tokyo&quot;, &quot;paris&quot;]) #doctest: +ELLIPSIS</span><br><span class="line">|  array([2, 2, 1]...)</span><br><span class="line">|  &gt;&gt;&gt; list(le.inverse_transform([2, 2, 1]))</span><br><span class="line">|  [&#x27;tokyo&#x27;, &#x27;tokyo&#x27;, &#x27;paris&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="参考">参考</h5>
<p><a href="https://www.kaggle.com/shenxiangzhuang/d/uciml/news-aggregator-dataset/classifying-news-headlines-with-scikit-learn/editnb"><em>Classifying News Headlines with scikit-learn</em></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kaggle</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake使用</title>
    <url>/2017/12/18/Cmake%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一直使用的Clion写C&amp;Cpp，编译都是用cmake文件来，这里记录下使用过程中遇到的问题及解决方法。</p>
<h4 id="链接math-h库">链接math.h库</h4>
<p>若是<code>.c</code>源文件包含了<code>math</code>库，那么我们在命令行用<code>gcc</code>编译的时候可以使用<code>-lm</code>来实现，如下：</p>
<blockquote>
<p>gcc fib.c -lm -o fibo</p>
</blockquote>
<p>参考<a href="https://stackoverflow.com/questions/8671366/undefined-reference-to-pow-and-floor">stackoverflow</a></p>
<blockquote>
<p>ps:在Linux下cc与gcc是等价的，cc原是Unix下的c compiler,gcc是其在Linux下的替代。参考<a href="http://www.cnblogs.com/zhouyinhui/archive/2010/02/01/1661078.html">这里</a></p>
</blockquote>
<p>而在Clion中就需要修改<code> CMakeLists.txt</code>文件,最后加上：</p>
<blockquote>
<p>target_link_libraries(NAME m)</p>
</blockquote>
<p>参考<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/206607085-CLion-Enabling-math-h-for-C-projects">intellij-support</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十三：Computing an image histogram</title>
    <url>/2017/05/02/Computing-an-image-histogram/</url>
    <content><![CDATA[<h4 id="Overview-8">Overview</h4>
<p>我们经常从图像像素点的直方图来获取一些数据，所以绘制直方图也是需要掌握的。</p>
<blockquote>
<p>An image is made of pixels that have different values. For example, in a 1-channel gray-level image, each pixel has an integer value between 0 (black) and 255 (white). Depending on the picture content, you will find different amounts of each gray shade laid out inside the image. A histogram is a simple table that gives you the number of pixels that have a given value in an image (or sometimes, a set of images). The histogram of a gray-level image will, therefore, have 256 entries (or bins). Bin 0 gives you the number of pixels that have the value 0, bin 1 gives you the number of pixels that have the value 1, and so on. Obviously, if you sum all of the entries of a histogram, you should get the total number of pixels. Histograms can also be normalized so that the sum of the bins equals 1. In this case, each bin gives you the percentage of pixels that have this specific value in the image.</p>
</blockquote>
<p>下面我们分别给出单通道[灰度图]和三通道图像直方图的绘制，前者来自这系列笔记的参考书，后者来自官方文档，其实基本思路是一致的。</p>
<h4 id="Code-8">Code</h4>
<h5 id="单通道-灰度图">单通道[灰度图]</h5>
<h6 id="grayhistogram-h">grayhistogram.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_GRAYHISTOGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_GRAYHISTOGRAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Histogram1D</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> histSize[<span class="number">1</span>]; <span class="comment">// numbers of bins in histogram</span></span><br><span class="line">    <span class="type">float</span> hranges[<span class="number">2</span>];  <span class="comment">// range of values</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* ranges[<span class="number">1</span>];  <span class="comment">// pointer to the value ranges</span></span><br><span class="line">    <span class="type">int</span> channels[<span class="number">1</span>]; <span class="comment">// channel number to be examined</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Histogram1D</span>()&#123;</span><br><span class="line">        <span class="comment">// Prepare default arguments for 1D histogram</span></span><br><span class="line">        histSize[<span class="number">0</span>] = <span class="number">256</span>;  <span class="comment">// 256bins</span></span><br><span class="line">        hranges[<span class="number">0</span>] = <span class="number">0.0</span>;  <span class="comment">// from 0 (inclusive)</span></span><br><span class="line">        hranges[<span class="number">1</span>] = <span class="number">256.0</span>;  <span class="comment">// to 256 (exclusive)</span></span><br><span class="line">        ranges[<span class="number">0</span>] = hranges;</span><br><span class="line">        channels[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// we look at channel 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNBins</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">        histSize[<span class="number">0</span>] = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Computes the 1D histogram</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">        cv::Mat hist;</span><br><span class="line">        <span class="comment">//Compute 1D histogram with calcHist</span></span><br><span class="line">        cv::<span class="built_in">calcHist</span>(&amp;image,<span class="number">1</span>,channels,cv::<span class="built_in">Mat</span>(),</span><br><span class="line">                     hist, <span class="number">1</span>, histSize, ranges);</span><br><span class="line">        <span class="keyword">return</span>  hist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the 1D histogram and returns an image of it</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getHistogramImage</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image, <span class="type">int</span> zoom=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Compute histogram first</span></span><br><span class="line">        cv::Mat hist = <span class="built_in">getHistogram</span>(image);</span><br><span class="line">        <span class="comment">// Create imaeg</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getImageOfHistogram</span>(hist, zoom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an image representing a histogram (static method)</span></span><br><span class="line">    <span class="function"><span class="type">static</span> cv::Mat <span class="title">getImageOfHistogram</span><span class="params">(<span class="type">const</span> cv::Mat &amp;hist, <span class="type">int</span> zoom)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get min and max bin values</span></span><br><span class="line">        <span class="type">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> minVal = <span class="number">0</span>;</span><br><span class="line">        cv::<span class="built_in">minMaxLoc</span>(hist, &amp;minVal, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get histogram size</span></span><br><span class="line">        <span class="type">int</span> histSize = hist.rows;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Square image on which to display histogram</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">histImg</span><span class="params">(histSize*zoom, histSize*zoom, CV_8U, cv::Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line">        <span class="comment">// set highest point at 90% of nbins (i.e. image height)</span></span><br><span class="line">        <span class="type">int</span> hpt = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">0.9</span>*histSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Draw vertical line for each bin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>; h&lt;histSize; h++)&#123;</span><br><span class="line">            <span class="type">float</span> binVal = hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(h);</span><br><span class="line">            <span class="keyword">if</span>(binVal&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> intensity = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(binVal*hpt/maxVal);</span><br><span class="line">                cv::<span class="built_in">line</span>(histImg, cv::<span class="built_in">Point</span>(h*zoom, histSize*zoom), cv::<span class="built_in">Point</span>(h*zoom, (histSize - intensity)*zoom),cv::<span class="built_in">Scalar</span>(<span class="number">0</span>),zoom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> histImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_GRAYHISTOGRAM_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-3">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>,<span class="number">0</span>); <span class="comment">// gray</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// The histogram object</span></span><br><span class="line">    Histogram1D h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Compute the histogram</span></span><br><span class="line">    cv::Mat histo = h.<span class="built_in">getHistogram</span>(image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over each bin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Value &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; = &quot;</span></span><br><span class="line">                              &lt;&lt;histo.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i)&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Histogram&quot;</span>, h.<span class="built_in">getHistogramImage</span>(image));</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Value 0 = 73<br>
Value 1 = 94<br>
Value 2 = 288<br>
Value 3 = 157<br>
…</p>
</blockquote>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170502/hist1.png" alt=""></p>
<h5 id="多通道-彩色">多通道[彩色]</h5>
<h6 id="main-cpp-4">main.cpp</h6>
<p>这里，为了更好地展示图片，我们仿照上面的方法，对文档代码进行了修改。主要就是动态限制了直方图高度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat src, dst;</span><br><span class="line">    src = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>, IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(src.<span class="built_in">empty</span>()) <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    vector&lt;Mat&gt;bgr_planes;</span><br><span class="line">    <span class="built_in">split</span>(src, bgr_planes);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> histSize[<span class="number">1</span>];</span><br><span class="line">    histSize[<span class="number">0</span>] = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> range[] = &#123;<span class="number">0</span>, <span class="number">256</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span>* histRange[<span class="number">2</span>] = &#123;range&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> uniform = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> accumulate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Mat b_hist, g_hist, r_hist;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcHist</span>(&amp;bgr_planes[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), b_hist, <span class="number">1</span>, histSize, histRange, uniform, accumulate);</span><br><span class="line">    <span class="built_in">calcHist</span>(&amp;bgr_planes[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), g_hist, <span class="number">1</span>, histSize, histRange, uniform, accumulate);</span><br><span class="line">    <span class="built_in">calcHist</span>(&amp;bgr_planes[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), r_hist, <span class="number">1</span>, histSize, histRange, uniform, accumulate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw the histograms for B, G, and R</span></span><br><span class="line">    <span class="type">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> minVal = <span class="number">0</span>;</span><br><span class="line">    cv::<span class="built_in">minMaxLoc</span>(b_hist, &amp;minVal, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">minMaxLoc</span>(g_hist, &amp;minVal, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">minMaxLoc</span>(r_hist, &amp;minVal, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hpt = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">0.9</span>*histSize[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hist_w = <span class="number">512</span>; <span class="type">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line">    <span class="type">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="type">double</span>)hist_w / histSize[<span class="number">0</span>]);</span><br><span class="line">    <span class="function">Mat <span class="title">histImage</span><span class="params">(hist_h, hist_w, CV_8UC3, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normalization</span></span><br><span class="line">    <span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line">    <span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line">    <span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;histSize[<span class="number">0</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w*(i<span class="number">-1</span>), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i<span class="number">-1</span>)*hpt/maxVal)),</span><br><span class="line">                        <span class="built_in">Point</span>(bin_w*i, hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i)*hpt/maxVal)),</span><br><span class="line">                        <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w*(i<span class="number">-1</span>), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i<span class="number">-1</span>)*hpt/maxVal)),</span><br><span class="line">             <span class="built_in">Point</span>(bin_w*i, hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i)*hpt/maxVal)),</span><br><span class="line">             <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w*(i<span class="number">-1</span>), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i<span class="number">-1</span>)*hpt/maxVal)),</span><br><span class="line">             <span class="built_in">Point</span>(bin_w*i, hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i)*hpt/maxVal)),</span><br><span class="line">             <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;calcHist&quot;</span>, histImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170502/hist2.png" alt=""></p>
<h5 id="直方图的修正">直方图的修正</h5>
<p>先来看下什么是图像增强技术：</p>
<blockquote>
<p>图像增强技术是一大类基本的图像处理技术，目的是对一幅图像进行 加工，突出图像中的某些信息，削弱或除去某些不需要的信息，以得 到对具体应用来说视觉效果更好、更有用的图像，或转换成一种更适<br>
合人或机器进行分析处理的形式。</p>
</blockquote>
<p>而图像增强方法分为空间域法和频率域法，空间域法是指在空间域内直接对像素的灰度值进行运算处理，我们这里将要介绍的直方图的修正，还有在下一篇笔记<a href="http://datahonor.com/2017/05/04/Look-up-tables/">look-ip table</a><br>
里面用到了灰度变换都属于常用的空间域法。与之对应的频率域法是一种间接的处理方法。它是在图像的某种变换宇内，对图像的变换值进行增强处理，然后通过逆变换获得增强图像。</p>
<h6 id="直方图的均衡化-histogram-equalization">直方图的均衡化(histogram equalization)</h6>
<p>均衡化的原理是使得变换后的图像灰度的概率密度均匀分布，即变换后的图像是衣服灰度级均匀分布的图像，这意味着图像灰度的动态范围得到了增加，从而可提高图像的对比度。<br>
转换过程类似这种形式：<br>
<img src="" alt=""></p>
<p>简单讲就是转换为其累计密度分布的形式。具体的推导过程见参考资料。</p>
<p>在OpenCV中已经有了相应的函数，我们来看下它的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image;</span><br><span class="line">    Histogram1D h;</span><br><span class="line"></span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/dark.jpeg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Hist&quot;</span>, h.<span class="built_in">getHistogramImage</span>(image));</span><br><span class="line"></span><br><span class="line">    cv::Mat equed;</span><br><span class="line">    cv::<span class="built_in">equalizeHist</span>(image, equed);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Equed&quot;</span>, equed);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Equed Hist&quot;</span>, h.<span class="built_in">getHistogramImage</span>(equed));</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170505/Selection_050511%3A02%3A11.png" alt=""></p>
<h6 id="直方图的规定化-histogram-specification-matching">直方图的规定化(histogram specification/matching)</h6>
<p>定义：</p>
<blockquote>
<p>是指将一幅图像通过灰度变换后，使其具有特定的直方图形式，如使图像与某一标准图像具有相同的直方图，或使图像具有某一特定函数形式的直方图。</p>
</blockquote>
<p>可以看到规定化是将原来的直方图转化为指定的形式。先将两个图像都进行均衡化处理，之后让被转化的直方图向目标直方图靠拢来得到目的。</p>
<p>在OpenCV中没有特定函数实现规定化，我从Scribd找来实现的代码，参考一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">grayImgSpecification</span><span class="params">(cv::Mat &amp;img1, cv::Mat &amp;img2)</span></span>&#123;</span><br><span class="line">    cv::Mat img_new = img1.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="type">int</span> grayLevel = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Histogram</span></span><br><span class="line">    Histogram1D h;</span><br><span class="line">    cv::Mat histogram1 = h.<span class="built_in">getHistogram</span>(img1);</span><br><span class="line">    cv::Mat histogram2 = h.<span class="built_in">getHistogram</span>(img2);</span><br><span class="line"><span class="comment">//    cv::imshow(&quot;img1-original histogram&quot;, h.getHistogramImage(img1));</span></span><br><span class="line"><span class="comment">//    cv::imshow(&quot;img2-original histogram&quot;, h.getHistogramImage(img2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifuication</span></span><br><span class="line">    <span class="type">float</span> * prImg1 = <span class="keyword">new</span> <span class="type">float</span>[grayLevel];</span><br><span class="line">    <span class="type">float</span> * mapImg1 = <span class="keyword">new</span> <span class="type">float</span>[grayLevel];</span><br><span class="line">    <span class="type">float</span> * prImg2 = <span class="keyword">new</span> <span class="type">float</span>[grayLevel];</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> n1 = img1.rows * img1.cols;</span><br><span class="line">    <span class="type">float</span> n2 = img2.rows * img2.cols;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同灰度级所占的比例</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;grayLevel; i++ )&#123;</span><br><span class="line">        <span class="type">float</span> nk = histogram1.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i);</span><br><span class="line">        prImg1[i] = nk/n1;</span><br><span class="line"></span><br><span class="line">        nk = histogram2.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i);</span><br><span class="line">        prImg2[i] = nk/n2;</span><br><span class="line"></span><br><span class="line">        mapImg1[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;grayLevel; i++)&#123;</span><br><span class="line">        prImg1[i] = prImg1[i<span class="number">-1</span>] + prImg1[i];</span><br><span class="line">        prImg2[i] = prImg2[i<span class="number">-1</span>] + prImg2[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    prImg1[grayLevel - <span class="number">1</span>] = prImg2[grayLevel - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mapping</span></span><br><span class="line">    <span class="type">int</span> currentID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;grayLevel; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> mapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(mapped== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prImg1[i] &lt;= prImg2[currentID])</span><br><span class="line">            &#123;</span><br><span class="line">                mapImg1[i] = currentID;</span><br><span class="line">                mapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentID++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new Image</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;img_new.rows; i++)&#123;</span><br><span class="line">        uchar* data = img_new.<span class="built_in">ptr</span>&lt;uchar&gt;(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;img_new.cols;j++)&#123;</span><br><span class="line">            <span class="type">int</span> grayVale = (<span class="type">int</span>)data[j*img_new.<span class="built_in">channels</span>()+<span class="number">0</span>];</span><br><span class="line">            <span class="type">float</span> val = mapImg1[grayVale];</span><br><span class="line">            data[j*img_new.<span class="built_in">channels</span>()+<span class="number">0</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img_new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Read image</span></span><br><span class="line">    cv::Mat img1 = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/desert.jpg&quot;</span>);</span><br><span class="line">    cv::Mat img2 = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/sea.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    std::vector&lt;cv::Mat&gt;img1_bgrplanes;</span><br><span class="line">    cv::<span class="built_in">split</span>(img1, img1_bgrplanes);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Mat&gt;img2_bgrplanes;</span><br><span class="line">    cv::<span class="built_in">split</span>(img2, img2_bgrplanes);</span><br><span class="line"></span><br><span class="line">    cv::Mat img_new0 = <span class="built_in">grayImgSpecification</span>(img1_bgrplanes[<span class="number">0</span>], img2_bgrplanes[<span class="number">0</span>]);</span><br><span class="line">    cv::Mat img_new1 = <span class="built_in">grayImgSpecification</span>(img1_bgrplanes[<span class="number">1</span>], img2_bgrplanes[<span class="number">1</span>]);</span><br><span class="line">    cv::Mat img_new2 = <span class="built_in">grayImgSpecification</span>(img1_bgrplanes[<span class="number">2</span>], img2_bgrplanes[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    cv::Mat img_news;</span><br><span class="line">    std::vector&lt;cv::Mat&gt;img_new_planes;</span><br><span class="line">    img_new_planes= &#123;img_new0, img_new1, img_new2&#125;;</span><br><span class="line">    cv::<span class="built_in">merge</span>(img_new_planes, img_news);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Img_news&quot;</span>, img_news);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;specification.jpg&quot;</span>, img_news);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170505/Selection_050512%3A26%3A29.png" alt=""></p>
<p>根据上面已经提到的，我们来获取原来的图片和新生成图片的彩色直方图：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170505/Selection_050501.png" alt=""></p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170505/Selection_050502.png" alt=""></p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170505/Selection_050503.png" alt=""></p>
<p>可以看到，最后生成的直方图和目标直方图(sea-hist)是基本一致的，这样就是达到了正规化的目的。</p>
<h4 id="直方图比较">直方图比较</h4>
<p>我们也可以通过比较直方图来检测图像的相似度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;colorhistogram.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageCompparator</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cv::Mat refH;  <span class="comment">// reference histogram</span></span><br><span class="line">    cv::Mat inputH;  <span class="comment">// histogram of input image</span></span><br><span class="line"></span><br><span class="line">    ColorHistogram hist;  <span class="comment">// to generate the histograms number of bins used in each color channel</span></span><br><span class="line">    <span class="type">int</span> nBins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ImageCompparator</span>():<span class="built_in">nBins</span>(<span class="number">8</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set and compute histogram of reference image</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setReferenceImage</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">        hist.<span class="built_in">setSize</span>(nBins);</span><br><span class="line">        refH = hist.<span class="built_in">getHistogram</span>(image);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comapre the image using their BGR histograms</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">        inputH = hist.<span class="built_in">getHistogram</span>(image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//histogram comparison using intersection</span></span><br><span class="line">        <span class="keyword">return</span> cv::<span class="built_in">compareHist</span>(refH, inputH, cv::HISTCMP_INTERSECT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/waves.jpg&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    ImageCompparator c;</span><br><span class="line">    c.<span class="built_in">setReferenceImage</span>(image);</span><br><span class="line"></span><br><span class="line">    cv::Mat wave, beach, cattle;</span><br><span class="line">    wave = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/waves.jpg&quot;</span>);  <span class="comment">// 和自身比较</span></span><br><span class="line">    beach = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/beach.jpg&quot;</span>);  <span class="comment">// 和较为相似的比较</span></span><br><span class="line">    cattle = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>);  <span class="comment">// 和不相似的比较</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> waves = c.<span class="built_in">compare</span>(wave);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;wave&#x27;s score: &quot;</span>+std::<span class="built_in">to_string</span>(waves), wave);</span><br><span class="line">    <span class="type">double</span> beachs = c.<span class="built_in">compare</span>(beach);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;beach&#x27;s score: &quot;</span>+std::<span class="built_in">to_string</span>(beachs), beach);</span><br><span class="line">    <span class="type">double</span> cattles = c.<span class="built_in">compare</span>(cattle);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;cattle&#x27;s score: &quot;</span>+std::<span class="built_in">to_string</span>(cattles), cattle);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170505/cmphists.png" alt=""></p>
<h4 id="Refrence">Refrence</h4>
<p><a href="https://www.scribd.com/document/106790597/OPENCV-Topic-04-Histogram-Specification">Scribd代码</a></p>
<p><a href="http://bj3s.pku.edu.cn/activity/subjects/lesson6.pdf">北大遥感课件</a></p>
<p>山东科大《数字图像处理》</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Const in Cpp</title>
    <url>/2017/04/09/Const-in-Cpp/</url>
    <content><![CDATA[<p>关于const在函数声明里的应用。const放在函数前与后的区别。<br>
先看下<a href="http://www.cplusplus.com/forum/general/12087/">cplusplus</a>的一个问答：</p>
<p>问：</p>
<blockquote>
<p>Could you please explain the different between:<br>
void const f() {} and void f() const {}.</p>
</blockquote>
<p>答：</p>
<blockquote>
<p>void const f() is equivilent to const void f(), which means the return type (in this case a void) is const. This is totally meaningless not only because it’s a void (there is nothing there that needs a const qualifier), but also because it’s a return type (returning something as const doesn’t make a whole lot of sense).</p>
</blockquote>
<p>void f() const makes the function itself const. This only really has meaning for member functions. Making a member function const means that it cannot call any non-const member functions, nor can it change any member variables. It also means that the function can be called via a const object of the class:</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Const_No</span><span class="params">()</span></span>;   <span class="comment">// nonconst member function</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Const_Yes</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// const member function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"></span><br><span class="line">A  obj_nonconst;  <span class="comment">// nonconst object</span></span><br><span class="line">obj_nonconst.<span class="built_in">Const_No</span>();  <span class="comment">// works fine</span></span><br><span class="line">obj_nonconst.<span class="built_in">Const_Yes</span>(); <span class="comment">// works fine</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> A obj_const = <span class="built_in">A</span>(); <span class="comment">// const object</span></span><br><span class="line">obj_const.<span class="built_in">Const_Yes</span>(); <span class="comment">// works fine (const object can call const function)</span></span><br><span class="line">obj_const.<span class="built_in">Const_No</span>();  <span class="comment">// ERROR (const object cannot call nonconst function) </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再参考下<a href="http://stackoverflow.com/questions/751681/meaning-of-const-last-in-a-c-method-declaration">stackoverflow</a>:</p>
<blockquote>
<p>When you add the const keyword to a method the this pointer will essentially become const, and you can therefore not change any member data. (Unless you use mutable, more on that later).</p>
</blockquote>
<p>简单讲，就是说，const放在前面，是保证函数返回值为const；放在函数后面，是保证其调用的对象，也就是参数为const,不能被改变。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十：Converting color reprentations</title>
    <url>/2017/05/02/Converting-color-reprentations/</url>
    <content><![CDATA[<h5 id="Overview-9">Overview</h5>
<p>在第九篇中，我们通过计算颜色范围来提取出ROI（上例为蓝天部分），我们是在BGR颜色空间进行的，但是在这个颜色空间并不是很好。原因是：</p>
<blockquote>
<p>Unfortunately, computing the distance between the colors using the<br>
RGB color space is not the best way to measure the similarity between<br>
two given colors. Indeed, RGB is not a perceptually uniform color<br>
space. This means that two colors at a given distance might look very<br>
similar, while two other colors separated by the same distance might<br>
look very different.</p>
</blockquote>
<p>所以：</p>
<blockquote>
<p>To solve this problem, other color representations that have the property<br>
of being perceptually uniform have been introduced. In particular, the<br>
CIE L<em>a</em>b* is one such color model. By converting our images to this<br>
representation, the Euclidean distance between an image pixel and the<br>
target color will then be a meaningful measure of the visual similarity<br>
between the two colors.</p>
</blockquote>
<h5 id="Code-9">Code</h5>
<p>这里核心的程序就是转换到另一个颜色空间进行颜色比较和颜色范围的界定。</p>
<p>主要改动就是process这里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">ColorDetector::process</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">    <span class="comment">// re-allocate binary map if necessary</span></span><br><span class="line">    <span class="comment">// same size as input image, but 1-channel</span></span><br><span class="line">    result.<span class="built_in">create</span>(image.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Converting to Lab color space</span></span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, converted, CV_BGR2Lab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processing</span></span><br><span class="line">    <span class="comment">// get the iterators</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it = converted.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator itend = converted.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;uchar&gt;::iterator itout = result.<span class="built_in">begin</span>&lt;uchar&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each pixel</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=itend;++it, ++itout)&#123;</span><br><span class="line">        <span class="comment">// compute distance from target color</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getColorDitanceToTargetColor</span>(*it) &lt;= maxDist)&#123;</span><br><span class="line">            *itout = <span class="number">255</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *itout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便运行，这里也贴下完整的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorDetector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// minimun accptable distance</span></span><br><span class="line">    <span class="type">int</span> maxDist;</span><br><span class="line">    <span class="comment">// target color</span></span><br><span class="line">    cv::Vec3b target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// image containing resulting binary map</span></span><br><span class="line">    cv::Mat result, converted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty constructor</span></span><br><span class="line">    <span class="comment">// default parameter initialization here</span></span><br><span class="line">    <span class="built_in">ColorDetector</span>():<span class="built_in">maxDist</span>(<span class="number">15</span>),<span class="built_in">target</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// another constructor with target and distance</span></span><br><span class="line">    <span class="built_in">ColorDetector</span>(uchar blue, uchar green, uchar red, <span class="type">int</span> mxDist)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color distance threshold</span></span><br><span class="line">    <span class="comment">// Threshold must be positive,</span></span><br><span class="line">    <span class="comment">// otherwise distance threshold is set to 0.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColorDistanceThreshold</span><span class="params">(<span class="type">int</span> distance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(distance&lt;<span class="number">0</span>)</span><br><span class="line">            distance = <span class="number">0</span>;</span><br><span class="line">        maxDist = distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets the color distance threshold</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDistanceThreshold</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxDist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color to be detected</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTargetColor</span><span class="params">(uchar blue, uchar green, uchar red)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Temporary 1-pixel image</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">tmp</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,CV_8UC3)</span></span>;</span><br><span class="line">        tmp.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(<span class="number">0</span>,<span class="number">0</span>) = cv::<span class="built_in">Vec3b</span>(blue, green, red);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Converting the target to Lab color space</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(tmp, tmp, CV_BGR2Lab);</span><br><span class="line"></span><br><span class="line">        target = tmp.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color to be detected</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTargetColor</span><span class="params">(cv::Vec3b color)</span></span>&#123;</span><br><span class="line">        target = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets the color to be detected</span></span><br><span class="line">    <span class="function">cv::Vec3b <span class="title">getTargetColor</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">process</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">process_bycv</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDitanceToTargetColor</span><span class="params">(<span class="type">const</span> cv::Vec3b&amp; color)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getColorDistance</span>(color, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Compute the city-block distance between two colors</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDistance</span><span class="params">(<span class="type">const</span> cv::Vec3b&amp;color1, <span class="type">const</span> cv::Vec3b&amp; color2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(color1[<span class="number">0</span>]-color2[<span class="number">0</span>]+</span><br><span class="line">                   <span class="built_in">abs</span>(color1[<span class="number">1</span>])-color2[<span class="number">1</span>]+</span><br><span class="line">                   <span class="built_in">abs</span>(color1[<span class="number">2</span>]-color2[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">ColorDetector::process</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">    <span class="comment">// re-allocate binary map if necessary</span></span><br><span class="line">    <span class="comment">// same size as input image, but 1-channel</span></span><br><span class="line">    result.<span class="built_in">create</span>(image.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Converting to Lab color space</span></span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, converted, CV_BGR2Lab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processing</span></span><br><span class="line">    <span class="comment">// get the iterators</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it = converted.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator itend = converted.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;uchar&gt;::iterator itout = result.<span class="built_in">begin</span>&lt;uchar&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each pixel</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=itend;++it, ++itout)&#123;</span><br><span class="line">        <span class="comment">// compute distance from target color</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getColorDitanceToTargetColor</span>(*it) &lt;= maxDist)&#123;</span><br><span class="line">            *itout = <span class="number">255</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *itout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. Create image processor object</span></span><br><span class="line">    ColorDetector cdetect;</span><br><span class="line">    <span class="comment">//2. Read input image</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(image.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. Set input parameters</span></span><br><span class="line">    cdetect.<span class="built_in">setTargetColor</span>(<span class="number">230</span>, <span class="number">220</span>, <span class="number">130</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. Process the image and display the result</span></span><br><span class="line">    cv::Mat result = cdetect.<span class="built_in">process</span>(image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Process Result&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    cv::Mat masked, result_inv;</span><br><span class="line">    cv::<span class="built_in">bitwise_not</span>(result, result_inv);</span><br><span class="line"></span><br><span class="line">    image.<span class="built_in">copyTo</span>(masked, result_inv);</span><br><span class="line">    cv::<span class="built_in">add</span>(masked, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), masked, result);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Masked&quot;</span>, masked);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170502/Selection_003.png" alt=""></p>
<p>貌似，效果差不多…</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Coursera-ML</title>
    <url>/2017/07/25/Coursera-ML-ex1-Linear-Regression/</url>
    <content><![CDATA[<h4 id="Overview-10">Overview</h4>
<p>Coursera上AndrawNg的ML课程，昨天写完了线性回归的编程作业，因为公式都已经推导出来了，所以编程实现相对比较简单。这里整理下，补充了一些代码，增强了一些可视化的效果。相关的帮助文档在课程中都能找得到，本次练习资料：<a href="https://www.coursera.org/learn/machine-learning/programming/8f3qT/linear-regression">传送门</a>。</p>
<blockquote>
<p>这里只是线性回归的代码，本来打算把所有的代码贴到这里的，但是感觉文件太多会比较乱。前几天刚好结束了这门课，直接就把代码丢到了<a href="https://github.com/shenxiangzhuang/Coursera_ML">Github</a>上。</p>
</blockquote>
<h4 id="Linear-regression-with-one-variable">Linear regression with one variable</h4>
<h5 id="ex1-m">ex1.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% Machine Learning Online Class - Exercise 1: Linear Regression</span><br><span class="line"></span><br><span class="line">%  Instructions</span><br><span class="line">%  ------------</span><br><span class="line">%</span><br><span class="line">%  This file contains code that helps you get started on the</span><br><span class="line">%  linear exercise. You will need to complete the following functions</span><br><span class="line">%  in this exericse:</span><br><span class="line">%</span><br><span class="line">%     warmUpExercise.m</span><br><span class="line">%     plotData.m</span><br><span class="line">%     gradientDescent.m</span><br><span class="line">%     computeCost.m</span><br><span class="line">%     gradientDescentMulti.m</span><br><span class="line">%     computeCostMulti.m</span><br><span class="line">%     featureNormalize.m</span><br><span class="line">%     normalEqn.m</span><br><span class="line">%</span><br><span class="line">%  For this exercise, you will not need to change any code in this file,</span><br><span class="line">%  or any other files other than those mentioned above.</span><br><span class="line">%</span><br><span class="line">% x refers to the population size in 10,000s</span><br><span class="line">% y refers to the profit in $10,000s</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">%% Initialization</span><br><span class="line">clear ; close all; clc</span><br><span class="line"></span><br><span class="line">%% ==================== Part 1: Basic Function ====================</span><br><span class="line">% Complete warmUpExercise.m</span><br><span class="line">fprintf(&#x27;Running warmUpExercise ... \n&#x27;);</span><br><span class="line">fprintf(&#x27;5x5 Identity Matrix: \n&#x27;);</span><br><span class="line">warmUpExercise()</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% ======================= Part 2: Plotting =======================</span><br><span class="line">fprintf(&#x27;Plotting Data ...\n&#x27;)</span><br><span class="line">data = load(&#x27;ex1data1.txt&#x27;);</span><br><span class="line">X = data(:, 1); y = data(:, 2);</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line"></span><br><span class="line">% Plot Data</span><br><span class="line">% Note: You have to complete the code in plotData.m</span><br><span class="line">plotData(X, y);</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line">%% =================== Part 3: Cost and Gradient descent ===================</span><br><span class="line"></span><br><span class="line">X = [ones(m, 1), data(:,1)]; % Add a column of ones to x</span><br><span class="line">theta = zeros(2, 1); % initialize fitting parameters</span><br><span class="line"></span><br><span class="line">% Some gradient descent settings</span><br><span class="line">iterations = 1500;</span><br><span class="line">alpha = 0.01;</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;\nTesting the cost function ...\n&#x27;)</span><br><span class="line">% compute and display initial cost</span><br><span class="line">J = computeCost(X, y, theta);</span><br><span class="line">fprintf(&#x27;With theta = [0 ; 0]\nCost computed = %f\n&#x27;, J);</span><br><span class="line">fprintf(&#x27;Expected cost value (approx) 32.07\n&#x27;);</span><br><span class="line"></span><br><span class="line">% further testing of the cost function</span><br><span class="line">J = computeCost(X, y, [-1 ; 2]);</span><br><span class="line">fprintf(&#x27;\nWith theta = [-1 ; 2]\nCost computed = %f\n&#x27;, J);</span><br><span class="line">fprintf(&#x27;Expected cost value (approx) 54.24\n&#x27;);</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;\nRunning Gradient Descent ...\n&#x27;)</span><br><span class="line">% run gradient descent</span><br><span class="line">[theta, J_history, theta_history] = gradientDescent(X, y, theta, alpha, iterations);</span><br><span class="line"></span><br><span class="line">% print theta to screen</span><br><span class="line">fprintf(&#x27;Theta found by gradient descent:\n&#x27;);</span><br><span class="line">fprintf(&#x27;%f\n&#x27;, theta);</span><br><span class="line">fprintf(&#x27;Expected theta values (approx)\n&#x27;);</span><br><span class="line">fprintf(&#x27; -3.6303\n  1.1664\n\n&#x27;);</span><br><span class="line"></span><br><span class="line">% Plot the linear fit</span><br><span class="line">hold on; % keep previous plot visible</span><br><span class="line">plot(X(:,2), X*theta, &#x27;-&#x27;)</span><br><span class="line">legend(&#x27;Training data&#x27;, &#x27;Linear regression&#x27;)</span><br><span class="line">hold off % don&#x27;t overlay any more plots on this figure</span><br><span class="line"></span><br><span class="line">% Predict values for population sizes of 35,000 and 70,000</span><br><span class="line">predict1 = [1, 3.5] *theta;</span><br><span class="line">fprintf(&#x27;For population = 35,000, we predict a profit of %f\n&#x27;,...</span><br><span class="line">    predict1*10000);</span><br><span class="line">predict2 = [1, 7] * theta;</span><br><span class="line">fprintf(&#x27;For population = 70,000, we predict a profit of %f\n&#x27;,...</span><br><span class="line">    predict2*10000);</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line">%% ============= Part 4: Visualizing J(theta_0, theta_1) =============</span><br><span class="line">fprintf(&#x27;Visualizing J(theta_0, theta_1) ...\n&#x27;)</span><br><span class="line"></span><br><span class="line">% Grid over which we will calculate J</span><br><span class="line">theta0_vals = linspace(-10, 10, 100);</span><br><span class="line">theta1_vals = linspace(-1, 4, 100);</span><br><span class="line"></span><br><span class="line">% initialize J_vals to a matrix of 0&#x27;s</span><br><span class="line">J_vals = zeros(length(theta0_vals), length(theta1_vals));</span><br><span class="line"></span><br><span class="line">% Fill out J_vals</span><br><span class="line">for i = 1:length(theta0_vals)</span><br><span class="line">    for j = 1:length(theta1_vals)</span><br><span class="line">      t = [theta0_vals(i); theta1_vals(j)];</span><br><span class="line">      J_vals(i,j) = computeCost(X, y, t);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% Because of the way meshgrids work in the surf command, we need to</span><br><span class="line">% transpose J_vals before calling surf, or else the axes will be flipped</span><br><span class="line">J_vals = J_vals&#x27;;</span><br><span class="line">% Surface plot</span><br><span class="line">figure;</span><br><span class="line">surf(theta0_vals, theta1_vals, J_vals)</span><br><span class="line">xlabel(&#x27;\theta_0&#x27;); ylabel(&#x27;\theta_1&#x27;);</span><br><span class="line"></span><br><span class="line">% Contour plot</span><br><span class="line">figure;</span><br><span class="line">% Plot J_vals as 15 contours spaced logarithmically between 0.01 and 100</span><br><span class="line">contour(theta0_vals, theta1_vals, J_vals, logspace(-2, 3, 20))</span><br><span class="line">xlabel(&#x27;\theta_0&#x27;); ylabel(&#x27;\theta_1&#x27;);</span><br><span class="line">hold on;</span><br><span class="line">nums_of_theta = size(theta_history, 1);</span><br><span class="line">plot(theta_history(1:nums_of_theta-1, 1), theta_history(1:nums_of_theta-1, 2), &#x27;go&#x27;, &#x27;MarkerSize&#x27;, 5, &#x27;LineWidth&#x27;, 1);</span><br><span class="line">plot(theta(1), theta(2), &#x27;rx&#x27;, &#x27;MarkerSize&#x27;, 10, &#x27;LineWidth&#x27;, 2);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="plotData-m">plotData.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function plotData(x, y)</span><br><span class="line">%PLOTDATA Plots the data points x and y into a new figure </span><br><span class="line">%   PLOTDATA(x,y) plots the data points and gives the figure axes labels of</span><br><span class="line">%   population and profit.</span><br><span class="line"></span><br><span class="line">figure; % open a new figure window</span><br><span class="line">plot(x, y, &#x27;rx&#x27;, &#x27;MarkerSize&#x27;, 10);</span><br><span class="line">xlabel(&#x27;population&#x27;); ylabel(&#x27;revenue&#x27;);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="computeCost-m">computeCost.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function J = computeCost(X, y, theta)</span><br><span class="line">%COMPUTECOST Compute cost for linear regression</span><br><span class="line">%   J = COMPUTECOST(X, y, theta) computes the cost of using theta as the</span><br><span class="line">%   parameter for linear regression to fit the data points in X and y</span><br><span class="line"></span><br><span class="line">% Initialize some useful values</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line"></span><br><span class="line">% You need to return the following variables correctly </span><br><span class="line">J = 0;</span><br><span class="line"></span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Instructions: Compute the cost of a particular choice of theta</span><br><span class="line">%               You should set J to the cost.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">J = sum((X * theta - y).^2)/(2 * m);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="gradientDescent-m">gradientDescent.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function [theta, J_history, theta_history] = gradientDescent(X, y, theta, alpha, num_iters)</span><br><span class="line">%GRADIENTDESCENT Performs gradient descent to learn theta</span><br><span class="line">%   theta = GRADIENTDESCENT(X, y, theta, alpha, num_iters) updates theta by </span><br><span class="line">%   taking num_iters gradient steps with learning rate alpha</span><br><span class="line"></span><br><span class="line">% Initialize some useful values</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line">J_history = zeros(num_iters, 1);</span><br><span class="line">theta_history = zeros(num_iters, 2);</span><br><span class="line"></span><br><span class="line">for iter = 1:num_iters</span><br><span class="line"></span><br><span class="line">    % ====================== YOUR CODE HERE ======================</span><br><span class="line">    % Instructions: Perform a single gradient step on the parameter vector</span><br><span class="line">    %               theta. </span><br><span class="line">    %</span><br><span class="line">    % Hint: While debugging, it can be useful to print out the values</span><br><span class="line">    %       of the cost function (computeCost) and gradient here.</span><br><span class="line">    %</span><br><span class="line">    size(X);  % 97x2</span><br><span class="line">    size(theta);  % 2x1</span><br><span class="line">    size(y);  % 97x1</span><br><span class="line">    change = (alpha/m) * (X&#x27; * (X * theta - y));</span><br><span class="line">    theta = theta - change;</span><br><span class="line"></span><br><span class="line">    % ============================================================</span><br><span class="line"></span><br><span class="line">    % Save the cost J in every iteration    </span><br><span class="line">    J_history(iter) = computeCost(X, y, theta);</span><br><span class="line">    theta_history(iter, :) = theta;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Running warmUpExercise ...
5x5 Identity Matrix:
ans =

Diagonal Matrix

   1   0   0   0   0
   0   1   0   0   0
   0   0   1   0   0
   0   0   0   1   0
   0   0   0   0   1

Program paused. Press enter to continue.
Plotting Data ...
Program paused. Press enter to continue.

Testing the cost function ...
With theta = [0 ; 0]
Cost computed = 32.072734
Expected cost value (approx) 32.07

With theta = [-1 ; 2]
Cost computed = 54.242455
Expected cost value (approx) 54.24
Program paused. Press enter to continue.

Running Gradient Descent ...
Theta found by gradient descent:
-3.630291
1.166362
Expected theta values (approx)
 -3.6303
  1.1664

For population = 35,000, we predict a profit of 4519.767868
For population = 70,000, we predict a profit of 45342.450129
Program paused. Press enter to continue.
Visualizing J(theta_0, theta_1) ...
</code></pre>
<p>几张图：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Figure%201_072501.png" alt=""><br>
<img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Figure%202_072502.png" alt=""><br>
<img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Figure%203_072503.png" alt=""></p>
<h4 id="Linear-regression-with-multiple-variables">Linear regression with multiple variables</h4>
<h5 id="ex1-multi-m">ex1_multi.m</h5>
<p>需要注意的是，我们在根据新的数据预测价格的时候，要记得根据之前归一化mu和sigma对新的数据进行相同的处理。这点在帮助文档中也特别提出了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">%% Machine Learning Online Class</span><br><span class="line">%  Exercise 1: Linear regression with multiple variables</span><br><span class="line">%</span><br><span class="line">%  Instructions</span><br><span class="line">%  ------------</span><br><span class="line">% </span><br><span class="line">%  This file contains code that helps you get started on the</span><br><span class="line">%  linear regression exercise. </span><br><span class="line">%</span><br><span class="line">%  You will need to complete the following functions in this </span><br><span class="line">%  exericse:</span><br><span class="line">%</span><br><span class="line">%     warmUpExercise.m</span><br><span class="line">%     plotData.m</span><br><span class="line">%     gradientDescent.m</span><br><span class="line">%     computeCost.m</span><br><span class="line">%     gradientDescentMulti.m</span><br><span class="line">%     computeCostMulti.m</span><br><span class="line">%     featureNormalize.m</span><br><span class="line">%     normalEqn.m</span><br><span class="line">%</span><br><span class="line">%  For this part of the exercise, you will need to change some</span><br><span class="line">%  parts of the code below for various experiments (e.g., changing</span><br><span class="line">%  learning rates).</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">%% Initialization</span><br><span class="line"></span><br><span class="line">%% ================ Part 1: Feature Normalization ================</span><br><span class="line"></span><br><span class="line">%% Clear and Close Figures</span><br><span class="line">clear ; close all; clc</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Loading data ...\n&#x27;);</span><br><span class="line"></span><br><span class="line">%% Load Data</span><br><span class="line">data = load(&#x27;ex1data2.txt&#x27;);</span><br><span class="line">X = data(:, 1:2);</span><br><span class="line">y = data(:, 3);</span><br><span class="line">m = length(y);</span><br><span class="line"></span><br><span class="line">% Print out some data points</span><br><span class="line">fprintf(&#x27;First 10 examples from the dataset: \n&#x27;);</span><br><span class="line">fprintf(&#x27; x = [%.0f %.0f], y = %.0f \n&#x27;, [X(1:10,:) y(1:10,:)]&#x27;);</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line">% Scale features and set them to zero mean</span><br><span class="line">fprintf(&#x27;Normalizing Features ...\n&#x27;);</span><br><span class="line"></span><br><span class="line">[X mu sigma] = featureNormalize(X);</span><br><span class="line"></span><br><span class="line">% Add intercept term to X</span><br><span class="line">X = [ones(m, 1) X];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% ================ Part 2: Gradient Descent ================</span><br><span class="line"></span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Instructions: We have provided you with the following starter</span><br><span class="line">%               code that runs gradient descent with a particular</span><br><span class="line">%               learning rate (alpha). </span><br><span class="line">%</span><br><span class="line">%               Your task is to first make sure that your functions - </span><br><span class="line">%               computeCost and gradientDescent already work with </span><br><span class="line">%               this starter code and support multiple variables.</span><br><span class="line">%</span><br><span class="line">%               After that, try running gradient descent with </span><br><span class="line">%               different values of alpha and see which one gives</span><br><span class="line">%               you the best result.</span><br><span class="line">%</span><br><span class="line">%               Finally, you should complete the code at the end</span><br><span class="line">%               to predict the price of a 1650 sq-ft, 3 br house.</span><br><span class="line">%</span><br><span class="line">% Hint: By using the &#x27;hold on&#x27; command, you can plot multiple</span><br><span class="line">%       graphs on the same figure.</span><br><span class="line">%</span><br><span class="line">% Hint: At prediction, make sure you do the same feature normalization.</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Running gradient descent ...\n&#x27;);</span><br><span class="line"></span><br><span class="line">% Choose some alpha value</span><br><span class="line">alpha = 0.01;</span><br><span class="line">num_iters = 400;</span><br><span class="line"></span><br><span class="line">% Init Theta and Run Gradient Descent </span><br><span class="line">theta = zeros(3, 1);</span><br><span class="line">[theta, J_history] = gradientDescentMulti(X, y, theta, alpha, num_iters);</span><br><span class="line"></span><br><span class="line">% Plot the convergence graph</span><br><span class="line">figure;</span><br><span class="line">plot(1:numel(J_history), J_history, &#x27;-b&#x27;, &#x27;LineWidth&#x27;, 2);</span><br><span class="line">xlabel(&#x27;Number of iterations&#x27;);</span><br><span class="line">ylabel(&#x27;Cost J&#x27;);</span><br><span class="line"></span><br><span class="line">% Display gradient descent&#x27;s result</span><br><span class="line">fprintf(&#x27;Theta computed from gradient descent: \n&#x27;);</span><br><span class="line">fprintf(&#x27; %f \n&#x27;, theta);</span><br><span class="line">fprintf(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">% Estimate the price of a 1650 sq-ft, 3 br house</span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Recall that the first column of X is all-ones. Thus, it does</span><br><span class="line">% not need to be normalized.</span><br><span class="line">sq_ft_norm = (1650-mu(1))/sigma(1);</span><br><span class="line">br_norm = (3-mu(2))/sigma(2);</span><br><span class="line">price = price = theta(1) + theta(2)*sq_ft_norm + theta(3)*br_norm; % You should change this</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% ============================================================</span><br><span class="line"></span><br><span class="line">fprintf([&#x27;Predicted price of a 1650 sq-ft, 3 br house &#x27; ...</span><br><span class="line">         &#x27;(using gradient descent):\n $%f\n&#x27;], price);</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Program paused. Press enter to continue.\n&#x27;);</span><br><span class="line">pause;</span><br><span class="line"></span><br><span class="line">%% ================ Part 3: Normal Equations ================</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Solving with normal equations...\n&#x27;);</span><br><span class="line"></span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Instructions: The following code computes the closed form </span><br><span class="line">%               solution for linear regression using the normal</span><br><span class="line">%               equations. You should complete the code in </span><br><span class="line">%               normalEqn.m</span><br><span class="line">%</span><br><span class="line">%               After doing so, you should complete this code </span><br><span class="line">%               to predict the price of a 1650 sq-ft, 3 br house.</span><br><span class="line">%</span><br><span class="line"></span><br><span class="line">%% Load Data</span><br><span class="line">data = csvread(&#x27;ex1data2.txt&#x27;);</span><br><span class="line">X = data(:, 1:2);</span><br><span class="line">y = data(:, 3);</span><br><span class="line">m = length(y);</span><br><span class="line"></span><br><span class="line">% Add intercept term to X</span><br><span class="line">X = [ones(m, 1) X];</span><br><span class="line"></span><br><span class="line">% Calculate the parameters from the normal equation</span><br><span class="line">theta = normalEqn(X, y);</span><br><span class="line"></span><br><span class="line">% Display normal equation&#x27;s result</span><br><span class="line">fprintf(&#x27;Theta computed from the normal equations: \n&#x27;);</span><br><span class="line">fprintf(&#x27; %f \n&#x27;, theta);</span><br><span class="line">fprintf(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% Estimate the price of a 1650 sq-ft, 3 br house</span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">price = theta(1) + theta(2)*1650 + theta(3)*3; % You should change this</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% ============================================================</span><br><span class="line"></span><br><span class="line">fprintf([&#x27;Predicted price of a 1650 sq-ft, 3 br house &#x27; ...</span><br><span class="line">         &#x27;(using normal equations):\n $%f\n&#x27;], price);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="computeCostMulti-m">computeCostMulti.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function J = computeCostMulti(X, y, theta)</span><br><span class="line">%COMPUTECOSTMULTI Compute cost for linear regression with multiple variables</span><br><span class="line">%   J = COMPUTECOSTMULTI(X, y, theta) computes the cost of using theta as the</span><br><span class="line">%   parameter for linear regression to fit the data points in X and y</span><br><span class="line"></span><br><span class="line">% Initialize some useful values</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line"></span><br><span class="line">% You need to return the following variables correctly </span><br><span class="line">J = 0;</span><br><span class="line"></span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Instructions: Compute the cost of a particular choice of theta</span><br><span class="line">%               You should set J to the cost.</span><br><span class="line"></span><br><span class="line">J = (((X*theta - y)&#x27;)*(X*theta - y))/(2*m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% =========================================================================</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="featureNormalize-m">featureNormalize.m</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function [X_norm, mu, sigma] = featureNormalize(X)</span><br><span class="line">%FEATURENORMALIZE Normalizes the features in X </span><br><span class="line">%   FEATURENORMALIZE(X) returns a normalized version of X where</span><br><span class="line">%   the mean value of each feature is 0 and the standard deviation</span><br><span class="line">%   is 1. This is often a good preprocessing step to do when</span><br><span class="line">%   working with learning algorithms.</span><br><span class="line"></span><br><span class="line">% You need to set these values correctly</span><br><span class="line">X_norm = X;</span><br><span class="line">mu = zeros(1, size(X, 2));</span><br><span class="line">sigma = zeros(1, size(X, 2));</span><br><span class="line"></span><br><span class="line">% ====================== YOUR CODE HERE ======================</span><br><span class="line">% Instructions: First, for each feature dimension, compute the mean</span><br><span class="line">%               of the feature and subtract it from the dataset,</span><br><span class="line">%               storing the mean value in mu. Next, compute the </span><br><span class="line">%               standard deviation of each feature and divide</span><br><span class="line">%               each feature by it&#x27;s standard deviation, storing</span><br><span class="line">%               the standard deviation in sigma. </span><br><span class="line">%</span><br><span class="line">%               Note that X is a matrix where each column is a </span><br><span class="line">%               feature and each row is an example. You need </span><br><span class="line">%               to perform the normalization separately for </span><br><span class="line">%               each feature. </span><br><span class="line">%</span><br><span class="line">% Hint: You might find the &#x27;mean&#x27; and &#x27;std&#x27; functions useful.</span><br><span class="line">%       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cols = size(X, 2);</span><br><span class="line">for col = 1:cols</span><br><span class="line">    featurex = X(:, col);</span><br><span class="line"></span><br><span class="line">    mux = mean(featurex);</span><br><span class="line">    mu(col) = mux;</span><br><span class="line"></span><br><span class="line">    featurex = featurex - mux;</span><br><span class="line"></span><br><span class="line">    sigmax = std(featurex);</span><br><span class="line">    sigma(col) = sigmax;</span><br><span class="line"></span><br><span class="line">    featurex = featurex/sigmax;</span><br><span class="line"></span><br><span class="line">    X_norm(:, col) = featurex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% ============================================================</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="gradientDescentMulti-m">gradientDescentMulti.m</h5>
<p>这里和单变量的是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function [theta, J_history] = gradientDescentMulti(X, y, theta, alpha, num_iters)</span><br><span class="line">%GRADIENTDESCENTMULTI Performs gradient descent to learn theta</span><br><span class="line">%   theta = GRADIENTDESCENTMULTI(x, y, theta, alpha, num_iters) updates theta by</span><br><span class="line">%   taking num_iters gradient steps with learning rate alpha</span><br><span class="line"></span><br><span class="line">% Initialize some useful values</span><br><span class="line">m = length(y); % number of training examples</span><br><span class="line">J_history = zeros(num_iters, 1);</span><br><span class="line"></span><br><span class="line">for iter = 1:num_iters</span><br><span class="line"></span><br><span class="line">    % ====================== YOUR CODE HERE ======================</span><br><span class="line">    % Instructions: Perform a single gradient step on the parameter vector</span><br><span class="line">    %               theta. </span><br><span class="line">    %</span><br><span class="line">    % Hint: While debugging, it can be useful to print out the values</span><br><span class="line">    %       of the cost function (computeCostMulti) and gradient here.</span><br><span class="line">    %</span><br><span class="line"></span><br><span class="line">    change = (alpha/m) * (X&#x27; * (X * theta - y));</span><br><span class="line">    theta = theta - change;</span><br><span class="line">    % ============================================================</span><br><span class="line"></span><br><span class="line">    % Save the cost J in every iteration    </span><br><span class="line">    J_history(iter) = computeCostMulti(X, y, theta);</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Loading data ...
First 10 examples from the dataset:
 x = [2104 3], y = 399900
 x = [1600 3], y = 329900
 x = [2400 3], y = 369000
 x = [1416 2], y = 232000
 x = [3000 4], y = 539900
 x = [1985 4], y = 299900
 x = [1534 3], y = 314900
 x = [1427 3], y = 198999
 x = [1380 3], y = 212000
 x = [1494 3], y = 242500
Program paused. Press enter to continue.
Normalizing Features ...
Running gradient descent ...
Theta computed from gradient descent:
 334302.063993
 100087.116006
 3673.548451

Predicted price of a 1650 sq-ft, 3 br house (using gradient descent):
 $289314.620338
Program paused. Press enter to continue.
Solving with normal equations...
Theta computed from the normal equations:
 89597.909542
 139.210674
 -8738.019112

Predicted price of a 1650 sq-ft, 3 br house (using normal equations):
 $293081.464335
</code></pre>
<p>迭代图：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Figure%201_072504.png" alt=""></p>
<p>这是单变量即多变量的线性回归，主要用了梯度下降最小化cost function来进行参数的选择，也用到了Normal Equations其可以代替梯度下降法进行参数选择。关于两者的优劣与选用问题，可参考<a href="http://www.cnblogs.com/elaron/archive/2013/05/20/3088894.html">这里</a>也是根据视频总结的。此外视频中并没有对Normal Equation做太多的解释，可以参考<a href="https://zhuanlan.zhihu.com/p/22757336">这里</a>。</p>
<p>下一章就是logistic regression了，有空再写。</p>
]]></content>
      <categories>
        <category>Octave</category>
      </categories>
      <tags>
        <tag>Octave</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp Virtual members的使用</title>
    <url>/2017/03/02/Cpp-Virtual-members%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>C++类的学习–&gt;Virtual member的使用</p>
<p>先看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPolygon</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width, heigth;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_values</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;width=a; heigth=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CRectangle</span>: <span class="keyword">public</span> CPolygon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (width * heigth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTriangle</span>: <span class="keyword">public</span> CPolygon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (width * heigth / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CRectangle rect;</span><br><span class="line">    CTriangle trgl;</span><br><span class="line">    CPolygon * ppoly1 = &amp;rect;</span><br><span class="line">    CPolygon * ppoly2 = &amp;trgl;</span><br><span class="line">    ppoly1 -&gt; <span class="built_in">set_values</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    ppoly2 -&gt; <span class="built_in">set_values</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; rect.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; trgl.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>20<br>
10</p>
</blockquote>
<p>这里，最后的rect.area() 与 trgl.area（） 必须用rect 与 trgl， 而不能用(*ppoly1)或是ppoly1-&gt;  。为什么呢，我们先试下，看看报错：</p>
<p>变动只有这两行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (*ppoly1).area() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ppoly2-&gt;area() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错如下：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/index.png" alt=""></p>
<p>报错写的很清楚了，两个指针ppoly1, ppoly2指向的基类是CPolygon, 而CPolygon类 has no member named ‘area’. 所以我们想，既然两个derived classes 都用到area, 如果能在基类里面定义就好了。但是可惜的是，两个darived class的area是不同的。</p>
<blockquote>
<p>实际上，这就是我们常说的<em>Diamond Problem</em>。<a href="https://www.geeksforgeeks.org/multiple-inheritance-in-c/">这篇文章</a>解释的比较详细。</p>
</blockquote>
<p>这时，就是Virtual member 上场的时候了。<br>
先看下Virtual member的说明：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/x.png" alt=""></p>
<p>接下来看个上面改写的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class CPolygon&#123;</span><br><span class="line">protected:                // protected与private的区别就在于能否被其derived classes使用</span><br><span class="line">    int width, height;</span><br><span class="line">public:</span><br><span class="line">    void set_values (int a, int b)&#123;</span><br><span class="line">        width=a; height=b;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual int area()</span><br><span class="line">    &#123; return (0);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CRectangle: public CPolygon&#123;</span><br><span class="line">public:</span><br><span class="line">    int area()&#123;</span><br><span class="line">        return (width * height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CTriangle: public CPolygon&#123;</span><br><span class="line">public:</span><br><span class="line">    int area()&#123;</span><br><span class="line">        return (width * height / 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    CRectangle rect;</span><br><span class="line">    CTriangle trgl;</span><br><span class="line">    CPolygon poly;</span><br><span class="line">    CPolygon * ppoly1 = &amp;rect;</span><br><span class="line">    CPolygon * ppoly2 = &amp;trgl;</span><br><span class="line">    CPolygon * ppoly3 = &amp;poly;</span><br><span class="line">    ppoly1-&gt;set_values(4, 5);</span><br><span class="line">    ppoly2-&gt;set_values(4, 5);</span><br><span class="line">    ppoly3-&gt;set_values(4, 5);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ppoly1-&gt;area() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ppoly2-&gt;area() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ppoly3-&gt;area() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>20<br>
10<br>
0</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/virtual.png" alt=""></p>
<p>参考：<em>The C++ Language Tutorial</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Dangling pointer and Lifetime</title>
    <url>/2018/01/24/Dangling-pointer-and-Lifetime/</url>
    <content><![CDATA[<h4 id="Overview-11">Overview</h4>
<p>在CW刷C的题，一道7ku的题目写了快100行…（虽然完成率只有1%）,然后还出错了…折腾下改好了。回头发现原来是写了Dangling pointer.</p>
<h4 id="Code-10">Code</h4>
<p>将原问题抽象成下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">readData</span><span class="params">(<span class="type">char</span> s[<span class="number">10</span>])</span>&#123;</span><br><span class="line">	fgets(s, <span class="number">10</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">return</span> readData(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *pch = foo();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的main函数中的pch就是dangling pointer了，因为在foo函数执行完之后，s的内存就被释放掉了，此时pch指向的内存中保存的数据是undefined的。所以（可能由于内存未刷新的原因），多次执行这个程序，有时也会正常打印，但是大部分时候是不行的。</p>
<p>这就涉及到了变量的lifetime的问题（参考<a href="https://blog.feabhas.com/2010/09/scope-and-lifetime-of-variables-in-c/">这里</a>），如上，s是属于最常见的automatic objects,所以其内存会随着函数执行的结束而释放。解决办法有两种，就是使用其他两种变量(static&amp;dynamic)来替换这里作为automatic的s。</p>
<h5 id="static">static</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">readData</span><span class="params">(<span class="type">char</span> s[<span class="number">10</span>])</span>&#123;</span><br><span class="line">	fgets(s, <span class="number">10</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">return</span> readData(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *pch = foo();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只需要将原来foo函数中的<code>char s[10]</code>改为<code>static char s[10]</code>即可。这种方法虽然简单，但是有个缺点，就是这里分配的内存应为确定的，这里是10。所以不太方便。</p>
<h5 id="dynamic">dynamic</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">readData</span><span class="params">(<span class="type">char</span> s[<span class="number">10</span>])</span>&#123;</span><br><span class="line">	fgets(s, <span class="number">10</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	s = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> readData(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *pch = foo();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, pch);</span><br><span class="line">	<span class="built_in">free</span>(pch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里改动也是不多的，只是用了<code>malloc</code>和<code>free</code>来动态地分配和释放内存。</p>
<p>其实，严格来说，dynamic也是属于automatic的，只不过有些不同：</p>
<blockquote>
<p>Strictly speaking (according to the C standard) dynamically allocated objects are also called automatics. However, it is important to differentiate between this type of object and automatics for two reasons:</p>
</blockquote>
<blockquote>
<p>The memory is allocated from a different memory area (the heap not the stack)</p>
</blockquote>
<blockquote>
<p>The lifetime is under the control of the programmer rather than the C run-time system.</p>
</blockquote>
<p>第二条是我们想要利用的属性，也就是可控的lifetime.</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure in C: Singly Linked Lists</title>
    <url>/2019/02/14/Data-Structure-in-C-Singly-Linked-Lists/</url>
    <content><![CDATA[<h3 id="Overview-12">Overview</h3>
<p>但凡提及<code>Data Structure</code>的学习总是从<code>Single Linked List</code>开始…之前看<em>Data Structures and Algorithms in C++<em>在<a href="http://datahonor.com/2017/04/25/Singly-Linked-Lists/">Singly Linked Lists</a>写过一个Cpp版本的，实现的东西比较简单一些。后来有看了</em>Data Structure Using C</em>(一些笔记放在<a href="https://github.com/shenxiangzhuang/DataStructureUsingC">这里</a>), 这书写的十分细致，而且代码比较好看懂(虽然偶尔Bug比较多…)。但是两本书写的东西都有些局限的地方，比如都只是“面向”<code>Int</code>类型给出的实现。这在<em>Master Algorithms with C</em>得到很好的实现，因为它把链表存储的对象换成了<code>generic pointer</code>,这就使得可以进行任何类型数据的存储。</p>
<p>下面首先结合前面两本书给出<code>Int</code>类型的实现，后给出<code>generic pointer</code>的实现。</p>
<h3 id="Code-11">Code</h3>
<h4 id="Int-type-version">Int type version</h4>
<h5 id="singlelinkedlist-h">singlelinkedlist.h</h5>
<p>注意，下面的两个自定义的<code>type</code>，<code>Node</code>就是我们的链表元素，或者叫节点。<code>List</code>就是链表。</p>
<p>这里我们实现了大部分可以想到的操作…包括增[4]删[4]改[1]查[1],创建，打印，排序[<code>Buble sort</code>]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 19-2-14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_SINGLELINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_SINGLELINKEDLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node&#x27;s data structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Node</span> *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linked list&#x27;s data structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">List</span>&#123;</span><br><span class="line">	Node *head;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a single linked list with length n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_create</span><span class="params">(List *list, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// print a single linked list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_print</span><span class="params">(List *list)</span></span>;</span><br><span class="line"><span class="comment">// add a Node to a list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_begin</span><span class="params">(List *list, Node *new_element)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_end</span><span class="params">(List *list, Node *new_element)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_after</span><span class="params">(List *list, <span class="type">int</span> given_node_data, Node *new_element)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_before</span><span class="params">(List *list, <span class="type">int</span> given_node_data, Node *new_element)</span></span>;</span><br><span class="line"><span class="comment">// delete Node in a list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_begin</span><span class="params">(List *list)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_end</span><span class="params">(List *list)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_given_node</span><span class="params">(List *list, <span class="type">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_delete_all</span><span class="params">(List *list)</span></span>;</span><br><span class="line"><span class="comment">// change node&#x27;s data in a list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_change</span><span class="params">(List *list, <span class="type">int</span> data, <span class="type">int</span> new_data)</span></span>;</span><br><span class="line"><span class="comment">// search a number in a list</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">node_search</span><span class="params">(List *list, <span class="type">int</span> data)</span></span>;</span><br><span class="line"><span class="comment">// sort  the list(increasing)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_sorted</span><span class="params">(List *list)</span></span>;</span><br><span class="line"><span class="comment">// test function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//TEST_SINGLELINKEDLIST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-c">main.c</h5>
<p>几点注意：</p>
<blockquote>
<p>1.为说明起见，这里没有处理重复数据的情况，重复情况下仅仅对第一个数据进行对应处理<br>
2.多次出现的temp变量，其作用就是一个工具变量，用于定位与释放内存<br>
3.在链表中，next的使用“代替”了数组中根据index的循环<br>
4.我们必须注意对空表的处理，使用if或assert来控制这一情况</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singlelinkedlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*StepINT SINGLE LINKED LIST*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_create</span><span class="params">(List *list, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, data;</span><br><span class="line">	Node *new_element;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		new_element = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		new_element-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter the data: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		new_element-&gt;data = data;</span><br><span class="line">		<span class="built_in">node_insert_end</span>(list, new_element);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_print</span><span class="params">(List *list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(list-&gt;length == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Empty List!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Node *temp;</span><br><span class="line">		temp = list-&gt;head;</span><br><span class="line">		<span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a Node to a list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_begin</span><span class="params">(List *list, Node * new_element)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 从用户输入新元素的数据</span></span><br><span class="line">	<span class="keyword">if</span>(new_element == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter the data: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		new_element = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		new_element-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		new_element-&gt;data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// empty list or not</span></span><br><span class="line">	<span class="keyword">if</span>(list-&gt;length == <span class="number">0</span>)</span><br><span class="line">		list-&gt;head = new_element;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		new_element-&gt;next = list-&gt;head;</span><br><span class="line">		list-&gt;head = new_element;</span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_end</span><span class="params">(List *list, Node *new_element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(new_element == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter the data: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		new_element = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		new_element-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		new_element-&gt;data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// empty list or not</span></span><br><span class="line">	<span class="keyword">if</span>(list-&gt;length == <span class="number">0</span>)</span><br><span class="line">		list-&gt;head = new_element;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 找到最后的元素</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		Node *temp;</span><br><span class="line">		temp = list-&gt;head;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; list-&gt;length<span class="number">-1</span>; i++)</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		<span class="comment">// 确保找到的是尾节点</span></span><br><span class="line">		<span class="built_in">assert</span>(temp-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">		temp-&gt;next = new_element;</span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_after</span><span class="params">(List *list, <span class="type">int</span> given_node_data, Node *new_element)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(new_element == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter the data of new node: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		new_element = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		new_element-&gt;data = data;</span><br><span class="line">		new_element-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp;</span><br><span class="line">	temp = list-&gt;head;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data == given_node_data)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	new_element-&gt;next = temp-&gt;next;</span><br><span class="line">	temp-&gt;next = new_element;</span><br><span class="line">	list-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_insert_before</span><span class="params">(List *list, <span class="type">int</span> given_node_data, Node *new_element)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(new_element == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter the data of new node: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">		new_element = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		new_element-&gt;data = data;</span><br><span class="line">		new_element-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// before head or not</span></span><br><span class="line">	<span class="keyword">if</span>(list-&gt;head-&gt;data == given_node_data)</span><br><span class="line">		<span class="built_in">node_insert_begin</span>(list, new_element);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Node *temp;</span><br><span class="line">		temp = list-&gt;head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp-&gt;next-&gt;data == given_node_data)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		new_element-&gt;next = temp-&gt;next;</span><br><span class="line">		temp-&gt;next = new_element;</span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete Node in a list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_begin</span><span class="params">(List *list)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	Node*temp;</span><br><span class="line">	temp = list-&gt;head;</span><br><span class="line">	list-&gt;head = list-&gt;head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	list-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_end</span><span class="params">(List *list)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 仅有一个节点</span></span><br><span class="line">	<span class="keyword">if</span>(list-&gt;length == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">free</span>(list-&gt;head);</span><br><span class="line">		list-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 两个节点及以上</span></span><br><span class="line">		<span class="comment">// 获取倒数第二个节点</span></span><br><span class="line">		Node*prev;</span><br><span class="line">		prev = list-&gt;head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(prev-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			prev = prev-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(prev-&gt;next);</span><br><span class="line">		prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_delete_given_node</span><span class="params">(List *list, <span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// if the node at 1st</span></span><br><span class="line">	<span class="keyword">if</span>(list-&gt;head-&gt;data == data)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Delete from head!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">node_delete_begin</span>(list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// two nodes or more</span></span><br><span class="line">		<span class="comment">// find the node before the given node</span></span><br><span class="line">		Node*prev, *node;</span><br><span class="line">		prev = list-&gt;head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(prev-&gt;next-&gt;data == data)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			prev = prev-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		node = prev-&gt;next;</span><br><span class="line">		prev-&gt;next = node-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(node);</span><br><span class="line">		list-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_delete_all</span><span class="params">(List *list)</span></span>&#123;</span><br><span class="line">	Node*temp;</span><br><span class="line">	<span class="keyword">while</span>(list-&gt;length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		temp = list-&gt;head;</span><br><span class="line">		list-&gt;head = list-&gt;head-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		list-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change node&#x27;s data in a list(for simple: only change the first one)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">node_change</span><span class="params">(List *list, <span class="type">int</span> data, <span class="type">int</span> new_data)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	Node *temp;</span><br><span class="line">	temp = list-&gt;head;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data == data)&#123;</span><br><span class="line">			temp-&gt;data = new_data;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search a number in a list</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">node_search</span><span class="params">(List *list, <span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(list-&gt;length &gt; <span class="number">0</span>);</span><br><span class="line">	Node *temp;</span><br><span class="line">	temp = list-&gt;head;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp-&gt;data == data)</span><br><span class="line">			count++;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Get %d &#x27;%d&#x27;!&quot;</span>, count, data);</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;There is not a %d\n&quot;</span>, data);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sort the list(increasing)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list_sorted</span><span class="params">(List *list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(list-&gt;length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Empty list!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *ptr1, *lptr;</span><br><span class="line">	<span class="type">int</span> temp, swapped;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		swapped = <span class="number">0</span>;</span><br><span class="line">		ptr1 = list-&gt;head;</span><br><span class="line">		lptr = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (ptr1-&gt;next != lptr)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ptr1-&gt;data &gt; ptr1-&gt;next-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				temp = ptr1-&gt;data;</span><br><span class="line">				ptr1-&gt;data = ptr1-&gt;next-&gt;data;</span><br><span class="line">				ptr1-&gt;next-&gt;data = temp;</span><br><span class="line">				swapped = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ptr1 = ptr1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		lptr = ptr1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (swapped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List * list;</span><br><span class="line">	list = (List *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(List));</span><br><span class="line">	list-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">	list-&gt;length = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 控制下面循环的选项; the length var</span></span><br><span class="line">	<span class="type">int</span> option, n;</span><br><span class="line">	<span class="comment">// 要用到的变量</span></span><br><span class="line">	<span class="type">int</span> given_node_data, old_data, new_data;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*****MAIN MENU *****\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1: Create a list\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2: Display a list\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3: Add a node at the beginning\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4: Add a node at the end\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;5: Add a node before a given node\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;6: Add a node after a given node\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;7: Delete a node from the beginning\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;8: Delete a node from the end\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;9: Delete a given node\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;10: Delete the entire list\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;11: Change the number\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;12: Search a number\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;13: Sort the list\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;14: EXIT\n&quot;</span>);</span><br><span class="line">		<span class="comment">// 输入选项</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter your option: &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;option);</span><br><span class="line">		<span class="keyword">switch</span>(option)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Enter the length of the list: &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">				<span class="built_in">list_create</span>(list, n);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="built_in">list_print</span>(list);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="comment">// 我们从输入来进行新增元素的初始化</span></span><br><span class="line">				<span class="comment">// 所以这里写为NULL，而非一个Node</span></span><br><span class="line">				<span class="comment">// 下同</span></span><br><span class="line">				<span class="built_in">node_insert_begin</span>(list, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				<span class="built_in">node_insert_end</span>(list, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Enter the given node data(we will insert node before it): &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;given_node_data);</span><br><span class="line">				<span class="built_in">node_insert_before</span>(list, given_node_data, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Enter the given node data(we will insert node after it): &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;given_node_data);</span><br><span class="line">				<span class="built_in">node_insert_after</span>(list, given_node_data, <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">				<span class="built_in">node_delete_begin</span>(list);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">				<span class="built_in">node_delete_end</span>(list);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">				<span class="comment">// 同插入时一样，我们从用户输入来</span></span><br><span class="line">				<span class="comment">// 指定要删除的元素，故写为NULL</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Enter the given node data: &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;given_node_data);</span><br><span class="line">				<span class="built_in">node_delete_given_node</span>(list, given_node_data);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">				<span class="built_in">list_delete_all</span>(list);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Change data.\nold data: &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;old_data);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;new data: &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;new_data);</span><br><span class="line">				<span class="built_in">node_change</span>(list, old_data, new_data);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Enter data to be searched: &quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;given_node_data);</span><br><span class="line">				<span class="built_in">node_search</span>(list, given_node_data);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">				<span class="built_in">list_sorted</span>(list);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(option != <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Generic-pointer-version">Generic pointer version</h4>
<p>暂略.</p>
<h3 id="Supplement">Supplement</h3>
<p>在CLion中写C的项目，直接把Cmake改一行比较好用。把<code>CMAKE_CXX_FLAGS</code>所在行改为<code>set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wall -Werror&quot;)</code>，参考<a href="https://stackoverflow.com/questions/26177390/how-to-create-a-c-project-with-clion">这里</a></p>
<h3 id="Reference-5">Reference</h3>
<p><em>Data Structure Using C</em><br>
<em>Master Algorithms with C</em><br>
<em>Data Structures and Algorithms in C++</em></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structure in R</title>
    <url>/2017/10/10/Data-Structure-in-R/</url>
    <content><![CDATA[<h4 id="Overview-13">Overview</h4>
<p>R中的一些数据结构，以及mode, class, typeof的区分。</p>
<h4 id="Data-Structure">Data Structure</h4>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201710/Screenshot%20from%202017-10-10%2012-29-04.png" alt=""></p>
<blockquote>
<p>R has a wide variety of objects for holding data, including scalars, vectors, matrices, arrays, data frames, and lists. They differ in terms of the type of data they can hold, how they’re created, their structural complexity, and the notation used to identify and access individual elements.</p>
</blockquote>
<p>有一点值得注意，那就是vector, matrix和array都必须是<code>single mode</code>，也就是只能储存同种类型的数据。而data.frame却更加包容：<code>different columns can contain dif- ferent modes</code>。</p>
<p>特别地，R中有两个比较特别的数据类型：factor和list。对于factor:<code>Categorical (nominal) and ordered categorical (ordinal) variables in R are called factors.</code>对于list：<code>Lists are the most complex of the R data types. Basically, a list is an ordered collection of objects (components). A list allows you to gather a variety of (possibly unrelated) objects under one name.</code>两者都算是R特有的数据类型了，而且在之后的学习中也会发现其为我们的分析提供了极大的便利。</p>
<h4 id="class-mode-and-typeof">class, mode and typeof</h4>
<h6 id="class">class</h6>
<p><code>class</code>返回对象的抽象类型（如data.frame）， 可以用来指示一些<code>generic function</code>怎样去处理这个对象。</p>
<blockquote>
<p><code>class</code> represents its abstract type, which tells generic functions like print how to handle it)</p>
</blockquote>
<h6 id="mode">mode</h6>
<p>简单讲，<code>mode</code>是返回对象在内存中是以何种方式储存的。</p>
<blockquote>
<p><code>mode</code>  represents how an object is stored in memory (numeric, character, list and function).</p>
</blockquote>
<blockquote>
<p>Function mode gives information about the mode of an object in the sense of Becker, Chambers &amp; Wilks (1988), and is more compatible with other implementations of the S language</p>
</blockquote>
<h6 id="typeof">typeof</h6>
<p>返回对象的数据类型。</p>
<blockquote>
<p>The R specific function typeof returns the type of an R object.</p>
</blockquote>
<h6 id="mode-vs-typeof">mode vs typeof</h6>
<blockquote>
<p>mode and storage.mode are the old-style types (where storage.mode is more accurate), and typeof is the newer, even more accurate version.</p>
</blockquote>
<p>解释的很清楚了，<code>mode</code>是比较旧的用法，用来查看存储的方式，而且它不如<code>storage.mode</code>精确，但是它和S语言有更好的兼容性。而<code>typeof</code>是新的用法，可以更加精确地查看对象的存储方式。所以…现在一般用typeof看下类型就行了。</p>
<h6 id="参考-2">参考</h6>
<p><a href="https://stackoverflow.com/questions/8855589/a-comprehensive-survey-of-the-types-of-things-in-r-mode-and-class-and-type">stackoverflow1</a></p>
<p><a href="https://stackoverflow.com/questions/6258004/types-and-classes-of-variables">stackoverflow2</a></p>
<p><a href="https://stats.stackexchange.com/questions/3212/mode-class-and-type-of-r-objects">stackexchange</a></p>
<p><a href="http://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Basic-types">R Language Definition</a></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning Papers</title>
    <url>/2021/01/28/Deep-Learning-Papers/</url>
    <content><![CDATA[<h1>Overview</h1>
<p>参考<a href="https://github.com/floodsung/Deep-Learning-Papers-Reading-Roadmaphttps://github.com/floodsung/Deep-Learning-Papers-Reading-Roadmap">Deep Learning Papers Reading Roadmap</a>来阅读DL相关论文，并做简单记录。</p>
<h1>Papers</h1>
<h2 id="General">General</h2>
<ul>
<li>LeCun, Yann, Yoshua Bengio, and Geoffrey Hinton. “<strong>Deep learning</strong>.” Nature 521.7553 (2015): 436-444. <a href="http://www.cs.toronto.edu/~hinton/absps/NatureDeepReview.pdf">[pdf]</a> <strong>(Three Giants’ Survey)</strong></li>
</ul>
<blockquote>
<p>2021-01-28：看完对DL有了一个更加明确的认识(其实黑盒之前的理解也差不多，只不过这里很明确地指出来了)，那就是Deep Learning主要就是learn representations of data with multiple levels of abstraction.</p>
<p>总的来说，文章指出了传统ML的缺点是： required <strong>careful engineering</strong> and considerable domain expertise to <strong>design a feature extractor</strong>. 这就使得传统ML受人工知识和经验等的限制，很难在raw data“不规则”时取得好的效果。为了使得传统ML算法更加高效，便有了kernel methods, 但是实际中发现有时候效果并不好，如Gaussian kernel引入的generic features带来的效果并不能泛化到测试集上。而依赖于Representation Learning的Deep Learning就不受上述限制，其用到的特征是在网络的各个layer中自动学习的。Good features can be learned automatically using a general-purpose learning procedure.(This is a key advantage of deep learning). 所以说，很多DL方法本质上就是做了自动化特征提取的工作： The hidden layers can be seen as distorting the input in a non-linear way so that categories become linearly separable by the last layer.</p>
<p>论文中对Representation Learning和Deep Learning给出了大致定义：</p>
<p><strong>Representation Learning</strong> is a set of methods that allows a machine to be fed with raw data and automatically discover the representations needed for detection or classification.</p>
<p><strong>Deep Learning</strong> methods are representation-learning methods with multiple levels of representation, obtained by composing simple but non-linear modules that each transform the representation at one level(starting with raw input) into a representation at a higher, slightly more abstract level.</p>
<p>论文后面大概讲了下CNN和RNN，CNN中对convolutional layer和pooling layer的讲解很好：The role of the convolutional layer is to detect local conjunctions of features from the previous layer; the role of the pooling  layer is merge semantically similar features into one.</p>
<p>最后是关于unsupervised learning的两个比较感兴趣的地方。For smaller data sets, unsupervised pre-training helps to prevent overfitting, leading to significantly better generalization when the number of labelled examples is small, or in a transfer setting where we have lots of examples for some ‘source’ tasks but very few for some ‘target’ tasks. (给出了参考文献，后面打算看一下)。另外就是文末的一句：Human and animal learning is largely unsupervised: we discover the structure of the world by observing it, not by being told the name of every object.</p>
</blockquote>
<h2 id="Attention">Attention</h2>
<p>在肝<a href="https://bcourses.berkeley.edu/courses/1487769">Designing, Visualizing and Understanding Deep Neural Networks (Spring 2020)</a>的时候，对Attention的理解总是比较肤浅，所以找来几篇论文读了一下.</p>
<p>此外有以下几个比较好的Blog:<a href="https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html">Attention? Attention!</a>, <a href="https://towardsdatascience.com/visual-attention-model-in-deep-learning-708813c2912c">Visual Attention Model in Deep Learning</a>.</p>
<ul>
<li>Sawant, Shriraj P., and Shruti Singh. “Understanding attention: in minds and machines.” <em>arXiv preprint arXiv:2012.02659</em> (2020).[<a href="https://arxiv.org/pdf/2012.02659.pdf">pdf</a>]</li>
</ul>
<blockquote>
<p>随便找的一篇最近的关于Attention review的文章.</p>
<p>文章整体可以大概分为两个部分： Attention in Artificial Neural Networks, Attention in Neuroscience。因为这里关注的是DL, 阅读的重点放在Attention in ANN部分。(以下提及Attention,若不做说明则全部认为是Attention in ANN)</p>
<p>文章首先给出Attention的起源， Attention mechanism in artificial neural networks was <strong>first proposed</strong> for the task of Machine Translation by <a href="https://arxiv.org/pdf/1409.0473.pdf">Bahdanau et al</a>，也就是NMT领域。因为<a href="https://arxiv.org/pdf/1409.0473.pdf">Bahdanau et al</a>的工作是依赖于<a href="https://arxiv.org/pdf/1406.1078.pdf">Learning phrase representations using rnn encoder-decoderfor statistical machine translation</a>的，所以文章先介绍了后者，之后结合<a href="https://arxiv.org/pdf/1409.0473.pdf">Bahdanau et al</a>介绍了Basic Attention Mechanism.(这里就不展开了，详见后面对这篇论文的简评)</p>
<p>之后介绍了几个Attention Variants</p>
<ul>
<li>Soft vs Hard Attention:最先在Image Captions任务中被提出. In Soft Attention, the alignment weights are placed all over the source image. On the other hand, Hard Attention selects one patch of the image to attend to at a time.</li>
<li>Local vs Global Attention: 最先在Machine Translation任务中提出.Global Attention与Soft Attention类似，consider all hidden states of the encoder when deriving the context. Local Attention focus on small context window.</li>
<li>Self Attention: Self Attention is the mechanism to capture different relations between words at different positions in the same sequence.</li>
<li>Hierachical Attention: To take into account the hierarchical nature of the data.</li>
</ul>
</blockquote>
<ul>
<li>Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. “Neural machine translation by jointly learning to align and translate.” <em>arXiv preprint arXiv:1409.0473</em> (2014).[<a href="https://arxiv.org/pdf/1409.0473.pdf">pdf</a>]</li>
</ul>
<blockquote>
<p>最早提出Attention in ANN的文章。</p>
<p>本文首先介绍了什么是Neural machine translation(NMT): attemps to build and train a single, large neural network that reads a sentence and outputs a correct translation.</p>
<p>之后指出当时现有的NMT model大多属于encoder-decoder类型的网络: An encoder neural network reads and encodes a source sentence into a fixed-length vector. A decoder then outputs a translation from the encoded vector.在这种框架下， A neural network needs to be able to compress all necessary information of a source sentence into a fixed-length vector.那么就有一个潜在的问题，在source sentence 过长的时候，这里得到的fixed-length vector不足以表达全部的信息，所以后面基于此vector的翻译任务将很难有好的表现，如下图所示(图片来自<a href="https://arxiv.org/pdf/1406.1078.pdf">Learning phrase representations using rnn encoder-decoderfor statistical machine translation</a>)</p>
<p><img src="https://i.loli.net/2021/02/24/SDztCQbhuq34FYc.png" alt="image-20210224180320025"></p>
<p>在<code>T</code>较大的时候，<code>C</code>很难将全部的信息综合起来，损失了较多的信息，所以使得Decoder很难有好的表现。</p>
<p>接着就是文章提出方法的具体描述了。The <strong>most important distinguishing feature</strong> of this approach from the basic encoder–decoder is thatit does not attempt to encode a whole input sentence into a single fixed-length vector. Instead, it <strong>en-codes the input sentence into a sequence of vectors and chooses a subset of these vectors adaptively while decoding the translation</strong>.  This <strong>frees</strong> a neural translation model from having to squash all theinformation of a source sentence, regardless of its length, into a fixed-length vector.</p>
<p><img src="https://i.loli.net/2021/02/24/2J1d9zXWIp8rht5.png" alt="image-20210224181041682"></p>
<p>上图(来自本文)进一步地补充了上面的解释。这里的Encoder是一个双向RNN, Decode仍然是一个RNN。不同的是，我们不再将source sentence的全部信息强行压缩到一个fixed-length vector, 而是加上了一个alignment model，其在每次预测$y_t$的时候都会汇总来自Encoder隐藏层的信息(annotations, 双向RNN拼接而成)作为输入。</p>
<p>接下来解释了为什么这样方法是有效的：<strong>Intuitively,this implements a mechanism of attention in the decoder.</strong>  The decoder decides parts of the sourcesentence to pay attention to.  <strong>By letting the decoder have an attention mechanism, we relieve theencoder from the burden of having to encode all information in the source sentence into a fixed-length vector.</strong>  With this new approach the information can be spread throughout the sequence ofannotations, which can be selectively retrieved by the decoder accordingly.</p>
<p>关于alignment model的实现: We parametrize the alignment modelaas a feedforward neural network which is jointly trained withall the other components of the proposed system.</p>
<p>综上可知，这里的Attention就是说在预测的时候持续“关注”source sentence(输入)以获得更好的预测，而完成这个“关注”任务的，协调“关注”工作的任务就交给了Attention Mechanism的实现，如这里的alignment model.</p>
<p>算法的PyTorch实现: <a href="https://github.com/pcyin/pytorch_basic_nmt">https://github.com/pcyin/pytorch_basic_nmt</a>.</p>
</blockquote>
<ul>
<li>Recurrent Models of Visual Attention[<a href="https://arxiv.org/pdf/1406.6247.pdf">pdf</a>]</li>
</ul>
<blockquote>
<p>Google DeepMind的一篇文章。</p>
<p><strong>What</strong>: a novel framework for attention-basedtask-driven visual processing with neural networks.</p>
<p><strong>How</strong>(to train): This procedure uses <strong>backpropagation</strong> to train the neural-network components and <strong>policy gradient</strong> to address the non-differentiabilities due to the control problem.</p>
<p>关于Recurrent Attention Model(RAM)的提出:In this paper we consider the attention problem as the sequential decision process of a goal-directedagent interacting with a visual environment.</p>
<img src="https://i.loli.net/2021/02/24/S3z49M7tPcwxJIY.png" alt="image-20210224183711691" style="zoom:120%;" />
<p>框架的主体就是一个RNN，有两点需要关注。第一，每个时间$t$的输入是<code>g</code>(Glimpse Network的输出); 第二每个hidden neural cell的状态$h_t$别被传入两个网络： 传入Action Network $f_a(:, \theta_a)$输出action or classification $a_t$, 传入Location Network$f_l(:, \theta_l)$输出下一个聚焦中心的位置$l_t$</p>
<p>具体训练来说，总体还是用BP通过SGD来优化参数，不过没有看懂这里通过增强学习来学习policy的过程。</p>
<p>算法的PyTorch实现: <a href="https://github.com/kevinzakka/recurrent-visual-attention">https://github.com/kevinzakka/recurrent-visual-attention</a></p>
</blockquote>
<h1>Emmmm</h1>
<p>不知道具体什么原因，以前一直对DL喜欢不起来，所以也就随便看看，没有系统地去学。现在看来，主要的原因还是在于没有好的引导资料，像Berkley的DL课程，李沐的《深度学习》，我怎么看不下去…</p>
<p>转折点是在一本书，Michael Nielson的<a href="http://neuralnetworksanddeeplearning.com/"><em>Neural Network and Deep Learning</em> </a>。初读这本书时，直接被震撼到了，明白了何谓高屋建瓴。</p>
<blockquote>
<p>You need to understand the durable, lasting insights underlying how neural networks work. Technologies come and technologies go, but insight is forever.</p>
</blockquote>
<p>所以我强烈推荐将这本书作为学习DL的开端。</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Doubly Linked Lists</title>
    <url>/2017/04/25/Doubly-Linked-Lists/</url>
    <content><![CDATA[<h5 id="初识">初识</h5>
<p>双向链表原理和单链表时一样的，也是由节点组成，每个节点包含要存储的数据信息和前后节点[单链表只有后面节点的信息]的位置信息，这些节点串连，形成一个链表。</p>
<h5 id="实现">实现</h5>
<h6 id="doublyLLst-h">doublyLLst.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-25.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_DOUBLYLLST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_DOUBLYLLST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;</span><br><span class="line">    Node* next, *prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>()&#123;</span><br><span class="line">        next = prev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; el ,Node* n = <span class="number">0</span>, Node* p = <span class="number">0</span>)&#123;</span><br><span class="line">        info = el; next = n; prev = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Node&lt;T&gt; *head, *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DoublyLinkedList</span>()&#123;</span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToDLLTail</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToDLLHead</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deleteFromDLLTail</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">deleteFromDLLHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNodeFromEl</span><span class="params">(T el)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNodeFromPs</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToDLList</span><span class="params">(<span class="type">const</span> T&amp; el, <span class="type">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInList</span><span class="params">(T el)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedLists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">addToDLLTail</span>(<span class="type">const</span> T &amp;el ) &#123;</span><br><span class="line">    <span class="keyword">if</span>(tail != <span class="number">0</span>)&#123;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(el, <span class="number">0</span>, tail);</span><br><span class="line">        tail-&gt;prev-&gt;next = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> head = tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">addToDLLHead</span>(<span class="type">const</span> T &amp;el ) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="number">0</span>)&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(el, head, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> head = tail = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T DoublyLinkedList&lt;T&gt;::<span class="built_in">deleteFromDLLHead</span>() &#123;</span><br><span class="line">    T el = head-&gt;info;</span><br><span class="line">    <span class="keyword">if</span>(head == tail)&#123; <span class="comment">// if only one node in the list</span></span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = tail =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// if more than one node in the list</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">// 先将head后移</span></span><br><span class="line">        <span class="keyword">delete</span> head-&gt;prev;  <span class="comment">// 删除旧head</span></span><br><span class="line">        head-&gt;prev = <span class="number">0</span>;  <span class="comment">// 新head&#x27;s prev 设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T DoublyLinkedList&lt;T&gt;::<span class="built_in">deleteFromDLLTail</span>() &#123;</span><br><span class="line">    T el = tail-&gt;info;</span><br><span class="line">    <span class="keyword">if</span>(head == tail)&#123; <span class="comment">// if only one node in the list</span></span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = tail =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// if more than one node in the list</span></span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        <span class="keyword">delete</span> tail-&gt;next;</span><br><span class="line">        tail-&gt;next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">deleteNodeFromEl</span>(T el) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(el == head-&gt;info &amp;&amp; head==tail)&#123;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(el == head-&gt;info)&#123;</span><br><span class="line">            <span class="built_in">deleteFromDLLHead</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node&lt;T&gt;* tmp, *pred;</span><br><span class="line">            <span class="keyword">for</span>(pred = head, tmp = head-&gt;next; tmp!=<span class="number">0</span> &amp;&amp; !(tmp-&gt;info == el);</span><br><span class="line">                pred = pred-&gt;next, tmp = tmp-&gt;next);  <span class="comment">// and a non-head node is deleted</span></span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="number">0</span>)&#123;</span><br><span class="line">                pred-&gt;next =tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next-&gt;prev = pred;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">deleteNodeFromPs</span>(<span class="type">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">deleteFromDLLHead</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">deleteFromDLLTail</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;T&gt; *tmp = head-&gt;next;</span><br><span class="line">        Node&lt;T&gt; *pred = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; pos - <span class="number">2</span>;</span><br><span class="line">            i++, pred = pred-&gt;next, tmp = tmp-&gt;next);</span><br><span class="line"></span><br><span class="line">        pred-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;next != <span class="number">0</span>)  <span class="comment">// 如果删除的不是最后一个节点，那么要与前面的节点连接[只在双向链表有]</span></span><br><span class="line">            tmp-&gt;next-&gt;prev = pred;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">addToDLList</span>(<span class="type">const</span> T&amp;el, <span class="type">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">addToDLLHead</span>(el);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">addToDLLTail</span>(el);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node&lt;T&gt; *tmp = head-&gt;next;</span><br><span class="line">        Node&lt;T&gt; *pred = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; pos - <span class="number">2</span>;</span><br><span class="line">            i++, pred = pred-&gt;next, tmp = tmp-&gt;next);</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* psNode = <span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(el, tmp, pred);</span><br><span class="line">        tmp-&gt;prev = psNode;</span><br><span class="line">        pred-&gt;next = psNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">isInList</span>(T el) &#123;</span><br><span class="line">    Node&lt;T&gt;* tmp;</span><br><span class="line">    <span class="keyword">for</span>(tmp=head; tmp != <span class="number">0</span> &amp;&amp; el != tmp-&gt;info; tmp = tmp-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> tmp != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// print the singly linked lists</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">printLinkedLists</span>()&#123;</span><br><span class="line">    Node&lt;T&gt;* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;info);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_DOUBLYLLST_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-5">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;doublyLLst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    DoublyLinkedList&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    list.<span class="built_in">addToDLLTail</span>(<span class="number">11</span>);</span><br><span class="line">    list.<span class="built_in">addToDLLTail</span>(<span class="number">12</span>);</span><br><span class="line">    list.<span class="built_in">addToDLLTail</span>(<span class="number">13</span>);</span><br><span class="line">    list.<span class="built_in">addToDLLHead</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">deleteFromDLLHead</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after the deleting from head...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after the deleting from el:12...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">deleteNodeFromEl</span>(<span class="number">12</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after the deleting from ps:2...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">deleteNodeFromPs</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after the adding from ps:1...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">addToDLList</span>(<span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isin = list.<span class="built_in">isInList</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Is 6 in list? The answer is: &quot;</span>&lt;&lt;isin&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<blockquote>
<p>10<br>
11<br>
12<br>
13<br>
after the deleting from head…<br>
11<br>
12<br>
13<br>
after the deleting from el:12…<br>
11<br>
13<br>
after the deleting from ps:2…<br>
11<br>
after the adding from ps:1…<br>
6<br>
11<br>
Is 6 in list? The answer is: 1</p>
</blockquote>
<h6 id="注意">注意</h6>
<p>此处用到模板，其声明的函数一般要在当前的头文件进行定义。当然，非要分到对应的cpp文件[例如doublyLLst.cpp]也行，只不过，这时候调用这些函数的话，要在main.cpp上面添加一句<code>include &quot;doublyLLst.cpp&quot;</code>。</p>
<h5 id="参考-3">参考</h5>
<p><em><a href="http://stackoverflow.com/questions/13216844/undefined-reference-to-linkedlistintpush-frontint">stackoverflow</a></em><br>
<em>Data Structures and Algorithms in C++</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Exploratory Data Analysis with R读书笔记</title>
    <url>/2017/10/06/EDA-with-R/</url>
    <content><![CDATA[<h3 id="启程">启程</h3>
<p>这学期开了EDA的课程，课本没用结合程序来进行，所以这里主要依照<em>Exploratory Data Analysis with R</em>这本书来进行EDA编程方面的学习。国庆这两天多花了点时间看完了，这里简单写下笔记。（这书的pdf可以在<a href="https://bookdown.org/rdpeng/exdata/">这里</a>看）</p>
<blockquote>
<p>ps:大一的时候学R看的是<em>The R Book</em>，但是看到概率论知识那里就放下了，后来也跑去学Python了orz…这里也当做重新来学R吧。</p>
</blockquote>
<p>书上首先介绍了dplyr的使用方法，十分好用（感觉和pandas好像…）。为了加深记忆，用Rmarkdown写了个笔记，发布在<a href="http://rpubs.com/shenxiangzhuang/mdplyr">rpubs</a>。再到后面主要介绍了EDA的过程和可视化的方法，对ggplot2的介绍间接明了，十分实用。最后还给出了具体的案例分析，结合的很好！</p>
<p>总之，这本书还是比较好的，可以学习EDA的方法，同时还可以作为一个简洁的handbook来备查。<br>
接下来，R的学习就已<em>R in Action</em>为主了，同时，非参数课本上的R程序也打算一直跟下去。</p>
<h3 id="后续">后续</h3>
<p>强迫症发作。。。因为一直在用R跟进<a href="https://github.com/shenxiangzhuang/StatisticalMethods-Course-WIth-R">统计预测与决策</a>，<a href="https://github.com/shenxiangzhuang/NonparameterStat-Course-WIth-R">非参数统计</a>的课程，所以对现在的EDA课程也想着用R挨着来实现一下，虽说要写代码的地方不多…承接着上面的EDA WITH R那本书，发现<a href="http://mgimond.github.io/ES218/">这里</a> 有更为详细的讲解。所以就参考这个，对教材<em>Understanding Robust And Exploratory Data Analysis</em>进行跟进。</p>
<p>项目地址：[Github]（<a href="https://github.com/shenxiangzhuang/EDA-Course-WIth-R%EF%BC%89">https://github.com/shenxiangzhuang/EDA-Course-WIth-R）</a></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>EDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Errata of PythonDA</title>
    <url>/2018/07/30/Errata-of-PythonDA/</url>
    <content><![CDATA[<p>《Python数据分析入门————从数据获取到可视化》勘误页</p>
<p>感谢各位读者提交的勘误，本页将持续更新。</p>
<h3 id="已更正">已更正</h3>
<table>
<thead>
<tr>
<th>页码</th>
<th>错误</th>
<th>改正</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>上方第一个阴影框（训练集数据）“种类”列最后两行将“bumpy”全改为“orange”</td>
<td>第一版第一次印刷存在的错误，第二次印刷时更正</td>
</tr>
<tr>
<td>202</td>
<td>第三行，“是橙子还是水果”改为“是橙子还是苹果”</td>
<td>第一版第一次印刷存在的错误，第二次印刷时更正</td>
</tr>
<tr>
<td>99</td>
<td>代码框最后两行交换位置（因为多线程会把<code>urls</code>清空）</td>
<td>第六次印刷时更正</td>
</tr>
<tr>
<td>115</td>
<td>正文第三行“运行输出如下。”下面的输出有误，下面的数据需要我们自己手动创建</td>
<td>第六次印刷时更正</td>
</tr>
<tr>
<td>245</td>
<td>代码框，最上面应加上<code>import random as rnd</code></td>
<td>第六次印刷时更正</td>
</tr>
<tr>
<td>247,248</td>
<td>两个LP问题的目标函数漏掉，改正参考<a href="http://datahonor.com/2017/03/22/%E5%88%A9%E7%94%A8Python%E8%A7%A3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-LP/">博客</a>。</td>
<td>第六次印刷时更正</td>
</tr>
<tr>
<td>71-73</td>
<td>豆瓣模拟登录报错</td>
<td>第六次印刷时更正</td>
</tr>
</tbody>
</table>
<h3 id="待更正">待更正</h3>
<table>
<thead>
<tr>
<th>页码</th>
<th>错误</th>
<th>改正</th>
</tr>
</thead>
</table>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>Eviews 安装</title>
    <url>/2017/10/14/Eviews-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h4 id="Windows">Windows</h4>
<p>关于Eviews9（windows）的安装。</p>
<p><strong>安装文件链接</strong>：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1eSEjcx8">https://pan.baidu.com/s/1eSEjcx8</a> 密码: 248h</p>
</blockquote>
<p>里面有32Bit和64Bit的安装文件。</p>
<p>**<br>
安装过程**</p>
<p>可以参考crack文件夹下的README文件。就是，前面的安装一直默认即可。<br>
等到出现Serial Number的时候，上面输入<code>Demo</code>即可（可能不是必须的，不过最后还是写上这个），下面的是程序自动检测到的你的计算机用户名，不用管。如下：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201710/IMG_20171014_150731.jpg" alt=""></p>
<p>之后再一路默认即可，无非就是选择下安装的路径这些。直到出现下面这个，询问是否检查更新，禁止即可。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201710/IMG_20171014_150807.jpg" alt=""></p>
<p>最后再一路默认到最后即可。完成安装后，桌面会出现Eviews的快捷方式。注意这时候直接运行是不可以的，因为还没有激活。只需要找到从百度云下载的文件中，crack文件夹下的Patch文件，运行，点击左侧patch,等待补丁打好退出即可， 如图。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201710/IMG_20171014_151206.jpg" alt=""></p>
<p>这时候再运行桌面的快捷方式就可以了。</p>
<h4 id="Mac">Mac</h4>
<p>对于Mac的安装，可以到Eviews官网下载Students Version, 目前版本应该是9.5的。只需要填一些信息就可以了。测试的时候用的学校的教育网邮箱是可以的。也可以用自己的其他邮箱试下，不行再去校内门户的邮件系统申请一个教育网邮箱进行申请。</p>
<p>嗯…还是支持正版好些orz…</p>
<h4 id="Student-Version-补充">Student Version 补充</h4>
<p>有些同学说破解文件报毒…我这没有360没报orz…用win10自带的杀毒软件扫了下，是安全的，所以这个一般不用担心。不过还是有的补丁程序没法运行，所以，可以用老师的那个老点的版本，也可以用Student Version（9.5版的，算是最新了，而且Win,Mac都有，而且还免费，力荐啊orz…。）。刚把上面的那个卸了，试了下学生版，很简单几步就可以了。</p>
<h5 id="准备：邮箱">准备：邮箱</h5>
<blockquote></blockquote>
<p>前面说了，测试用的学校的教育网邮箱，是可以的。可以先用自己的其他邮箱试下，不行再去<a href="http://hd2.hainu.edu.cn/homeN/">校内门户</a>申请一个。登录进去校内门户，右侧第一个就是邮件系统，进去申请就可以了。</p>
<h5 id="填写注册信息">填写注册信息</h5>
<p>首先到<a href="http://www.eviews.com/EViews9/EViews9SV/evstud9.html">这里</a>,看到下面的<code>Free Download</code>,点进去，来到<a href="http://register1.eviews.com/Lite/">注册页面</a>,这里填写好相关的信息即可。</p>
<h5 id="查收邮件">查收邮件</h5>
<p>填好后会很快收到邮件（如果收不到的话可能就是自己的邮箱不行，就需要按照前面那样申请教育邮箱了）。邮件会给出下载的<a href="http://www.eviews.com/download/student9/">链接</a>(Win和Mac都有)，以及序列号。</p>
<h5 id="安装激活">安装激活</h5>
<p>文件下载好直接默认安装就可以，当中不会提示输入序列号。安装好运行，会出现注册的提示，输入邮件的序列号即可（下面的用户名一样可以随便填）。激活后会有注册成功的提示。</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二十三：Extracting Lines, Contours, and Components</title>
    <url>/2017/05/27/Extracting-Lines-Contours-and-Components/</url>
    <content><![CDATA[<h4 id="Overview-14">Overview</h4>
<p>我们这里介绍怎样从图像中抽取一些有用的特征来进行图像的分析。</p>
<blockquote>
<p>In order to perform content-based analysis of an image, it is necessary to<br>
extract meaningful features from the collection of pixels that constitute<br>
the image.</p>
</blockquote>
<h4 id="Code-12">Code</h4>
<h5 id="Find-contours-by-Canny-operator">Find contours by Canny operator</h5>
<p>之前，我们也简单介绍了基于梯度的图像的边缘检测，但是有两个缺点：第一是边缘有些厚，第二用于分割的阀值很难找到。所以我们这里介绍Canny算子。</p>
<p>原理部分，参考<a href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html">文档</a>,写的很精彩。主要就是Non-maximum suppression和Hysteresis threshold的理解。</p>
<p>一个简单的demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/road.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Original Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply Canny algorithm</span></span><br><span class="line">    cv::Mat contours;</span><br><span class="line">    cv::<span class="built_in">Canny</span>(image, contours, <span class="number">125</span>, <span class="number">350</span>);  <span class="comment">// contours &#123;0,255&#125;,边缘为255</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Canny Image&quot;</span>);</span><br><span class="line">    <span class="comment">// 为了便于观察，取反色</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Canny Image&quot;</span>, <span class="number">255</span>-contours);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052701.png" alt=""></p>
<p>除此之外，我们也可以通过pyrUp去除一些细节再进行边缘检测，效果会更好些。参考<a href="http://datahonor.com/2017/02/23/OpenCV-Pyramid-and-Canny/">这里</a></p>
<h5 id="Detecting-lines-in-images-with-the-Hough-transform">Detecting lines in images with the Hough transform</h5>
<p>关于霍夫变换的简单的demo，可以看下<a href="http://datahonor.com/2017/05/28/Hough%E5%8F%98%E6%8D%A2/">这里</a>. 这里，我们使用其进行检测图像中的直线。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/road.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply Canny algotithm</span></span><br><span class="line">    cv::Mat contours;</span><br><span class="line">    cv::<span class="built_in">Canny</span>(image, contours, <span class="number">125</span>, <span class="number">350</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Contours&quot;</span>, contours);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hough transfrom for line detection</span></span><br><span class="line">    std::vector&lt;cv::Vec2f&gt;lines;</span><br><span class="line">    cv::<span class="built_in">HoughLines</span>(contours, lines, <span class="number">1</span>, PI/<span class="number">180</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Vec2f&gt;::const_iterator it = lines.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != lines.<span class="built_in">end</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> rho = (*it)[<span class="number">0</span>];  <span class="comment">// first element is distance rho</span></span><br><span class="line">        <span class="type">float</span> theta = (*it)[<span class="number">1</span>];  <span class="comment">// second element is angle theta</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(theta &lt; PI/<span class="number">4.</span> || theta &gt; <span class="number">3.</span>*PI/<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">// vertical line</span></span><br><span class="line">            <span class="comment">// point of intersection of the line with first row</span></span><br><span class="line">            <span class="function">cv::Point <span class="title">pt1</span><span class="params">(rho/cos(theta), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// point of intersection of the line with last row</span></span><br><span class="line">            <span class="function">cv::Point <span class="title">pt2</span><span class="params">((rho-image.rows*sin(theta))/cos(theta), image.rows)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// draw white line</span></span><br><span class="line">            cv::<span class="built_in">line</span>(image, pt1, pt2, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>), <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// horizontal line</span></span><br><span class="line">            <span class="comment">// point of intersection of the line with first column</span></span><br><span class="line">            cv::Point <span class="built_in">pt1</span>(<span class="number">0</span>, rho/<span class="built_in">sin</span>(theta));</span><br><span class="line">            <span class="comment">// point of intersection of the line with last column</span></span><br><span class="line">            <span class="function">cv::Point <span class="title">pt2</span><span class="params">(image.cols, (rho-image.cols*cos(theta))/sin(theta))</span></span>;</span><br><span class="line">            <span class="comment">// draw white line</span></span><br><span class="line">            cv::<span class="built_in">line</span>(image, pt1, pt2, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052804.png" alt=""></p>
<p>同样地，只要可以将图像中的形状转化到参数空间，我们都可以用hough变换进行检测，比如圆形的检测：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/chariot.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Detecting circles</span></span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(image, image, cv::<span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">1.5</span>);</span><br><span class="line">    std::vector&lt;cv::Vec3f&gt;circles;</span><br><span class="line">    cv::<span class="built_in">HoughCircles</span>(image, circles, cv::HOUGH_GRADIENT,</span><br><span class="line">                    <span class="number">2</span>, <span class="comment">// accumulator resolution(size of the image/2)</span></span><br><span class="line">                    <span class="number">20</span>, <span class="comment">// minimum distance between two circles</span></span><br><span class="line">                    <span class="number">200</span>, <span class="comment">// Canny high threshold</span></span><br><span class="line">                    <span class="number">60</span>, <span class="comment">// minimum number of vates</span></span><br><span class="line">                    <span class="number">15</span>,</span><br><span class="line">                    <span class="number">50</span>);  <span class="comment">// min and max radius</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::Vec3f&gt;::const_iterator itc = circles.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(itc!=circles.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cv::<span class="built_in">circle</span>(image, cv::<span class="built_in">Point</span>((*itc)[<span class="number">0</span>], (*itc)[<span class="number">1</span>]), (*itc)[<span class="number">2</span>], cv::<span class="built_in">Scalar</span>(<span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        ++itc;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Detected Circles&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Detected Circles&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:<br>
<img src="http://datahonor-1252464519.costj.myqcloud.com/201705/Detected%20Circles_052901.png" alt=""></p>
<p>基于上面的应用，我们来学习下关于Probabilistic Hough transform的应用：</p>
<blockquote>
<p>As can be seen, the Hough transform simply looks for an alignment of edge pixels across the image. This can potentially create some false detections due to incidental pixel alignments or multiple detections when several lines with slightly different parameter values pass through the same alignment of pixels.<br>
To overcome some of these problems, and to allow line segments to be detected (that is, with endpoints), a variant of the transform has been proposed. This is the Probabilistic Hough transform, and it is implemented in OpenCV as the cv::HoughLinesP function.</p>
</blockquote>
<p><strong>linefinder.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_LINEFINDER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_LINEFINDER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_LINEFINDER_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineFinder</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// orginal image</span></span><br><span class="line">    cv::Mat img;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector containing the endpoints of the detected lines</span></span><br><span class="line">    std::vector&lt;cv::Vec4i&gt;lines;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accumulator resolution parameters</span></span><br><span class="line">    <span class="type">double</span> deltaRHo;</span><br><span class="line">    <span class="type">double</span> deltaTheta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minimum number of votes that a line</span></span><br><span class="line">    <span class="comment">// must receive before being considered</span></span><br><span class="line">    <span class="type">int</span> minVote;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// min length for a line</span></span><br><span class="line">    <span class="type">double</span> minLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max allowed gap along the line</span></span><br><span class="line">    <span class="type">double</span> maxGap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default accumulator resolution is 1 pixel by 1 degree</span></span><br><span class="line">    <span class="comment">// no gap, no minimum length</span></span><br><span class="line">    <span class="built_in">LineFinder</span>():<span class="built_in">deltaRHo</span>(<span class="number">1</span>), <span class="built_in">deltaTheta</span>(PI/<span class="number">180</span>),</span><br><span class="line">                 <span class="built_in">minVote</span>(<span class="number">10</span>), <span class="built_in">minLength</span>(<span class="number">0.</span>), <span class="built_in">maxGap</span>(<span class="number">0.</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the resolution of the accumulator</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAccResolution</span><span class="params">(<span class="type">double</span> dRho, <span class="type">double</span> dTheta)</span></span>&#123;</span><br><span class="line">        deltaRHo = dRho;</span><br><span class="line">        deltaTheta = dTheta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the minimum member of votes</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMinVote</span><span class="params">(<span class="type">int</span> minv)</span></span>&#123;</span><br><span class="line">        minVote = minv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set line length and gap</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLineLengthAndGap</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> gap)</span></span>&#123;</span><br><span class="line">        minLength = length;</span><br><span class="line">        maxGap = gap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply probabilistic Hough Transform</span></span><br><span class="line">    std::vector&lt;cv::Vec4i&gt;<span class="built_in">findLines</span>(cv::Mat&amp;binary)&#123;</span><br><span class="line">        lines.<span class="built_in">clear</span>();</span><br><span class="line">        cv::<span class="built_in">HoughLinesP</span>(binary, lines, deltaRHo, deltaTheta, minVote,</span><br><span class="line">                        minLength, maxGap);</span><br><span class="line">        <span class="keyword">return</span> lines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw the detected lines on an image</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawDetectedLines</span><span class="params">(cv::Mat &amp;image, cv::Scalar color=cv::Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw lines</span></span><br><span class="line">        std::vector&lt;cv::Vec4i&gt;::const_iterator it2 = lines.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(it2!=lines.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="function">cv::Point <span class="title">pt1</span><span class="params">((*it2)[<span class="number">0</span>], (*it2)[<span class="number">1</span>])</span></span>;</span><br><span class="line">            <span class="function">cv::Point <span class="title">pt2</span><span class="params">((*it2)[<span class="number">2</span>], (*it2)[<span class="number">3</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">line</span>(image, pt1, pt2, color);</span><br><span class="line">            ++it2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line">#include &lt;opencv2/imgcodecs.hpp&gt;</span><br><span class="line">#include &lt;opencv/cv.hpp&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;linefinder.h&quot;</span><br><span class="line">#define PI 3.1415926</span><br><span class="line"></span><br><span class="line">using namespace std</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cv::Mat image = cv::imread(&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/road.jpg&quot;, 0);</span><br><span class="line">    cv::imshow(&quot;Original Image&quot;, image);</span><br><span class="line"></span><br><span class="line">    // Apply Canny algotithm</span><br><span class="line">    cv::Mat contours;</span><br><span class="line">    cv::Canny(image, contours, 125, 350);</span><br><span class="line">    cv::imshow(&quot;Contours&quot;, contours);</span><br><span class="line"></span><br><span class="line">        // Create LineFinder instance</span><br><span class="line">    LineFinder finder;</span><br><span class="line"></span><br><span class="line">    // Set probabilistic Hough parameters</span><br><span class="line">    finder.setLineLengthAndGap(100, 20);</span><br><span class="line">    finder.setMinVote(60);</span><br><span class="line"></span><br><span class="line">    // Detect lines and draw them in the image</span><br><span class="line">    std::vector&lt;cv::Vec4i&gt;lines = finder.findLines(contours);</span><br><span class="line">    finder.drawDetectedLines(image);</span><br><span class="line"></span><br><span class="line">    cv::namedWindow(&quot;Lines with HoughP&quot;);</span><br><span class="line">    cv::imshow(&quot;Lines with HoughP&quot;, image);</span><br><span class="line"></span><br><span class="line">    cv::waitKey();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://datahonor-1252464519.costj.myqcloud.com/201705/Selection_052902.png" alt=""></p>
<h5 id="Extracting-connected-components-Computing-components’-shape-descriptors">Extracting connected components &amp;&amp; Computing components’ shape descriptors</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eliminate too short or too long contours</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BalanceLength</span><span class="params">(std::vector&lt;std::vector&lt;cv::Point&gt;&gt;&amp; contours)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cmin = <span class="number">80</span>;  <span class="comment">// minimum contour length</span></span><br><span class="line">    <span class="type">int</span> cmax = <span class="number">500</span>;  <span class="comment">// maximum contours length</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt;::iterator itc = contours.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for all contours</span></span><br><span class="line">    <span class="keyword">while</span>( itc != contours.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// verify contour size</span></span><br><span class="line">        <span class="keyword">if</span>(itc-&gt;<span class="built_in">size</span>() &lt; cmin || itc-&gt;<span class="built_in">size</span>() &gt; cmax)</span><br><span class="line">            itc = contours.<span class="built_in">erase</span>(itc);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++itc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/marphimg.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// the vector that will contain the contours</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;</span><br><span class="line">    cv::<span class="built_in">findContours</span>(image,</span><br><span class="line">                    contours,   <span class="comment">// a vector og contours</span></span><br><span class="line">                    cv::RETR_EXTERNAL,  <span class="comment">//retieve the external contours</span></span><br><span class="line">                    cv::CHAIN_APPROX_NONE);  <span class="comment">// all pixels of each contours</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw black contours on a white image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">result</span><span class="params">(image.size(), CV_8U, cv::Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line">    cv::<span class="built_in">drawContours</span>(result, contours, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// draw all contours; in black; with a thickness of 2</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;result_before_elimination&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eliminate too short or too long contours</span></span><br><span class="line">    <span class="built_in">BalanceLength</span>(contours);</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">result1</span><span class="params">(image.size(), CV_8U, cv::Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line">    cv::<span class="built_in">drawContours</span>(result1, contours, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// draw all contours; in black; with a thickness of 2</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;result_after_elimination&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// testing the bounding box</span></span><br><span class="line">    cv::Rect r0 = cv::<span class="built_in">boundingRect</span>(contours[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// draw the rectangle</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(result1, r0, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;boundingbox&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// testing the enclosing circle</span></span><br><span class="line">    <span class="type">float</span> radius;</span><br><span class="line">    cv::Point2f center;</span><br><span class="line">    cv::<span class="built_in">minEnclosingCircle</span>(contours[<span class="number">1</span>],center,radius);</span><br><span class="line">    <span class="comment">// draw the cricle</span></span><br><span class="line">    cv::<span class="built_in">circle</span>(result1,center,<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(radius), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;enclosing&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// testing the approximate polygon</span></span><br><span class="line">    std::vector&lt;cv::Point&gt; poly;</span><br><span class="line">    cv::<span class="built_in">approxPolyDP</span>(contours[<span class="number">2</span>], poly, <span class="number">5</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// draw the polygon</span></span><br><span class="line">    cv::<span class="built_in">polylines</span>(result1, poly, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Poly&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// testing the convex hull</span></span><br><span class="line">    std::vector&lt;cv::Point&gt;hull;</span><br><span class="line">    cv::<span class="built_in">convexHull</span>(contours[<span class="number">3</span>], hull);</span><br><span class="line">    <span class="comment">// draw the polygon</span></span><br><span class="line">    cv::<span class="built_in">polylines</span>(result1, hull, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;convexhull&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// testing the moments</span></span><br><span class="line">    <span class="comment">// iterator over all contours</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt;::iterator itc = contours.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(itc!=contours.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// compute all moments</span></span><br><span class="line">        cv::Moments mom = cv::<span class="built_in">moments</span>(cv::<span class="built_in">Mat</span>(*itc++));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw mess center</span></span><br><span class="line">        cv::<span class="built_in">circle</span>(result1, cv::<span class="built_in">Point</span>(mom.m10/mom.m00, mom.m01/mom.m00),</span><br><span class="line">        <span class="number">2</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>), <span class="number">2</span>);  <span class="comment">// draw black dot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Moments&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// original color image of cattles</span></span><br><span class="line">    cv::Mat colorImage  = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;OriginalColorImage&quot;</span>, colorImage);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">drawContours</span>(colorImage, contours, <span class="number">-1</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">2</span>); <span class="comment">// draw all contours; in black; with a thickness of 2</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;colorImage&quot;</span>, colorImage);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201705/Selection_052903.png" alt=""></p>
<h5 id="Quadrilateral-detection">Quadrilateral detection</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat components = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/mser.bmp&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Raw Image&quot;</span>, components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary</span></span><br><span class="line">    components = components == <span class="number">255</span>;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Binary&quot;</span>, components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open the image (white background)</span></span><br><span class="line">    <span class="comment">// clean the image with a morphological filter</span></span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(components,components,</span><br><span class="line">                    cv::MORPH_OPEN, cv::<span class="built_in">Mat</span>(),</span><br><span class="line">                    cv::<span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;After bin-morph&quot;</span>, components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invert image (background must be black)</span></span><br><span class="line">    cv::Mat componentsInv = <span class="number">255</span> - components;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the contours of the connected components</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;</span><br><span class="line">    cv::<span class="built_in">findContours</span>(componentsInv, contours, cv::RETR_EXTERNAL,</span><br><span class="line">                    cv::CHAIN_APPROX_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// white image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">quadri</span><span class="params">(components.size(), CV_8U, <span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for all contours</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt;::iterator it = contours.<span class="built_in">begin</span>();</span><br><span class="line">    std::vector&lt;cv::Point&gt; poly;</span><br><span class="line">    <span class="keyword">while</span> (it != contours.<span class="built_in">end</span>())&#123;</span><br><span class="line">        poly.<span class="built_in">clear</span>();</span><br><span class="line">        cv::<span class="built_in">approxPolyDP</span>(*it, poly, <span class="number">5</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do we have a quadrilateral?</span></span><br><span class="line">        <span class="keyword">if</span>(poly.<span class="built_in">size</span>() == <span class="number">4</span>)  <span class="comment">//draw it</span></span><br><span class="line">            cv::<span class="built_in">polylines</span>(quadri, poly, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Quadri&quot;</span>, quadri);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201705/Selection_052904.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Get help in R</title>
    <url>/2017/10/10/Get-help-in-R/</url>
    <content><![CDATA[<h4 id="Overview-15">Overview</h4>
<p>之前一段时间开始看<em>R in Action</em>， 感觉写的特别好，尤其是一开始对R的帮助文档的使用和基本数据类型的概括，这里做下记录以备忘。首先是多种获取帮助的方式。</p>
<h4 id="Code-13">Code</h4>
<h5 id="demo">demo</h5>
<p>书中介绍的第一个TIP就是关于demo的：</p>
<blockquote>
<p>To get a sense of what R can do graphically, enter demo()at the command prompt. A sample of the graphs produced is included in figure 1.5. Other demonstrations include demo(Hershey), demo(persp), and demo(image). To see a complete list of demonstrations, enter demo() without parameters.</p>
</blockquote>
<p>demo直接给出简洁的代码示例来解释如何使用相关的功能，可以说是十分有帮助的。这里拓展一下：</p>
<ul>
<li>[ ] demo()</li>
</ul>
<blockquote>
<p>直接<code>demo()</code>的话，会返回<code>Demos in package ‘base’:</code>, 也就是base库包含的一些demo。</p>
</blockquote>
<ul>
<li>[ ] demo(package = .packages(all.available = TRUE))</li>
</ul>
<blockquote>
<p>通过这条命令，我们可以列出已经安装的包中，所有可用的demo</p>
</blockquote>
<ul>
<li>[ ] demo(“zoo-overplot”, package = “zoo”)</li>
</ul>
<blockquote>
<p><code>a character vector giving the packages to look into for demos, or NULL. By default, all packages in the search path are used.</code> 这里，我们可以通过指定package的值来搜索指定包下的demo。如果不指定，则在所有已导入的包中搜索。</p>
</blockquote>
<h5 id="help-functions">help functions</h5>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201710/Screenshot%20from%202017-10-10%2012-00-03.png" alt=""></p>
<blockquote>
<p>The vignettes returned by the vignette() function are practical introductory articles provided in PDF format. Not all packages have vignettes</p>
</blockquote>
<p>这里的vignettes值得去注意，因为这些包的官方提供的文档，是我们学习包的使用最有效的方法。</p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令积累</title>
    <url>/2018/02/06/Git%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h4 id="Overview-16">Overview</h4>
<p>记录一些常用的Git命令。</p>
<h4 id="Code-14">Code</h4>
<h5 id="Adding-an-existing-project-to-GitHub">Adding an existing project to GitHub</h5>
<p>将本地文件同步到Github，参考<a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/">这里</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HOG+SVM&amp;Pedestrian Detection</title>
    <url>/2017/08/17/HOG-SVM-Pedestrian-Detection/</url>
    <content><![CDATA[<h4 id="Overview-17">Overview</h4>
<p>用了大概几个月的时间看完了<em>OpenCV 3 Computer Vision Application Programming Cookbook - Third Edition</em>， 也对前7章的基本操作部分在小站上进行了相应的总结。这里是最后一章实战的DEMO部分的代码，算作对本书学习的一个结尾吧。前面也看了几本相关的书，不过都和这本书差远了，无论理论和算法的讲解还是代码的水平都堪称一流，真心推荐~</p>
<h4 id="Code-15">Code</h4>
<h5 id="关于HOG的可视化">关于HOG的可视化</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/ml.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// draw one HOG over one cell</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawHOG</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt;::const_iterator hog, <span class="comment">// iterator to the HOG</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> numberOfBins,  <span class="comment">// number of bins inHOG</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cv::Mat &amp; image,  <span class="comment">// image of the cell</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span> scale = <span class="number">1.0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.1415927</span>;</span><br><span class="line">    <span class="type">float</span> binStep = PI/numberOfBins;</span><br><span class="line">    <span class="type">float</span> maxLength = image.rows;</span><br><span class="line">    <span class="type">float</span> cx = image.cols/<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> cy = image.rows/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each bin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> bin=<span class="number">0</span>; bin&lt;numberOfBins; bin++)&#123;</span><br><span class="line">        <span class="comment">// bin orientation</span></span><br><span class="line">        <span class="type">float</span> angle = bin*binStep;</span><br><span class="line">        <span class="type">float</span> dirX = <span class="built_in">cos</span>(angle);</span><br><span class="line">        <span class="type">float</span> dirY = <span class="built_in">sin</span>(angle);</span><br><span class="line">        <span class="comment">// length of line proportion to bin size</span></span><br><span class="line">        <span class="comment">// 这里感觉是为了可视化的时候区分不同的bin,不是很明白...</span></span><br><span class="line">        <span class="type">float</span> length = <span class="number">0.5</span>*maxLength**(hog+bin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// drawing the line</span></span><br><span class="line">        <span class="type">float</span> x1 = cx - dirX * length * scale;</span><br><span class="line">        <span class="type">float</span> y1 = cy - dirY * length * scale;</span><br><span class="line">        <span class="type">float</span> x2 = cx + dirX * length * scale;</span><br><span class="line">        <span class="type">float</span> y2 = cy + dirY * length * scale;</span><br><span class="line">        cv::<span class="built_in">line</span>(image, cv::<span class="built_in">Point</span>(x1, y1), cv::<span class="built_in">Point</span>(x2, y2),</span><br><span class="line">        <span class="built_in">CV_RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw HOG over an image</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawHOGDescriptors</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image, <span class="comment">// the input image</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Mat &amp;hogImage, <span class="comment">// the resulting hog image</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cv::Size cellSize,  <span class="comment">// size of each cell</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> nBins</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>&#123;</span><br><span class="line">    <span class="comment">// block size is image size</span></span><br><span class="line">    <span class="comment">// image.cols = 391</span></span><br><span class="line">    <span class="comment">// (image.cols/cellSize.width)*cellSize.width = 384</span></span><br><span class="line">    <span class="comment">// 下面这里先除后乘，是为了保证在不能恰好被cell均分的情况</span></span><br><span class="line">    <span class="function">cv::HOGDescriptor <span class="title">hog</span><span class="params">(cv::Size((image.cols/cellSize.width)*cellSize.width, (image.rows/cellSize.height)*cellSize.height),</span></span></span><br><span class="line"><span class="params"><span class="function">                          cv::Size((image.cols/cellSize.width)*cellSize.width, (image.rows/cellSize.height)*cellSize.height),</span></span></span><br><span class="line"><span class="params"><span class="function">                          cellSize, cellSize, nBins)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute HOG</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt;descriptors;</span><br><span class="line">    hog.<span class="built_in">compute</span>(image, descriptors);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> scale = <span class="number">2.0</span> / *std::<span class="built_in">max_element</span>(descriptors.<span class="built_in">begin</span>(), descriptors.<span class="built_in">end</span>());</span><br><span class="line">    hogImage.<span class="built_in">create</span>(image.rows, image.cols, CV_8U);</span><br><span class="line">    cv::Mat temp;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt;::const_iterator itDesc = descriptors.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;image.rows/cellSize.height; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; image.cols/cellSize.width; j++)&#123;</span><br><span class="line">            <span class="comment">// draw each cell</span></span><br><span class="line">            temp = <span class="built_in">hogImage</span>(cv::<span class="built_in">Rect</span>(j*cellSize.width, i*cellSize.height, cellSize.width, cellSize.height));</span><br><span class="line">            <span class="built_in">drawHOG</span>(itDesc, nBins, temp, scale);</span><br><span class="line">            itDesc += nBins;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/MyCV/data/girl.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::HOGDescriptor <span class="title">hog</span><span class="params">(cv::Size((image.cols / <span class="number">16</span>) * <span class="number">16</span>, (image.rows / <span class="number">16</span>) * <span class="number">16</span>), <span class="comment">// size of the window</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          cv::Size(<span class="number">16</span>, <span class="number">16</span>),  <span class="comment">// block size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          cv::Size(<span class="number">16</span>, <span class="number">16</span>),  <span class="comment">// block stride</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          cv::Size(<span class="number">4</span>, <span class="number">4</span>),  <span class="comment">// cell size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="number">9</span>)</span></span>; <span class="comment">// num of bins</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; descriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw  a representation of HOG cells</span></span><br><span class="line">    cv::Mat hogImage = image.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">drawHOGDescriptors</span>(image, hogImage, cv::<span class="built_in">Size</span>(<span class="number">16</span>, <span class="number">16</span>), <span class="number">9</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;HOG image&quot;</span>, hogImage);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/Original%20image_081704.png" alt=""><br>
<img src="http://datahonor-1252464519.costj.myqcloud.com/201708/HOG%20image_081705.png" alt=""></p>
<h5 id="HOG-SVM检测警示牌">HOG+SVM检测警示牌</h5>
<p>这里是自己完成训练到预测全部过程的，之前看到<a href="http://blog.csdn.net/masibuaa/article/details/16105073">这个</a>，但是是OpenCV2.4的，尝试改成3的没成功，很多函数的用法已经变了，不过对比看还是下面这种逻辑更为清晰一些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/ml.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate the filename</span></span><br><span class="line">    std::vector&lt;std::string&gt; imgs;</span><br><span class="line">    std::string prefix = <span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/b&quot;</span></span><br><span class="line">            <span class="string">&quot;ooks/CV/1-ing/OpenCV3ComputerVisionApplicationProgrammingCookbook&quot;</span></span><br><span class="line">            <span class="string">&quot;ThirdEdition_Code/images/stopSamples/stop&quot;</span>;</span><br><span class="line">    std::string ext = <span class="string">&quot;.png&quot;</span>;</span><br><span class="line">    <span class="comment">// loading 8 positive samples</span></span><br><span class="line">    std::vector&lt;cv::Mat&gt; positives;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(prefix)</span></span>;</span><br><span class="line">        std::ostringstream ss;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; i;</span><br><span class="line">        name += ss.<span class="built_in">str</span>();</span><br><span class="line">        name += ext;</span><br><span class="line">        positives.<span class="built_in">push_back</span>(<span class="built_in">imread</span>(name, cv::IMREAD_GRAYSCALE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the first 8 positive samples</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">posSamples</span><span class="params">(<span class="number">2</span> * positives[<span class="number">0</span>].rows, <span class="number">4</span> * positives[<span class="number">0</span>].cols, CV_8U)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            positives[i * <span class="number">4</span> + j].<span class="built_in">copyTo</span>(<span class="built_in">posSamples</span>(cv::<span class="built_in">Rect</span>(j * positives[i * <span class="number">4</span> + j].cols,</span><br><span class="line">                                                            i * positives[i * <span class="number">4</span> + j].rows,</span><br><span class="line">                                                            positives[i * <span class="number">4</span> + j].cols,</span><br><span class="line">                                                            positives[i * <span class="number">4</span> + j].rows)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Positive samples&quot;</span>, posSamples);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// laoding 8 negative samples</span></span><br><span class="line">    std::string nprefix = <span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/1-ing&quot;</span></span><br><span class="line">            <span class="string">&quot;/OpenCV3ComputerVisionApplicationProgrammingCookbookThirdEdition_Code&quot;</span></span><br><span class="line">            <span class="string">&quot;/images/stopSamples/neg&quot;</span>;</span><br><span class="line">    std::vector&lt;cv::Mat&gt; negatives;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">name</span><span class="params">(nprefix)</span></span>;</span><br><span class="line">        std::ostringstream ss;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; i;</span><br><span class="line">        name += ss.<span class="built_in">str</span>();</span><br><span class="line">        name += ext;</span><br><span class="line">        negatives.<span class="built_in">push_back</span>(cv::<span class="built_in">imread</span>(name, cv::IMREAD_GRAYSCALE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the first 8 negative  samples</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">negSamples</span><span class="params">(<span class="number">2</span> * negatives[<span class="number">0</span>].rows, <span class="number">4</span> * negatives[<span class="number">0</span>].cols, CV_8U)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            negatives[i * <span class="number">4</span> + j].<span class="built_in">copyTo</span>(</span><br><span class="line">                    <span class="built_in">negSamples</span>(cv::<span class="built_in">Rect</span>(j * negatives[<span class="number">4</span> * i + j].cols,</span><br><span class="line">                                        i * negatives[<span class="number">4</span> * i + j].rows, negatives[<span class="number">4</span> * i + j].cols,</span><br><span class="line">                                        negatives[<span class="number">4</span> * i + j].rows)));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Negative Samples&quot;</span>, negSamples);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The HOG descriptor for stop sign detection</span></span><br><span class="line">    <span class="function">cv::HOGDescriptor <span class="title">hogDesc</span><span class="params">(positives[<span class="number">0</span>].size(), <span class="comment">// size of the window</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              cv::Size(<span class="number">8</span>, <span class="number">8</span>),  <span class="comment">// block size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              cv::Size(<span class="number">4</span>, <span class="number">4</span>),  <span class="comment">// block stride</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              cv::Size(<span class="number">4</span>, <span class="number">4</span>),  <span class="comment">// cell size</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="number">9</span>  <span class="comment">// number of bins</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute first descriptor</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; desc;</span><br><span class="line">    hogDesc.<span class="built_in">compute</span>(positives[<span class="number">0</span>], desc);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Positive sample size: &quot;</span> &lt;&lt; positives[<span class="number">0</span>].rows &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; positives[<span class="number">0</span>].cols &lt;&lt; endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HOG descriptor size: &quot;</span> &lt;&lt; desc.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the matrix of sample descriptors</span></span><br><span class="line">    <span class="type">int</span> featureSize = desc.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> numberOfSamples = positives.<span class="built_in">size</span>() + negatives.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// create the matrix that will contain the sample HOG</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">samples</span><span class="params">(numberOfSamples, featureSize, CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill first row with first descriptor</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++)</span><br><span class="line">        samples.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>)[i] = desc[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute descriptor of the positive samples</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; positives.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        hogDesc.<span class="built_in">compute</span>(positives[j], desc);</span><br><span class="line">        <span class="comment">// fill the next row with current descriptor</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++) &#123;</span><br><span class="line">            samples.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(j)[i] = desc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute descriptor of the negative samples</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; negatives.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        hogDesc.<span class="built_in">compute</span>(negatives[j], desc);</span><br><span class="line">        <span class="comment">// fill the next row with current descriptor</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++) &#123;</span><br><span class="line">            samples.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(j + positives.<span class="built_in">size</span>())[i] = desc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the labels</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">labels</span><span class="params">(numberOfSamples, <span class="number">1</span>, CV_32SC1)</span></span>;</span><br><span class="line">    <span class="comment">// labels of positive samples</span></span><br><span class="line">    labels.<span class="built_in">rowRange</span>(<span class="number">0</span>, positives.<span class="built_in">size</span>()) = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// labels of negative sampels</span></span><br><span class="line">    labels.<span class="built_in">rowRange</span>(positives.<span class="built_in">size</span>(), numberOfSamples) = <span class="number">-1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create SVM classifier</span></span><br><span class="line">    cv::Ptr&lt;cv::ml::SVM&gt; svm = cv::ml::SVM::<span class="built_in">create</span>();</span><br><span class="line">    svm-&gt;<span class="built_in">setType</span>(cv::ml::SVM::C_SVC);</span><br><span class="line">    svm-&gt;<span class="built_in">setKernel</span>(cv::ml::SVM::LINEAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare the training data</span></span><br><span class="line">    cv::Ptr&lt;cv::ml::TrainData&gt; trainingData =</span><br><span class="line">            cv::ml::TrainData::<span class="built_in">create</span>(samples, cv::ml::SampleTypes::ROW_SAMPLE, labels);</span><br><span class="line">    <span class="comment">// SVM training</span></span><br><span class="line">    svm-&gt;<span class="built_in">train</span>(trainingData);</span><br><span class="line">    <span class="comment">// 将训练好的SVM模型保存为XML文件</span></span><br><span class="line">    svm-&gt;<span class="built_in">save</span>(<span class="string">&quot;STOP_LOGO.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">queries</span><span class="params">(<span class="number">4</span>, featureSize, CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the rows with query descriptor</span></span><br><span class="line">    hogDesc.<span class="built_in">compute</span>(cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/bo&quot;</span></span><br><span class="line">                                       <span class="string">&quot;oks/CV/1-ing/OpenCV3ComputerVisionApplication&quot;</span></span><br><span class="line">                                       <span class="string">&quot;ProgrammingCookbookThirdEdition_Code/images/stopSamples/stop08.png&quot;</span>, <span class="number">0</span>), desc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++)</span><br><span class="line">        queries.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>)[i] = desc[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hogDesc.<span class="built_in">compute</span>(cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/boo&quot;</span></span><br><span class="line">                                       <span class="string">&quot;ks/CV/1-ing/OpenCV3ComputerVisionApplicationProgramm&quot;</span></span><br><span class="line">                                       <span class="string">&quot;ingCookbookThirdEdition_Code/images/stopSamples/stop09.png&quot;</span>, <span class="number">0</span>), desc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++)</span><br><span class="line">        queries.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>)[i] = desc[i];</span><br><span class="line"></span><br><span class="line">    hogDesc.<span class="built_in">compute</span>(cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/&quot;</span></span><br><span class="line">                                       <span class="string">&quot;Cpp/books/CV/1-ing/OpenCV3ComputerVisionApplicationPro&quot;</span></span><br><span class="line">                                       <span class="string">&quot;grammingCookbookThirdEdition_Code/images/stopSamples/neg08.png&quot;</span>, <span class="number">0</span>), desc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++)</span><br><span class="line">        queries.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>)[i] = desc[i];</span><br><span class="line"></span><br><span class="line">    hogDesc.<span class="built_in">compute</span>(cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/&quot;</span></span><br><span class="line">                                       <span class="string">&quot;CV/1-ing/OpenCV3ComputerVisionApplicationP&quot;</span></span><br><span class="line">                                       <span class="string">&quot;rogrammingCookbookThirdEdition_Code/images/stopSamples/neg09.png&quot;</span>, <span class="number">0</span>), desc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; featureSize; i++)</span><br><span class="line">        queries.<span class="built_in">ptr</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>)[i] = desc[i];</span><br><span class="line"></span><br><span class="line">    cv::Mat predictions;</span><br><span class="line">    svm-&gt;<span class="built_in">predict</span>(queries, predictions);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;query: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt;</span><br><span class="line">                                       ((predictions.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,<span class="number">0</span>) &lt; <span class="number">0.0</span>) ?</span><br><span class="line">                                       <span class="string">&quot;Negative&quot;</span> : <span class="string">&quot;Positive&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Positive sample size: 64x64
HOG descriptor size: 8100
query: 0: Positive
query: 1: Positive
query: 2: Negative
query: 3: Negative
</code></pre>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/Positive%20samples_081707.png" alt=""></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/Negative%20Samples_081706.png" alt=""></p>
<h5 id="Pedestrian-Detection简化版">Pedestrian Detection简化版</h5>
<p>同样是用的OpenCV自带的行人检测器，这里只是一个针对照片的简化版本，<a href="http://datahonor.com/2017/08/17/Pedestrain-Detection/">这里</a>是完整版。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;matplotlibcpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// People detection</span></span><br><span class="line">    cv::Mat myImage = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/MyCV/data/person.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// create the detector</span></span><br><span class="line">    std::vector&lt;cv::Rect&gt; peoples;</span><br><span class="line">    cv::HOGDescriptor peopleHog;</span><br><span class="line">    peopleHog.<span class="built_in">setSVMDetector</span>(cv::HOGDescriptor::<span class="built_in">getDefaultPeopleDetector</span>());</span><br><span class="line">    <span class="comment">// detect people on an image</span></span><br><span class="line">    peopleHog.<span class="built_in">detectMultiScale</span>(myImage,</span><br><span class="line">                               peoples, <span class="number">0</span>, cv::<span class="built_in">Size</span>(<span class="number">4</span>, <span class="number">4</span>), cv::<span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">32</span>), <span class="number">1.1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// draw detections on image</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; peoples.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cv::<span class="built_in">rectangle</span>(myImage, peoples[i], cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;People detection&quot;</span>, myImage);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/People%20detection_081708.png" alt=""></p>
<h4 id="…">…</h4>
<p>马上大三了，课比较多，估计没时间再捣鼓这些纯粹为了兴趣的东西了orz…嗯，不过毕竟看了快一年，也算是有点基础了解吧，之后还有机会玩这个也会轻松一些了。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell&amp;The Caesar Cipher</title>
    <url>/2018/02/07/Haskell-The-Caesar-Cipher/</url>
    <content><![CDATA[<h4 id="Overvier">Overvier</h4>
<p>例子来自<em>Programming in Haskell</em>(很好的一本书，简要明了)， 主要是将list comprehension。仅仅短短几十行代码…充分体现了FP的concise…</p>
<h4 id="Code-16">Code</h4>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">module</span> FirstScript <span class="keyword">where</span></span><br><span class="line">  <span class="keyword">import</span> Test.QuickCheck</span><br><span class="line">  <span class="keyword">import</span> Test.HUnit</span><br><span class="line">  <span class="keyword">import</span> Data.Char</span><br><span class="line"></span><br><span class="line">  let2int :: <span class="type">Char</span> -&gt; <span class="type">Int</span></span><br><span class="line">  let2int c  = ord c - ord &#x27;a&#x27;</span><br><span class="line">  int2let :: <span class="type">Int</span> -&gt; <span class="type">Char</span></span><br><span class="line">  int2let n = chr(ord &#x27;a&#x27; + n)</span><br><span class="line"></span><br><span class="line">  shift :: <span class="type">Int</span> -&gt; <span class="type">Char</span> -&gt; <span class="type">Char</span></span><br><span class="line">  shift n c | isLower c = int2let((let2int c + n) `mod` <span class="number">26</span>)</span><br><span class="line">			| otherwise = c</span><br><span class="line"></span><br><span class="line">  encode :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line">  encode n xs = [shift n x | x &lt;- xs]</span><br><span class="line"></span><br><span class="line">  percent :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span> -&gt; <span class="type">Float</span></span><br><span class="line">  percent n m = (fromInteger n / fromInteger m)*<span class="number">100</span></span><br><span class="line"></span><br><span class="line">  count :: <span class="type">Char</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Integer</span></span><br><span class="line">  count c string = sum[ <span class="number">1</span> | x &lt;- string, c == x ]</span><br><span class="line"></span><br><span class="line">  lowers :: <span class="type">String</span> -&gt; <span class="type">Integer</span></span><br><span class="line">  lowers xs = sum[ <span class="number">1</span> | x &lt;- xs, isLower x ]</span><br><span class="line"></span><br><span class="line">  freqs :: <span class="type">String</span> -&gt; [<span class="type">Float</span>]</span><br><span class="line">  freqs xs = [percent (count x xs) n | x &lt;- [&#x27;a&#x27;..&#x27;z&#x27;]]</span><br><span class="line">		  <span class="keyword">where</span> n = lowers xs</span><br><span class="line">  table :: [<span class="type">Float</span> ]</span><br><span class="line">  table = [<span class="number">8.2</span>, <span class="number">1.5</span>, <span class="number">2.8</span>, <span class="number">4.3</span>, <span class="number">12.7</span>, <span class="number">2.2</span>, <span class="number">2.0</span>, <span class="number">6.1</span>, <span class="number">7.0</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">4.0</span>, <span class="number">2.4</span>,</span><br><span class="line">		<span class="number">6.7</span>, <span class="number">7.5</span>, <span class="number">1.9</span>, <span class="number">0.1</span>, <span class="number">6.0</span>, <span class="number">6.3</span>, <span class="number">9.1</span>, <span class="number">2.8</span>, <span class="number">1.0</span>, <span class="number">2.4</span>, <span class="number">0.2</span>, <span class="number">2.0</span>, <span class="number">0.1</span>]</span><br><span class="line"></span><br><span class="line">  chisqr :: [<span class="type">Float</span>] -&gt; [<span class="type">Float</span>] -&gt; <span class="type">Float</span></span><br><span class="line">  chisqr os es = sum[ (o-e)^<span class="number">2</span> | (o, e) &lt;- zip os es]</span><br><span class="line"></span><br><span class="line">  rotate :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line">  rotate n xs = drop n xs ++ take n xs</span><br><span class="line"></span><br><span class="line">  positions :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; [<span class="type">Int</span>]</span><br><span class="line">  positions x xs = [ i | (x&#x27;, i) &lt;- zip xs [<span class="number">0</span>..n-<span class="number">1</span>], x&#x27; == x] <span class="keyword">where</span></span><br><span class="line">			n = length xs</span><br><span class="line"></span><br><span class="line">  crack :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line">  crack xs = encode (-factor) xs <span class="keyword">where</span></span><br><span class="line">			factor = head (positions (minimum chitab) chitab)</span><br><span class="line">			chitab = [chisqr (rotate n table&#x27;) table | n &lt;- [<span class="number">0</span>..<span class="number">25</span>]]</span><br><span class="line">			table&#x27; = freqs xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- test data</span></span><br><span class="line"><span class="comment">-- crack (encode 3 &quot;Haskell is fun and I love it!&quot;)</span></span><br><span class="line"><span class="comment">-- crack (encode 3 &quot;Haskell is fun!&quot;)</span></span><br><span class="line"><span class="comment">-- crack (encode 3 &quot;haskell is fun!&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps:一开始看到用卡方值还一阵惊讶，我可能不是一个合格的玩统计的人…其实从前面开始讲词频的时候就该想到和分布有关，然后由于一般性，首先应该想到正态分布，进而就是”集成正态分布“的卡方分布了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Haskell</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell in Ubuntu</title>
    <url>/2017/11/12/Haskell-in-Ubuntu/</url>
    <content><![CDATA[<h3 id="基础集成开发环境搭建">基础集成开发环境搭建</h3>
<p>在Ubuntu下配置集成Haskell集成开发环境。首先是按照官网教程，一条命令直接安装了haskell plateform、之后尝试配置一个和leksah关联的IDE，一直出错，所以就换成Atom来配置了。直接apm安装一些插件后，必须添加一个运行脚本的插件才可以直接在Atom编译并运行haskell。测试发现，Atom没有办法交互式地输入数据到程序，所以暂时安装了一个可以调用终端的插件代替。配置过后，发现Atom还挺好看~</p>
<h3 id="其他配置">其他配置</h3>
<h4 id="将GHCi的终端提示符永久替换为λ">将GHCi的终端提示符永久替换为λ</h4>
<p>直接新建<code>~/.ghci</code>文件，并写入：</p>
<blockquote>
<p>:set prompt “\ESC[1;34m%s\n\ESC[0;34mλ&gt; \ESC[m”</p>
</blockquote>
<p>这样进入GHCi（不会成功显示λ）将会有如下提示：</p>
<blockquote>
<p>GHCi, version 7.10.3: <a href="http://www.haskell.org/ghc/">http://www.haskell.org/ghc/</a>  :? for help<br>
*** WARNING: /home/shensir/.ghci is writable by someone else, IGNORING!<br>
Suggested fix: execute ‘chmod go-w /home/shensir/.ghci’</p>
</blockquote>
<p>按照提示执行下面的命令即可修复：</p>
<blockquote>
<p>chmod go-w /home/shensir/.ghci</p>
</blockquote>
<p>这样每次回车都会产生两行，第一行是所在module,第二行是一个λ。好看且方便~</p>
<p>参考<a href="https://coderwall.com/p/13h9bw/colored-ghci-prompt-with-and-modules-on-separate-lines">这里</a></p>
]]></content>
      <categories>
        <category>Haskell</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Docker!</title>
    <url>/2017/10/24/Hello-Docker/</url>
    <content><![CDATA[<h3 id="Overview-18">Overview</h3>
<p>一直不清楚Docker怎么玩，只知道很强…打算学习下怎么用。</p>
<p>关于版本：</p>
<blockquote>
<p>Docker CE is the simple classical OSS Docker Engine.</p>
</blockquote>
<blockquote>
<p>Docker EE is Docker CE with certification on some systems and support by Docker Inc.</p>
</blockquote>
<blockquote>
<p>Docker CS (Commercially Supported) is kind of the old bundle version of Docker EE for versions &lt;= 1.13.</p>
</blockquote>
<p>这里装的是CE.</p>
<h3 id="安装与配置">安装与配置</h3>
<p>基本上按照官网教程来的。</p>
<h4 id="Install">Install</h4>
<p>先是<a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/">Get Docker CE for Ubuntu</a>, 选用的是<code>Install using the repository</code>。一切正常。</p>
<blockquote>
<p>之后尝试<code> docker run -it ubuntu bash</code>，然后就进去了一个环境，但是怎么也无法退出…参考<a href="https://forums.docker.com/t/container-stops-upon-exit-from-the-terminal/1267/2">这里</a>,使用<code>CTRL+p CTRL+q</code>退出到了原来的环境。</p>
</blockquote>
<h4 id="Post-installation-steps-for-Linux">Post-installation steps for Linux</h4>
<p>参考<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user">这里</a>,只是设置了非root的权限，其他的暂时没去管。</p>
<h4 id="Build-and-run-your-first-app">Build and run your first app</h4>
<p>参考<a href="https://docs.docker.com/get-started/">这里</a>进行下一步的操作。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello! 树先生</title>
    <url>/2021/12/15/Hello-%E6%A0%91%E5%85%88%E7%94%9F/</url>
    <content><![CDATA[<p>Hello! 树先生.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hough变换</title>
    <url>/2017/05/28/Hough%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="Overview-19">Overview</h4>
<p>关于hough变换，确实被它的奇妙思想震撼到。</p>
<blockquote>
<p>图像空间中共线的点对应参数空间共点的线。</p>
</blockquote>
<p>于是就尝试去实现这个变换.</p>
<h4 id="Code-17">Code</h4>
<h5 id="Python">Python</h5>
<p>先用Python写了个demo，效果还是可以的，但是写的略显粗糙…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取原空间的点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_raw_points</span>():</span><br><span class="line">    points = np.array([[<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取原空间点对应的线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_line</span>(<span class="params">points</span>):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    para_points = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        a = point[<span class="number">0</span>]</span><br><span class="line">        b = point[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        para_X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">101</span>)</span><br><span class="line">        para_Y = a * para_X + b</span><br><span class="line">        plt.plot(para_X, para_Y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(para_X)):</span><br><span class="line">            para_x = np.<span class="built_in">round</span>(para_X[i], <span class="number">3</span>)</span><br><span class="line">            para_y = np.<span class="built_in">round</span>(para_Y[i], <span class="number">3</span>)</span><br><span class="line">            <span class="comment"># para_points.append([para_x, para_y])</span></span><br><span class="line">            para_str = <span class="built_in">str</span>(np.<span class="built_in">round</span>([para_x, para_y], <span class="number">3</span>))</span><br><span class="line">            <span class="keyword">if</span> para_str <span class="keyword">not</span> <span class="keyword">in</span> para_points.keys():</span><br><span class="line">                para_points[para_str] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                para_points[para_str] += <span class="number">1</span></span><br><span class="line">    plt.legend([<span class="string">&#x27;(1,1)&#x27;</span>, <span class="string">&#x27;(2,2)&#x27;</span>, <span class="string">&#x27;(3,3)&#x27;</span>, <span class="string">&#x27;(1,2)&#x27;</span>, <span class="string">&#x27;(2,1)&#x27;</span>])</span><br><span class="line">    <span class="comment"># 按照交点个数排序</span></span><br><span class="line">    sorted_para_points = <span class="built_in">sorted</span>(para_points.items(), key=operator.itemgetter(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取其中的交点,这里就简短地从结果看下，直接切片了</span></span><br><span class="line">    <span class="comment"># 正规是根据点的value来取的，也不麻烦。</span></span><br><span class="line">    more_points = sorted_para_points[-<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The point that we want to find!</span></span><br><span class="line">    <span class="comment"># 这里可以用正则...前面写的太粗糙了，这里就取点比较麻烦了</span></span><br><span class="line">    <span class="comment"># 绿色点标记交点</span></span><br><span class="line">    plt.plot(-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;go&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> more_points</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在hough变换后找到直线[a,b]后，在原空间画出此直线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_point_line</span>():</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    points = get_raw_points()</span><br><span class="line">    plt.plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">    <span class="comment"># [-1,0]--&gt; 0=-a+b --&gt; b=a --&gt; y=x</span></span><br><span class="line"></span><br><span class="line">    X = np.linspace(-<span class="number">2</span>,<span class="number">5</span>,<span class="number">101</span>)</span><br><span class="line">    Y= X</span><br><span class="line">    plt.plot(X, Y, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    points = get_raw_points()</span><br><span class="line">    more_points = get_line(points)</span><br><span class="line">    plot_point_line()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Figure%201_052801.png" alt=""><br>
<img src="http://blog-1252464519.costj.myqcloud.com/1705/Figure%202_052802.png" alt=""></p>
<h5 id="Cpp">Cpp</h5>
<p>在用Python写出demo后，想着拿一张真实的图像来试试，结果没成功…也没有找出原因。这里贴上代码，请看出错误的大佬指点…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;matplotlibcpp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">namespace</span> plt = matplotlibcpp;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;cv::Point&gt; <span class="title">PointFindPtr</span><span class="params">(cv::Mat image)</span></span>&#123;</span><br><span class="line">    vector&lt;cv::Point&gt; Points;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nl = image.rows; <span class="comment">// number of lines</span></span><br><span class="line">    <span class="comment">// total number or element per ;ine</span></span><br><span class="line">    <span class="type">int</span> nc = image.cols * image.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nl; j++)&#123;</span><br><span class="line">        <span class="comment">//get the address of row j</span></span><br><span class="line">        uchar* data = image.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nc;i++)&#123;</span><br><span class="line">            <span class="comment">// process each pixel=======================</span></span><br><span class="line">            <span class="keyword">if</span> (data[i] == <span class="number">255</span>)</span><br><span class="line">                Points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point</span>(j, i));</span><br><span class="line">            <span class="comment">// OR in this way</span></span><br><span class="line">            <span class="comment">//data[i] = (data[i]/div)*div + div/2;</span></span><br><span class="line">            <span class="comment">//end of pixel processing=====================</span></span><br><span class="line">        &#125;<span class="comment">//end of line</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Points;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/road.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply Canny algotithm</span></span><br><span class="line">    cv::Mat contours;</span><br><span class="line">    cv::<span class="built_in">Canny</span>(image, contours, <span class="number">125</span>, <span class="number">350</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Contours&quot;</span>, contours);</span><br><span class="line"></span><br><span class="line">    vector&lt;cv::Point&gt; Points = <span class="built_in">PointFindPtr</span>(contours);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = Points.<span class="built_in">size</span>();</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        Point point_i = Points[i];</span><br><span class="line">        <span class="type">int</span> a = point_i.x;</span><br><span class="line">        <span class="type">int</span> b = point_i.y;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">x</span><span class="params">(<span class="number">360</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">360</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">360</span>; i++)&#123;</span><br><span class="line">            x.<span class="built_in">at</span>(i) = <span class="number">2</span>*PI/i-PI;</span><br><span class="line">            y.<span class="built_in">at</span>(i) = a*<span class="built_in">cos</span>(<span class="number">2</span>*PI/i)+b*<span class="built_in">sin</span>(<span class="number">2</span>*PI/i);</span><br><span class="line">        &#125;</span><br><span class="line">        plt::<span class="built_in">plot</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    plt::<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Figure%201_052803.png" alt=""></p>
<p>参数空间所有的线交在一点说明图像中，所有的点共线…很明显是错误的…</p>
<p>这里，matplotlibcpp的安装，参考<a href="https://github.com/lava/matplotlib-cpp">gothub项目地址</a>,记得安装后将matplotlibcpp.h文件放到自己的工程里面。且这里在cmake做了改动才可以，使用的，<br>
<code>include_directories(Clions $&#123;PYTHON_INCLUDE_DIRS&#125;)</code>，<br>
而不是<code>target_include_directories(Clions $&#123;PYTHON_INCLUDE_DIRS&#125;)</code>。</p>
<h5 id="Cpp调用Python">Cpp调用Python</h5>
<p>上面是对amtplotlib进行了包装，然后直接在Cpp使用。除此之外，我们还有另一个办法在Cpp中使用Python。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;python2.7/Python.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pythonrun.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Py_Initialize</span>();</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;import pylab&quot;</span>);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;pylab.plot(range(5))&quot;</span>);</span><br><span class="line">    <span class="built_in">PyRun_SimpleString</span>(<span class="string">&quot;pylab.show()&quot;</span>);</span><br><span class="line">    <span class="built_in">Py_Exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，这里的头文件：</p>
<pre><code>#include &lt;python2.7/Python.h&gt;
#include &quot;pythonrun.h&quot;
</code></pre>
<p>在测试的时候，直接写Python.h是找不到的，而且没有下面的pythonrun.h也是不行的。</p>
<h4 id="Reference-6">Reference</h4>
<p><a href="https://stackoverflow.com/questions/613183/sort-a-python-dictionary-by-value">字典按键值排序</a></p>
<p><a href="https://stackoverflow.com/questions/8024737/c-interface-for-matplotlib">Python.h</a></p>
<p><a href="https://github.com/lava/matplotlib-cpp">matplotlibcpp</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>How to write a Python package?</title>
    <url>/2019/07/13/How-to-write-a-Python-package/</url>
    <content><![CDATA[<p>这里记录下如何将自己写的Python程序打包成库，并安装, 参考官方文档<a href="https://packaging.python.org/tutorials/packaging-projects/">Packaging Python Projects</a>。</p>
<h2 id="方法一：官方安装流程">方法一：官方安装流程</h2>
<p>首先，我们要有一个文件夹，比如名为<code>mypkg</code>的文件夹。</p>
<p>之后我们需要将我们主要的源文件，比如<code>myml</code>文件夹（比如里面是一些机器学习的算法实现）， 添加到<code>mypkg</code>中。</p>
<p>之后我们需要两个辅助文件：<code>setup.py</code>和<code>README.md</code></p>
<p>其中<code>README.md</code>写上项目简短的说明即可。</p>
<p><code>setup.py</code>需要按照一定的格式写，比如下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&quot;example-pkg-your-username&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    author=<span class="string">&quot;Example Author&quot;</span>,</span><br><span class="line">    author_email=<span class="string">&quot;author@example.com&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A small example package&quot;</span>,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line">    url=<span class="string">&quot;https://github.com/pypa/sampleproject&quot;</span>,</span><br><span class="line">    packages=setuptools.find_packages(),</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">&quot;Programming Language :: Python :: 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;License :: OSI Approved :: MIT License&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Operating System :: OS Independent&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后呢，我们就可以将上面的文件夹打包并发布了，发布之后便可以自行通过pip安装。具体可以参考上面官网的链接。</p>
<p>但是，我们这里可能会有一个需求，那就是，我们可能要持续开发这个库。这样的话，我们可以用pip提供的<a href="https://pip.pypa.io/en/stable/reference/pip_install/#id44">“Editable” Installs</a>, 如此可以进入<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#id25">“Development Mode”</a>。也即，我们只需要在<code>mypkg</code>上层文件夹下运行<code>pip install -e mypkg</code>就可以直接进入开发模式。这时候我们已经可以在终端（但是记得不要在<code>myml</code>文件下，不然就会无法调用）运行Python, 并直接通过<code>import myml</code>来完成调用。</p>
<p>这里我们对代码进行更改后，只需要在<code>mypkg</code>文件下用命令行运行<code>python setup.py build</code>就可以将新的改动提交上去。最后在我们将项目开发完时，运行<code>python setup.py develop --uninstall</code>将开发版本卸载掉，之后重新打包发布，在安装正式版本即可。</p>
<h3 id="init-py文件的写法"><code>__init__.py</code>文件的写法</h3>
<p>首先明确<code>__init__.py</code>文件存在，则其所在的文件夹被自动视为一个<code>package</code>,在运行<code>import package_name</code>之后，其对应的<code>__init__.py</code>首先被调用。</p>
<p>按照文档，最顶层的<code>__init__.py</code>可以只写上库名字：<code>name = &quot;example_pkg&quot;</code>。</p>
<p>其他的一般空下，不写任何东西，只是作为一个标识。</p>
<p>也有时候会用于多个<code>submodules</code>的一起调用或者限制调用，具体可以参考<em>Python Cookbook3-Chap10</em>.</p>
<h3 id="测试">测试</h3>
<p>在写完需求后，写简单的单元测试来验证API的正确性，同时也避免了通过打印测试的局限性。目前主要用的还是<code>unittest</code>库，结合<code>vscode</code>使用非常方便。</p>
<h3 id="文档">文档</h3>
<p>对于一个完整的库来说，文档是必不可少的，这里选用的是用<code>Sphinx</code>来做项目的文档。大致流程可以先参考下<a href="https://docs.readthedocs.io/en/stable/intro/getting-started-with-sphinx.html">这里</a>, 将文档通过Github发布，可以参考<a href="https://www.youtube.com/channel/UCOSeGDrlScCNgBcN5C8nTEw">Open Source Options</a>的这个教程， 最后还有些细枝末节的问题，可以看<a href="https://daler.github.io/sphinxdoc-test/includeme.html">这篇文档</a></p>
<p>上面的教程总体感觉都挺乱的，这里进行下汇总。</p>
<h4 id="Step1-本地生成">Step1: 本地生成</h4>
<p>首先安装<code>sphinx</code>: <code>pip install sphinx</code>.</p>
<p>之后在<code>mypkg</code>新建文件夹<code>sphinx</code>， 之后进入该文件夹<code>cd sphinx</code>，并运行<code>sphinx-quickstart</code>， 根据提示输入对应的信息。（这里填错了后面还可以改的）</p>
<p>这时候，可以根据<a href="http://sphinx-doc.org/rest.html">reStructuredText</a> 语法写改<code>sphinx</code>文件夹下的<code>.rst</code>文件，指定生成文档的内容与格式等。</p>
<p>之后修改<code>sphinx/source/conf.py</code>文件设置<code>autodoc</code>，参考<a href="https://www.jianshu.com/p/23a54872ab82">这里</a>。因为我在设置的时候没有遇到让加入<code>extensions</code>的提示，所以就手动设置，修改结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">&quot;sphinx.ext.autodoc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sphinx.ext.intersphinx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sphinx.ext.todo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sphinx.ext.viewcode&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sphinx_rtd_theme&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里还有去掉下面路径设置的注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, os.path.abspath(<span class="string">&#x27;.&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>然后保存（其他设置可以随便找个开源项目看看别人怎么写的，比如<code>requests</code>库），在<code>sphinx</code>文件夹下，终端执行<code>sphinx-apidoc -o ./source ../src/</code></p>
<p>最后是生成html文件，<code>make html</code>。</p>
<p>此时可以打开<code>sphinx/build/html/index.html</code>打开文档。</p>
<h4 id="Step2-发布文档">Step2: 发布文档</h4>
<p>发布的方法<a href="https://daler.github.io/sphinxdoc-test/includeme.html">这篇文档</a>写的比较详细，可以照着作下，我这里并没有测试，而是按照<a href="https://www.youtube.com/channel/UCOSeGDrlScCNgBcN5C8nTEw">Open Source Options</a>最后一集比较粗暴的方法。</p>
<p>就是在<code>mypkg</code>文件夹下新建一个<code>docs</code>文件夹，之后将<code>html</code>文件夹下的文档全部复制过去，再新建一个<code>.nojekyll</code>文件，之后直接commit， push到github。最后在项目的<code>setting</code>中选择githubpages的设置，选中<code>docs</code>文件夹即可。</p>
<p>之后重新生成文档，同样将<code>html</code>文件夹下的文件全部复制到<code>docs</code>再提交就是了。注意这里<code>.nojekyll</code>文件十分重要，如果没有这个文件（而是选择某个主题），会出现文档页面无法显示的情况。</p>
<p>在全部完成之后就可以打包发布了。其他可能有些设置没有提到，可以看下我的<a href="https://github.com/shenxiangzhuang/ToyData">ToyData</a>项目的设置。</p>
<h2 id="方法二：自动化构建">方法二：自动化构建</h2>
<p>之前的项目都是按照上面的方法一来构建和发布的，但是总体来看，流程还是有一些复杂的…(当然了，全面地了解下这个流程还是很有必要的)</p>
<p>所以就查了下一些自动化构建的工具，在测试过之后采取了<a href="https://python-poetry.org/">Poetry</a>+<a href="https://www.mkdocs.org">MkDocs</a>的组合: Poetry用于库文件的创建，库的本地打包与<a href="https://pypi.org/">PyPI</a>上传; MkDocs用于文档的生成与部署。下面简单介绍下整个库从重建到发布的流程。(Poetry和MkDocs的安装见官网指引)</p>
<h3 id="本地创建库">本地创建库</h3>
<p>命令行执行<code>poetry new poetry-mkdocs-shenxzh</code>, 输出<code>Created package poetry_mkdocs_shenxzh in poetry-mkdocs-shenxzh</code>.</p>
<p>查看文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ tree </span><br><span class="line">.</span><br><span class="line">├── poetry_mkdocs_shenxzh</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── pyproject.toml</span><br><span class="line">├── README.rst</span><br><span class="line">└── tests</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_poetry_mkdocs_shenxzh.py</span><br></pre></td></tr></table></figure>
<p>我们在<code>poetry_mkdocs_shenxzh</code>文件夹下放我们的库源码，在<code>tests</code>文件夹下做测试。为了符合一般习惯，可以把<code>README.rst</code>改成<code>README.md</code>, <code>pyproject.toml</code>是项目的主要配置文件，包括库依赖等设置。</p>
<p>后面就要进行库的开发了，我们用Git记录开发过程，故在<code>pyproject.toml</code>同目录(后称之为根目录)下运行<code>git init</code>初始化项目。</p>
<p>之后添加库文件，修改<code>README.md</code>文件， <code>.gitignore</code>，测试…</p>
<p>之后在根目录下执行<code>mkdocs new docs</code>, 此时<code>docs</code>文件夹目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ tree .</span><br><span class="line">.</span><br><span class="line">├── docs</span><br><span class="line">│   └── index.md</span><br><span class="line">└── mkdocs.yml</span><br></pre></td></tr></table></figure>
<p>我们将在<code>docs/docs</code>文件夹下放我们的文档源文件，这里是<code>.md</code>格式的。<code>mkdocs.yml</code>是MkDocs的配置文件。</p>
<p>我们在<code>docs/docs</code>文件夹下加入<code>intro.md</code>之后修改<code>mkdocs.yml</code>为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site_name: My Docs</span><br><span class="line">nav:</span><br><span class="line">    - Home: index.md</span><br><span class="line">    - Introduction: intro.md</span><br></pre></td></tr></table></figure>
<p>之后<code>mkdocs serve</code>就可以在打开本地服务，查看文档界面。调整合适之后即可<code>mkdocs build</code>生成html文件，位于<code>./docs/site</code>文件夹下。因为我们一般不把<code>site</code>目录加入Git(只用<code>docs/docs</code>下面的md文件就可以很好地追踪文档变化),所以将<code>docs/site</code>加入<code>.gitignore</code>之后再<code>add</code>, <code>commit</code>。(如果已经commit也可以用<code>git rm -r --cached docs/site</code>将其删除)</p>
<p>现在我们已经完成了库的开发和文档的本地生成。下面首先将项目发布到GitHub，然后发布文档，最后将整个库打包发布。</p>
<h3 id="项目发布到GitHub">项目发布到GitHub</h3>
<p>首先在Github新建项目<code>poetry-mkdocs-shenxzh</code>，之后复制仓库地址，执行<code>git remote add origin https://github.com/shenxiangzhuang/poetry-mkdocs-shenxzh.git</code>加入远程仓库地址。</p>
<h3 id="发布文档">发布文档</h3>
<p>在<code>./docs</code>文件夹下执行<code>mkdocs gh-deploy</code>，输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ mkdocs gh-deploy</span><br><span class="line">INFO    -  Cleaning site directory </span><br><span class="line">INFO    -  Building documentation to directory: /home/shensir/Documents/CS/MyPrograming/Python/poetry-mkdocs-shenxzh/docs/site </span><br><span class="line">INFO    -  Documentation built in 0.23 seconds </span><br><span class="line">WARNING -  Version check skipped: No version specified in previous deployment. </span><br><span class="line">INFO    -  Copying &#x27;/home/shensir/Documents/CS/MyPrograming/Python/poetry-mkdocs-shenxzh/docs/site&#x27; to &#x27;gh-pages&#x27; branch and pushing to GitHub. </span><br><span class="line">INFO    -  Your documentation should shortly be available at: https://shenxiangzhuang.github.io/poetry-mkdocs-shenxzh/ </span><br></pre></td></tr></table></figure>
<p>这里直接访问<code>https://shenxiangzhuang.github.io/poetry-mkdocs-shenxzh/ </code>即可查看文档了。(我们可以在https://github.com/shenxiangzhuang/poetry-mkdocs-shenxzh/settings 中看到，GitHub Page的站点建立在<code>gh-pages</code>分支(<code>mkdocs gh-deploy</code>帮我们自动创建的)的根目录下。</p>
<h3 id="发布库到PyPI">发布库到PyPI</h3>
<p>这里就是Poetry发挥作用的时候了，根目录执行<code>poetry build</code>把轮子造好（会自动创建<code>./dist</code>文件夹，然后将build好的文件放在这里）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ poetry build     </span><br><span class="line">Building poetry-mkdocs-shenxzh (0.1.0)</span><br><span class="line">  - Building sdist</span><br><span class="line">  - Built poetry-mkdocs-shenxzh-0.1.0.tar.gz</span><br><span class="line">  - Building wheel</span><br><span class="line">  - Built poetry_mkdocs_shenxzh-0.1.0-py3-none-any.whl</span><br></pre></td></tr></table></figure>
<p>之后执行<code>poetry publish</code>即可直接将库发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ poetry publish</span><br><span class="line"></span><br><span class="line">Username: IronSky</span><br><span class="line">Password: </span><br><span class="line">Publishing poetry-mkdocs-shenxzh (0.1.0) to PyPI</span><br><span class="line"> - Uploading poetry-mkdocs-shenxzh-0.1.0.tar.gz 100%</span><br><span class="line"> - Uploading poetry_mkdocs_shenxzh-0.1.0-py3-none-any.whl 100%</span><br></pre></td></tr></table></figure>
<p>此时登录https://pypi.org/manage/projects/即可看到发布的库，这时执行<code>pip install poetry-mkdocs-shenxzh</code>就可以安装了。因为我本地已经把默认源头换成了豆瓣源，所以需要<code>pip install poetry-mkdocs-shenxzh -i https://pypi.org/simple</code>才可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ pip install poetry-mkdocs-shenxzh -i https://pypi.org/simple</span><br><span class="line">Collecting poetry-mkdocs-shenxzh</span><br><span class="line">  Downloading poetry_mkdocs_shenxzh-0.1.0-py3-none-any.whl (1.4 kB)</span><br><span class="line">Installing collected packages: poetry-mkdocs-shenxzh</span><br><span class="line">Successfully installed poetry-mkdocs-shenxzh-0.1.0</span><br></pre></td></tr></table></figure>
<p>之后我们就可以使用我们自己写的库了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: from poetry_mkdocs_shenxzh.hello import Hello</span><br><span class="line"></span><br><span class="line">In [2]: h = Hello()</span><br><span class="line"></span><br><span class="line">In [3]: h.sayHello()</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<h3 id="后记">后记</h3>
<p>用MkDocs替换Sphinx其实有个问题,那就是没办法自动化生成API Doc，就是Python的Docstring不能直接生成文档。(暂时没找到好的插件可以做到这一点)</p>
<p>所以用MkDocs在不需要对源码做大量解释的情况下还是很方便的，如果要对源码做更多的介绍，可能还是Sphinx好一些？</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>IPython Tips</title>
    <url>/2018/03/08/IPython-Tips/</url>
    <content><![CDATA[<h3 id="Install-2">Install</h3>
<p>一直是Anaconda一起用的，直接就安装好了。当然不用Conda,也可以用Pip装上IPython,这里记录下常用的命令以备忘。</p>
<h3 id="Tips">Tips</h3>
<h4 id="“cmd”">“cmd”</h4>
<p>在IPython中，一些常见的Linux命令都是可以用的，如ls, cd这些。</p>
<h4 id="load-xxx-py">%load <a href="http://xxx.py">xxx.py</a></h4>
<p>载入文件中的变量，函数，类等。</p>
<h4 id="edit-xxx-py">edit <a href="http://xxx.py">xxx.py</a></h4>
<p>指定用于编辑的工具后（我这里用的Vim），可以直接编辑文件。之后保存退出，代码会自动执行。</p>
<h4 id="whos-del-reset">whos <a href="http://sofasofa.io/forum_main_post.php?postid=1000225">del %reset</a></h4>
<p>whos，查看当前环境下的所有全局变量。<br>
del x, 删除变量x<br>
%reset [-f], 删去所有变量</p>
<h4 id="function-name-function-name"><a href="https://stackoverflow.com/questions/1562759/can-python-print-a-function-definition">function_name? &amp; function_name??</a></h4>
<p>Use function_name? to get help, and function_name?? will print out the source.</p>
<h4 id="IPython-in-virtual-environment">IPython in virtual environment</h4>
<p>在用conda创建新的env后会发现无法使用对应版本的IPython,于是可以先在这个环境新安装一个IPython。，然后运行<code>hash -r</code>。如果不运行后面的命令会发现打开的IPython还是之前默认的版本。后者的作用就是<code>forget all remembered locations</code>，所以就可以了。</p>
<p><a href="https://howchoo.com/g/mgvizdexzje/how-to-make-ipython-work-in-a-virtualenv-virtual-environment">参考1</a>, <a href="https://askubuntu.com/questions/952137/what-does-hash-r-command-do">参考2</a></p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>IPython</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains Toolbox</title>
    <url>/2018/04/23/JetBrains-Toolbox/</url>
    <content><![CDATA[<h3 id="Overview-20">Overview</h3>
<p>JetBrains工具使用记录。</p>
<h4 id="JetBrains-Toolbox"><a href="https://www.jetbrains.com/toolbox/">JetBrains Toolbox</a></h4>
<p>今天才发现的工具，可以同时管理PyCharm,Clion这些JetBrains的东西，安装和更新都十分方便。</p>
<h4 id="Desktop-Entry">Desktop Entry</h4>
<p>安装后启动栏的Icon不能正常显示会只出现问号。</p>
<p>下面的方法可以方便地添加图标<br>
Tools -&gt; Create Destktop Entry…<br>
<a href="https://askubuntu.com/questions/391439/how-can-i-set-up-pycharm-to-launch-from-the-launcher">参考1</a></p>
<p>…<br>
2018/12/25更新…<br>
…</p>
<p>上面的方法在更新toolbox之后好像还是会出问题，参考<a href="https://youtrack.jetbrains.com/issue/IDEA-149703">这里</a>，看到:</p>
<blockquote>
<p>Derek Costroff: I had this issue and resolved it by removing the icon file extension from the desktop file. i.e “.svg” or “.png” whatever your case may be.</p>
</blockquote>
<p>于是，<code>mv '/usr/share/applications/jetbrains-pycharm.desktop' /home/shensir/Downloads/</code>其他<code>CLion</code>也一样操作就可以。这里并没有delete掉，暂时放起来，不知道后面会不会用到。</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>Julia in Ubuntu</title>
    <url>/2018/01/28/Julia-in-Ubuntu/</url>
    <content><![CDATA[<h4 id="Overview-21">Overview</h4>
<p>补上Jupyter三大将最后一个——Julia，目前每台有时间学了，先把环境搭建好。首先很简单的步骤安装好Julia，之后设置Jupyter上的kernel。最后是一些Atom里面的配置。</p>
<h4 id="Julia-installation">Julia installation</h4>
<p>Julia的安装及其简单，只需要到<a href="https://julialang.org/downloads/platform.html">官网</a>下载安装文件，之后一个软链接就可以了。之后在终端直接输入<code>julia</code>即可进入交互式界面！</p>
<h4 id="Julia-kernel">Julia kernel</h4>
<p>同样的，让Jupyter notebook支持Julia也是及其简单。在交互式界面直接输入<code>Pkg.add(&quot;IJulia&quot;)</code>同样是一行的事。之后在终端输入<code>jupyter notebook</code>，浏览器上就可以看到新添加的Julia的kernel了。</p>
<h4 id="Julia-in-Atom">Julia in Atom</h4>
<p>发现Atom一个叫<a href="https://atom.io/packages/hydrogen#plugins-for-hydrogen">hydrogen</a>的插件，很好地支持Jupyter的一套kernel，正在测试中。其提供了集成各种kernel的<a href="https://nteract.gitbooks.io/hydrogen/docs/Installation.html">文档</a></p>
]]></content>
      <categories>
        <category>Julia</category>
      </categories>
      <tags>
        <tag>Julia</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Lab&amp;Multi-Kernels</title>
    <url>/2018/03/21/Jupyter-Lab-Multi-Kernels/</url>
    <content><![CDATA[<h3 id="Overview-22">Overview</h3>
<p>前些时候看到Jupyter Lab，用了下，感觉特别好用。不仅包括原来的Jupyter Notebook，而且还有各种环境的Console。一开始只是安装了Jupyter最专注的三个Kernel:Julia, Python和R。最近想撸下Haskell做数据分析的东西，所以就把Haskell的Kernel装上了,顺便把Octave一块装上了。</p>
<h3 id="R-Kernel">R Kernel</h3>
<p>参考<a href="http://datahonor.com/2017/10/24/R-In-Jupyter/">R-In-Jupyter</a></p>
<h3 id="Haskell-Kernel">Haskell Kernel</h3>
<p>直接看到官方的<a href="https://github.com/gibiansky/IHaskell">Doc</a>,一开始执行<code>curl -sSL https://get.haskellstack.org/ | sh</code>的时候会提示用stack更新，但是我这里失败了，用了错误提示的另一种方法。后面安装基本没什么问题，虽然有一些Warning，但是没有影响。</p>
<p>之后<a href="http://nbviewer.jupyter.org/github/gibiansky/IHaskell/blob/master/notebooks/IHaskell.ipynb">测试</a>了下,很好用。帮助和提示依旧那么友好，另外还可以直接连到hoogle.</p>
<p>另外，它的<a href="https://github.com/gibiansky/IHaskell/wiki">wiki</a>提供了很多很Nice的Demo，以后有时间挑几个跑下。</p>
<p>＝＝＝＝更新＝＝＝＝<br>
最近使用IHaskell的时候，Kernel会直接死掉。后来看到在项目Github地址上README特别说明了这一点，就是GHC版本的问题。用<code>stack</code>单独新建项目就可以了。</p>
<p>另外，参考<a href="https://zhuanlan.zhihu.com/p/25005809">这里</a>设置了Stackage 镜像。</p>
<h3 id="Octave-Kernel">Octave Kernel</h3>
<p>也是按照<a href="https://github.com/calysto/octave_kernel">Doc</a>来的，由于之前装过Octave了，所以直接<code>pip install octave_kernel</code>就可以了。往后用计算器就比较方便了:P</p>
<p>最后，<code>jupyter lab</code>启动：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/Screenshot%20from%202018-03-21%2011-22-42.png" alt=""></p>
<h3 id="C-kernel">C kernel</h3>
<p>根据<a href="https://github.com/brendan-rius/jupyter-c-kernel">jupyter-c-kernel</a>安装即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install jupyter-c-kernel</span><br><span class="line">install_c_kernel --user</span><br></pre></td></tr></table></figure>
<p>第二条命令涉及权限问题，参考<a href="https://github.com/Calysto/matlab_kernel/issues/68"><strong>matlab_kernel</strong></a>中类似的问题，加上<code>--user</code>参数解决。</p>
<h1>删除多余的Kernel</h1>
<p>参考<a href="https://stackoverflow.com/questions/42635310/remove-kernel-on-jupyter-notebook">这里</a></p>
<p>先<code>jupyter kernelspec list</code>查看各个Kernel的安装路径，之后<code>jupyter kernelspec uninstall unwanted-kernel</code>删除不需要的Kernel即可。</p>
<h3 id="Reference-7">Reference</h3>
<p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels">Jupyter kernels</a><br>
<a href="https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernelspecs">Kernel specs</a></p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
        <tag>Octave</tag>
        <tag>R</tag>
        <tag>Haskell</tag>
        <tag>Julia</tag>
      </tags>
  </entry>
  <entry>
    <title>Oh, Jupyter!</title>
    <url>/2018/05/19/Jupyter-nbextensions/</url>
    <content><![CDATA[<h3 id="Jupyter-nbextensions">Jupyter nbextensions</h3>
<p>打算把<em>The Art of R programming</em>的东西整理到Jupyter notebook, 发现这里插入目录不太好搞，就找到了<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions">jupyter_contrib_nbextensions</a>,安装比较简单，而且功能真的很强大，不仅可以很好地支持目录，其他还包括一些很使用的拓展功能，比如打印执行时间，高亮标记文字等。</p>
<h3 id="Jupyter-themes">Jupyter themes</h3>
<p>为Jupyter添加样式主题，结合上面的拓展用起来就很顺手了。配置参考这里<a href="https://github.com/dunovank/jupyter-themes">Jupyter themes</a>.</p>
<p>另外，直接运行<code>jt -t grade3</code>设置主题是会把上面的工具栏给隐藏，而且调不出来。发现<a href="https://github.com/dunovank/jupyter-themes/issues/85">issue</a>已经被提出并解决了，只需要<code>jt -t grade3 -T</code>即可。</p>
<h3 id="Double-click-to-open-an-ipython-notebook">Double click to open an ipython notebook</h3>
<p>使用开源项目<a href="https://github.com/takluyver/nbopen">nbopen</a>实现双击打开<code>.ipynb</code>文件的功能。同时会给<code>.ipynb</code>文件创建一个Icon.</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>K-means clustering</title>
    <url>/2017/02/27/K-means-clustering/</url>
    <content><![CDATA[<p>K-means clustering的Python实现<br>
交流群不相识的朋友突然问我怎么手写K-means…于是腾出时间简单写下。</p>
<h5 id="Overview-23">Overview</h5>
<blockquote>
<p>k-平均算法源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘领域。k-平均聚类的目的是：把 n {\displaystyle n} n个点（可以是样本的一次观察或一个实例）划分到k个聚类中，使得每个点都属于离他最近的均值（此即聚类中心）对应的聚类，以之作为聚类的标准。这个问题将归结为一个把数据空间划分为Voronoi cells的问题。[wiki]</p>
</blockquote>
<h5 id="Theory-2">Theory</h5>
<p>关于算法的步骤也是参考的<a href="https://zh.wikipedia.org/wiki/K-%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95#.E7.AE.97.E6.B3.95.E6.8F.8F.E8.BF.B0">WIKI</a>，原理比较简单，不再重复叙述。<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-27%2022-21-23.png" alt=""></p>
<h5 id="Code-18">Code</h5>
<p>这里的实现有几个需要改进的地方，这里放在前面指出。</p>
<ul>
<li>[ ] 采用了循环，而不是向量化，矩阵化的运算</li>
<li>[ ] 收敛的判断，并没有按照分类是否恒定不变来判断收敛与否，而是以，所有质点新一次迭代前后空间距离的微小变化[自定义阀值]作为收敛的标准。[这里纯属个人想法，不知道是否有原则的错误0.0]</li>
</ul>
<blockquote>
<p>2017.03.01补充<br>
今天再次搜索K-means算法，看到<a href="http://wiki.swarma.net/index.php?title=K-means%E8%81%9A%E7%B1%BB&amp;variant=zh">集智百科</a>的关于次算法的介绍。恰好正是按照这种方法来判断算法的收敛。<br>
叙述是这样的<br>
<img src="http://olricxi00.bkt.clouddn.com/Screenshot%20from%202017-03-01%2012-59-38.png" alt=""><br>
可以看到下面算法收敛的判断准则就是质心的微小变化。[所以目前看来这样还是靠谱的0.0]<br>
但是呢，有些不太同意简介的开头：<br>
++ “K-means算法是很典型的基于距离的聚类算法，采用距离作为相似性的评价指标，即认为两个对象的距离越近，其相似度就越大。该算法认为簇是由距离靠近的对象组成的，因此把得到紧凑且独立的簇作为最终目标。”++<br>
这里还是参考WIK的说法：<br>
++“分配(Assignment)：将每个观测分配到聚类中，使得组内平方和（WCSS）达到最小。因为这一平方和就是平方后的欧氏距离，所以很直观地把观测分配到离它最近得均值点即可 [8] 。（数学上，这意味依照由这些均值点生成的Voronoi图来划分上述观测）。”++</p>
</blockquote>
<p>这里测试的data来自于那位朋友的题目，比较简单，见代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdata</span>():</span><br><span class="line">    x = np.array([[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)])</span><br><span class="line">    y = np.array([[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">51</span>, <span class="number">151</span>)])</span><br><span class="line">    data = np.hstack((x, y))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取两点间的距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdis</span>(<span class="params">px, py</span>):</span><br><span class="line">    dims = <span class="built_in">len</span>(px)</span><br><span class="line">    <span class="comment"># dist = np.sqrt(((px[0]-py[0])**2)+(px[1]-py[1])**2)</span></span><br><span class="line">    dist = np.sqrt(np.<span class="built_in">sum</span>(((px[i] - py[i]) ** <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dims)))</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于首次随机获取质点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getrandmeans</span>(<span class="params">data, n</span>):</span><br><span class="line">    means = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x0 = random.choice(data)</span><br><span class="line">        means.append(x0)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Random: &#x27;</span>, means)</span><br><span class="line">    <span class="keyword">return</span> means</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归，重复计算所属类别，至收敛</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getclass</span>(<span class="params">data, means</span>):</span><br><span class="line">    classx = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(means)):</span><br><span class="line">        classx[<span class="built_in">str</span>(k)] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        p0 = data[i]</span><br><span class="line">        dists = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(means)):</span><br><span class="line">            dist = getdis(p0, means[k])</span><br><span class="line">            dists.append(dist)</span><br><span class="line">        maxdist = <span class="built_in">max</span>(dists)</span><br><span class="line">        class_p0 = [i <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(dists) <span class="keyword">if</span> j==maxdist ][<span class="number">0</span>]</span><br><span class="line">        classx[<span class="built_in">str</span>(class_p0)].append(p0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(means)</span></span><br><span class="line">    newmeans = getnewmeans(classx)</span><br><span class="line">    <span class="comment"># 这里我们并未按照所属类别是否收敛，而后所得质心各维度的距离是否足够小</span></span><br><span class="line">    dists_of_means = getdis(np.sort(means, <span class="number">0</span>),  np.sort(newmeans, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;alculating...&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>(dists_of_means &gt; <span class="number">0.001</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;complete!&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;求得的最优质点为: &#x27;</span>, means)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;各维度的距离为: &#x27;</span>, dists_of_means)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;最终聚类结果为: &#x27;</span>, classx)</span><br><span class="line">        <span class="keyword">return</span> classx</span><br><span class="line"></span><br><span class="line">    newclassx = getclass(data, newmeans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newclassx</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getnewmeans</span>(<span class="params">classx</span>):</span><br><span class="line">    classes = <span class="built_in">list</span>(classx.keys())</span><br><span class="line">    means = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classx))]</span><br><span class="line">    <span class="keyword">for</span> class0 <span class="keyword">in</span> classes:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(classx[class0]) != <span class="number">0</span>:</span><br><span class="line">            points = np.vstack(classx[class0])</span><br><span class="line">            x = np.mean(points[:, <span class="number">0</span>])</span><br><span class="line">            y = np.mean(points[:, <span class="number">1</span>])</span><br><span class="line">            means[<span class="built_in">int</span>(class0)] = np.array([x, y])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;WARNING: 极大可能存在一个多余的质点!&#x27;</span>)</span><br><span class="line">            means[<span class="built_in">int</span>(class0)] = np.array([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> means</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotdata</span>(<span class="params">classx</span>):</span><br><span class="line">    plt.figure()</span><br><span class="line">    classes = classx.keys()</span><br><span class="line">    color = [<span class="string">&#x27;ro&#x27;</span>, <span class="string">&#x27;bo&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> class0 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes)):</span><br><span class="line">        points = np.vstack(classx[<span class="built_in">str</span>(class0)])</span><br><span class="line">        <span class="comment"># print(points)</span></span><br><span class="line">        plt.plot(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], color[class0])</span><br><span class="line">        <span class="comment"># print(&#x27;=========================&#x27;)</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    data = getdata()</span><br><span class="line">    <span class="comment">#print(data)</span></span><br><span class="line">    dist = getdis(data[<span class="number">0</span>], data[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#print(dist)</span></span><br><span class="line">    means = getrandmeans(data, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">#print(means)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(classx)</span></span><br><span class="line">    classx = getclass(data, means)</span><br><span class="line">    plotdata(classx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Random:  [array([ 85, 135]), array([ 92, 142])]<br>
alculating…<br>
alculating…<br>
alculating…<br>
alculating…<br>
alculating…<br>
alculating…<br>
alculating…<br>
alculating…<br>
complete!<br>
求得的最优质点为:  [array([  75.5,  125.5]), array([ 25.5,  75.5])]<br>
各维度的距离为:  [ 0.  0.]<br>
最终聚类结果为:  {‘1’: [array([ 51, 101]), array([ 52, 102]), array([ 53, 103]), array([ 54, 104]),array([ 55, 105]), … , array([46, 96]), array([47, 97]), array([48, 98]), array([49, 99]), array([ 50, 100])]}</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-03-03%2001-38-15.png" alt=""></p>
<h5 id="Supplement-2">Supplement</h5>
<p>关于上面的实现，开始时发现，每次运行作出来的图竟然不一样…调试发现时递归那里的问题。<br>
就是关于return的问题，这里内部的return只是起到终止递归的作用，返回的是外面的return。抽象出来，类似下面这种<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-27%2022-39-10.png" alt=""></p>
<p>后面有时间会再针对上面的问题进行改进。</p>
<h5 id="Reference-8">Reference</h5>
<p><a href="https://zh.wikipedia.org/wiki/K-%E5%B9%B3%E5%9D%87%E7%AE%97%E6%B3%95#.E7.AE.97.E6.B3.95.E6.8F.8F.E8.BF.B0">WIKI</a><br>
<a href="http://stackoverflow.com/questions/3989016/how-to-find-all-positions-of-the-maximum-value-in-a-list">StackOverflow</a><br>
<a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/20/k-means.html">CodingLabs</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle: Human Resources Analytics</title>
    <url>/2017/02/25/Kaggle-Human-Resources-Analytics/</url>
    <content><![CDATA[<h5 id="Introduce">Introduce</h5>
<p>这是新年定下的目标之一 —— Kaggle案例的学习<br>
这里，数据即来自<a href="https://www.kaggle.com/ludobenistant/hr-analytics">Human Resources Analytics</a>， 参考<a href="https://www.kaggle.com/nirajvermafcb/d/ludobenistant/hr-analytics/principal-component-analysis-explained">这里</a>学习数据的分析.</p>
<h5 id="Overview-24">Overview</h5>
<p>这个kernel里面呢，大部分还是比较常规的EDA，可视化和简单算法的应用，但是也有要学习的地方，这里在代码里面都有声明。</p>
<blockquote>
<p>[学习heatmap使用]<br>
[学习plt.barh使用]<br>
[学习如下reindex的步骤]<br>
[学习iloc使用]<br>
[学习使用sklearn进行标准化]<br>
[掌握手动计算协方差]<br>
[学习使用Numpy简单的线性代数的运算]<br>
[学习使用sklearn做PCA]</p>
</blockquote>
<h5 id="Code-19">Code</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Sat Feb 25 07:48:50 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: shen</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 人力资源——离职分析</span></span><br><span class="line"><span class="comment"># 采用PCA</span></span><br><span class="line"><span class="comment"># 参考https://www.kaggle.com/nirajvermafcb/d/ludobenistant/hr-analytics/principal-component-analysis-explained</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># data rocessing</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line"><span class="comment"># https://www.kaggle.com/nirajvermafcb/d/ludobenistant/hr-analytics/principal-component-analysis-explained</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;/home/shen/PycharmProjects/MyPython/Kaggle/human resources/data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 了解数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">df.columns.tolist() fetches all the columns and </span></span><br><span class="line"><span class="string">then convert it into list type.This step is just </span></span><br><span class="line"><span class="string">to check out all the column names in our data.Columns </span></span><br><span class="line"><span class="string">are also called as features of our datasets.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">columns_names = df.columns.tolist()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.shape)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值型变量的协方差矩阵</span></span><br><span class="line"><span class="built_in">print</span>(df.corr())</span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习heatmap使用]</span></span><br><span class="line"><span class="comment"># 协方差矩阵的可视化</span></span><br><span class="line">correlation = df.corr()</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">sns.heatmap(correlation, vmax=<span class="number">1</span>, square=<span class="literal">True</span>, annot=<span class="literal">True</span>, cmap=<span class="string">&#x27;cubehelix&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Correlation between diffrent features&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 职位</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;sales&#x27;</span>].unique())</span><br><span class="line"></span><br><span class="line">groupby_sales = df.groupby(<span class="string">&#x27;sales&#x27;</span>).mean()</span><br><span class="line"></span><br><span class="line">IT=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].IT</span><br><span class="line">RandD=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].RandD</span><br><span class="line">accounting=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].accounting</span><br><span class="line">hr=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].hr</span><br><span class="line">management=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].management</span><br><span class="line">marketing=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].marketing</span><br><span class="line">product_mng=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].product_mng</span><br><span class="line">sales=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].sales</span><br><span class="line">support=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].support</span><br><span class="line">technical=groupby_sales[<span class="string">&#x27;satisfaction_level&#x27;</span>].technical</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习plt.barh使用]</span></span><br><span class="line">department_name = df[<span class="string">&#x27;sales&#x27;</span>].unique()</span><br><span class="line">department=(sales, accounting, hr, technical, support, management,</span><br><span class="line">       IT, product_mng, marketing, RandD)</span><br><span class="line"></span><br><span class="line">y_pos = np.arange(<span class="built_in">len</span>(department))</span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">plt.barh(y_pos, department, align=<span class="string">&#x27;center&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.yticks(y_pos, department_name)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Satisfaction level&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Mean Satisfaction Level of each department&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PCA</span></span><br><span class="line"><span class="comment"># 去除非数值型的变量(feature)</span></span><br><span class="line"><span class="built_in">print</span>(df.dtypes)</span><br><span class="line">df_drop = df.drop(labels=[<span class="string">&#x27;sales&#x27;</span>, <span class="string">&#x27;salary&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df_drop.dtypes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习如下reindex的步骤]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Here we are converting columns of the dataframe to list </span></span><br><span class="line"><span class="string">so it would be easier for us to reshuffle the columns.</span></span><br><span class="line"><span class="string">We are going to use cols.insert method</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">cols = df_drop.columns.tolist()</span><br><span class="line">cols.insert(<span class="number">0</span>, cols.pop(cols.index(<span class="string">&#x27;left&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">df_drop = df_drop.reindex(columns= cols)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习iloc使用]</span></span><br><span class="line"><span class="comment"># 索引分离数据</span></span><br><span class="line">X = df_drop.iloc[:, <span class="number">1</span>:<span class="number">8</span>].values</span><br><span class="line">y = df_drop.iloc[:, <span class="number">0</span>].values</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.shape(X))</span><br><span class="line"><span class="built_in">print</span>(np.shape(y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习使用sklearn进行标准化]</span></span><br><span class="line"><span class="comment"># 数据的标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">X_std = StandardScaler().fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [掌握手动计算协方差]</span></span><br><span class="line"><span class="comment"># 计算协方差矩阵</span></span><br><span class="line">mean_vec = np.mean(X_std, axis=<span class="number">0</span>)</span><br><span class="line">cov_mat = (X_std - mean_vec).T.dot((X_std - mean_vec)) / (X_std.shape[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># another way --&gt; np.cov</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;NumPy covariance matrix: \n%s&#x27;</span> %np.cov(X_std.T))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">sns.heatmap(cov_mat, vmax=<span class="number">1</span>, square=<span class="literal">True</span>,annot=<span class="literal">True</span>,cmap=<span class="string">&#x27;cubehelix&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Correlation between different features&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习使用Numpy简单的线性代数的运算]</span></span><br><span class="line"><span class="comment"># 计算特征值与特征向量</span></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(cov_mat)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Eigenvectors \n%s&#x27;</span> %eig_vecs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nEigenvalues \n%s&#x27;</span> %eig_vals)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a list of (eigenvalue, eigenvector) tuples</span></span><br><span class="line">eig_pairs = [(np.<span class="built_in">abs</span>(eig_vals[i]), eig_vecs[:,i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(eig_vals))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sort the (eigenvalue, eigenvector) tuples from high to low</span></span><br><span class="line">eig_pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visually confirm that the list is correctly sorted by decreasing eigenvalues</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Eigenvalues in descending order:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eig_pairs:</span><br><span class="line">    <span class="built_in">print</span>(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Explained Variance</span></span><br><span class="line">tot = <span class="built_in">sum</span>(eig_vals)</span><br><span class="line">var_exp = [(i / tot)*<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(eig_vals, reverse=<span class="literal">True</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> plt.style.context(<span class="string">&#x27;ggplot&#x27;</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    plt.bar(<span class="built_in">range</span>(<span class="number">7</span>), var_exp, alpha=<span class="number">0.5</span>, align=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">            label=<span class="string">&#x27;individual explained variance&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Explained variance ratio&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Principal components&#x27;</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Projection matrix</span></span><br><span class="line"><span class="comment"># [假设前两个主成分占Explain Variance 的90%]选取前两个变量，构成Projection matrix</span></span><br><span class="line">matrix_w = np.hstack((eig_pairs[<span class="number">0</span>][<span class="number">1</span>].reshape(<span class="number">7</span>,<span class="number">1</span>), </span><br><span class="line">                      eig_pairs[<span class="number">1</span>][<span class="number">1</span>].reshape(<span class="number">7</span>,<span class="number">1</span>)</span><br><span class="line">                    ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Matrix W:\n&#x27;</span>, matrix_w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Projection Onto the New Feature Space</span></span><br><span class="line">Y = X_std.dot(matrix_w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [学习使用sklearn做PCA]</span></span><br><span class="line"><span class="comment"># PCA in scikit-learn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca = PCA().fit(X_std)</span><br><span class="line">plt.plot(np.cumsum(pca.explained_variance_ratio_))</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of components&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Cumulativa explained variance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA </span><br><span class="line">sklearn_pca = PCA(n_components=<span class="number">6</span>)</span><br><span class="line">Y_sklearn = sklearn_pca.fit_transform(X_std)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Y_sklearn.shape)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Supplement-3">Supplement</h5>
<p>补充下sns.heatmap的使用</p>
<blockquote>
<p>heatmap(data, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt=‘.2g’, annot_kws=None, linewidths=0, linecolor=‘white’, cbar=True, cbar_kws=None, cbar_ax=None, square=False, ax=None, xticklabels=True, yticklabels=True, mask=None, **kwargs)</p>
</blockquote>
<blockquote>
<p>Plot rectangular data as a color-encoded matrix.</p>
</blockquote>
<blockquote>
<p>This function tries to infer a good colormap to use from the data, but<br>
this is not guaranteed to work, so take care to make sure the kind of<br>
colormap (sequential or diverging) and its limits are appropriate.</p>
</blockquote>
<blockquote>
<p>This is an Axes-level function and will draw the heatmap into the<br>
currently-active Axes if none is provided to the <code>ax</code> argument.  Part of<br>
this Axes space will be taken and used to plot a colormap, unless <code>cbar</code><br>
is False or a separate Axes is provided to <code>cbar_ax</code>.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">flights = sns.load_dataset(<span class="string">&quot;flights&quot;</span>)</span><br><span class="line">flights = flights.pivot(<span class="string">&quot;month&quot;</span>, <span class="string">&quot;year&quot;</span>, <span class="string">&quot;passengers&quot;</span>)</span><br><span class="line">ax = sns.heatmap(flights, linewidth=<span class="number">.5</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-25%2010-22-47.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">flights = sns.load_dataset(<span class="string">&quot;flights&quot;</span>)</span><br><span class="line">flights = flights.pivot(<span class="string">&quot;month&quot;</span>, <span class="string">&quot;year&quot;</span>, <span class="string">&quot;passengers&quot;</span>)</span><br><span class="line">ax = sns.heatmap(flights, center=flights.loc[<span class="string">&quot;January&quot;</span>, <span class="number">1955</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-02-25%2010-26-23.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle——A Journey through Titanic[Python]</title>
    <url>/2017/03/02/Kaggle%E2%80%94%E2%80%94A-Journey-through-Titanic-Python/</url>
    <content><![CDATA[<p>Kaggle案例一——Titanic——Python分析与预测</p>
<blockquote>
<p>非原创，目前本站Kaggle案例均来自Kaggle官网发布的kernel，这里摘抄下来学习借鉴。</p>
</blockquote>
<h5 id="数据变量描述">数据变量描述</h5>
<blockquote>
<p>VARIABLE DESCRIPTIONS:<br>
survival        Survival<br>
(0 = No; 1 = Yes)<br>
pclass          Passenger Class<br>
(1 = 1st; 2 = 2nd; 3 = 3rd)<br>
name            Name<br>
sex             Sex<br>
age             Age<br>
sibsp           Number of Siblings/Spouses Aboard<br>
parch           Number of Parents/Children Aboard<br>
ticket          Ticket Number<br>
fare            Passenger Fare<br>
cabin           Cabin<br>
embarked        Port of Embarkation<br>
(C = Cherbourg; Q = Queenstown; S = Southampton)</p>
</blockquote>
<blockquote>
<p>SPECIAL NOTES:<br>
Pclass is a proxy for socio-economic status (SES)<br>
1st ~ Upper; 2nd ~ Middle; 3rd ~ Lower</p>
</blockquote>
<blockquote>
<p>Age is in Years; Fractional if Age less than One (1)<br>
If the Age is Estimated, it is in the form xx.5</p>
</blockquote>
<blockquote>
<p>With respect to the family relation variables (i.e. sibsp and parch)<br>
some relations were ignored.  The following are the definitions used<br>
for sibsp and parch.</p>
</blockquote>
<blockquote>
<p>Sibling:  Brother, Sister, Stepbrother, or Stepsister of Passenger Aboard Titanic<br>
Spouse:   Husband or Wife of Passenger Aboard Titanic (Mistresses and Fiances Ignored)<br>
Parent:   Mother or Father of Passenger Aboard Titanic<br>
Child:    Son, Daughter, Stepson, or Stepdaughter of Passenger Aboard Titanic</p>
</blockquote>
<blockquote>
<p>Other family relatives excluded from this study include cousins,<br>
nephews/nieces, aunts/uncles, and in-laws.  Some children travelled<br>
only with a nanny, therefore parch=0 for them.  As well, some<br>
travelled with very close friends or neighbors in a village, however,<br>
the definitions do not support such relations.</p>
</blockquote>
<h5 id="数据分析">数据分析</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Imports</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series,DataFrame</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy, matplotlib, seaborn</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment"># 设置seaborn默认的绘图样式</span></span><br><span class="line">sns.set_style(<span class="string">&#x27;whitegrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC, LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于sns.set_style(‘whitegrid’):<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/1.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># get titanic &amp; test csv files as a DataFrame</span></span><br><span class="line"><span class="comment"># 获取训练和待预测的数据，导入为DF</span></span><br><span class="line">titanic_df = pd.read_csv(<span class="string">&quot;/home/shen/PycharmProjects/MyPython/Kaggle/Titanic/train.csv&quot;</span>)</span><br><span class="line">test_df    = pd.read_csv(<span class="string">&quot;/home/shen/PycharmProjects/MyPython/Kaggle/Titanic/test.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># preview the data</span></span><br><span class="line"><span class="comment"># 预览数据</span></span><br><span class="line">titanic_df.head()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/2.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">titanic_df.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line">test_df.info()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/3.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/4.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># drop unnecessary columns, these columns won&#x27;t be useful in analysis and prediction</span></span><br><span class="line"><span class="comment"># 去除一些无用的列，这种  关注数据的核心信息   在之后还能看到</span></span><br><span class="line"></span><br><span class="line">titanic_df = titanic_df.drop([<span class="string">&#x27;PassengerId&#x27;</span>,<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Ticket&#x27;</span>], axis=<span class="number">1</span>)  <span class="comment"># axis=1,代表列</span></span><br><span class="line">test_df    = test_df.drop([<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Ticket&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Embarked</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># only in titanic_df, fill the two missing values with the most occurred value, which is &quot;S&quot;.</span></span><br><span class="line"><span class="comment"># 少量非数值缺失值处理的一种方法--&gt;用出现最多的观测值填充</span></span><br><span class="line">titanic_df[<span class="string">&quot;Embarked&quot;</span>] = titanic_df[<span class="string">&quot;Embarked&quot;</span>].fillna(<span class="string">&quot;S&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">sns.factorplot(<span class="string">&#x27;Embarked&#x27;</span>,<span class="string">&#x27;Survived&#x27;</span>, data=titanic_df,size=<span class="number">4</span>,aspect=<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/5.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fig, (axis1,axis2,axis3) = plt.subplots(<span class="number">1</span>,<span class="number">3</span>,figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.factorplot(&#x27;Embarked&#x27;,data=titanic_df,kind=&#x27;count&#x27;,order=[&#x27;S&#x27;,&#x27;C&#x27;,&#x27;Q&#x27;],ax=axis1)</span></span><br><span class="line"><span class="comment"># sns.factorplot(&#x27;Survived&#x27;,hue=&quot;Embarked&quot;,data=titanic_df,kind=&#x27;count&#x27;,order=[1,0],ax=axis2)</span></span><br><span class="line">sns.countplot(x=<span class="string">&#x27;Embarked&#x27;</span>, data=titanic_df, ax=axis1)</span><br><span class="line">sns.countplot(x=<span class="string">&#x27;Survived&#x27;</span>, hue=<span class="string">&quot;Embarked&quot;</span>, data=titanic_df, order=[<span class="number">1</span>,<span class="number">0</span>], ax=axis2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># group by embarked, and get the mean for survived passengers for each value in Embarked</span></span><br><span class="line">embark_perc = titanic_df[[<span class="string">&quot;Embarked&quot;</span>, <span class="string">&quot;Survived&quot;</span>]].groupby([<span class="string">&#x27;Embarked&#x27;</span>],as_index=<span class="literal">False</span>).mean()</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Embarked&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, data=embark_perc,order=[<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>],ax=axis3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Either to consider Embarked column in predictions,</span></span><br><span class="line"><span class="comment"># and remove &quot;S&quot; dummy variable, </span></span><br><span class="line"><span class="comment"># and leave &quot;C&quot; &amp; &quot;Q&quot;, since they seem to have a good rate for Survival.</span></span><br><span class="line"><span class="comment"># 观察到&quot;C&quot;, &quot;Q&quot;相比“S”有较高的生存率，所以我们删除S列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OR, don&#x27;t create dummy variables for Embarked column, just drop it, </span></span><br><span class="line"><span class="comment"># because logically, Embarked doesn&#x27;t seem to be useful in prediction.</span></span><br><span class="line"><span class="comment"># 或者我们可以直接删除Embarked这一列，它对预测无太大影响</span></span><br><span class="line"></span><br><span class="line">embark_dummies_titanic  = pd.get_dummies(titanic_df[<span class="string">&#x27;Embarked&#x27;</span>])</span><br><span class="line">embark_dummies_titanic.drop([<span class="string">&#x27;S&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">embark_dummies_test  = pd.get_dummies(test_df[<span class="string">&#x27;Embarked&#x27;</span>])</span><br><span class="line">embark_dummies_test.drop([<span class="string">&#x27;S&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic_df = titanic_df.join(embark_dummies_titanic)</span><br><span class="line">test_df    = test_df.join(embark_dummies_test)</span><br><span class="line"></span><br><span class="line">titanic_df.drop([<span class="string">&#x27;Embarked&#x27;</span>], axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.drop([<span class="string">&#x27;Embarked&#x27;</span>], axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fare</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># only for test_df, since there is a missing &quot;Fare&quot; values</span></span><br><span class="line"><span class="comment"># 少量数值型缺失值的处理方法--&gt;中位数填充</span></span><br><span class="line">test_df[<span class="string">&quot;Fare&quot;</span>].fillna(test_df[<span class="string">&quot;Fare&quot;</span>].median(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert from float to int</span></span><br><span class="line"><span class="comment"># 数据类型的转换</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Fare&#x27;</span>] = titanic_df[<span class="string">&#x27;Fare&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">test_df[<span class="string">&#x27;Fare&#x27;</span>]    = test_df[<span class="string">&#x27;Fare&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get fare for survived &amp; didn&#x27;t survive passengers</span></span><br><span class="line"><span class="comment"># 数据分类</span></span><br><span class="line">fare_not_survived = titanic_df[<span class="string">&quot;Fare&quot;</span>][titanic_df[<span class="string">&quot;Survived&quot;</span>] == <span class="number">0</span>]</span><br><span class="line">fare_survived     = titanic_df[<span class="string">&quot;Fare&quot;</span>][titanic_df[<span class="string">&quot;Survived&quot;</span>] == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get average and std for fare of survived/not survived passengers</span></span><br><span class="line"><span class="comment"># 获取典型统计量，更好地描述和观察数据</span></span><br><span class="line">avgerage_fare = DataFrame([fare_not_survived.mean(), fare_survived.mean()])</span><br><span class="line">std_fare      = DataFrame([fare_not_survived.std(), fare_survived.std()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Fare&#x27;</span>].plot(kind=<span class="string">&#x27;hist&#x27;</span>, figsize=(<span class="number">15</span>,<span class="number">3</span>),bins=<span class="number">100</span>, xlim=(<span class="number">0</span>,<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">avgerage_fare.index.names = std_fare.index.names = [<span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">avgerage_fare.plot(yerr=std_fare,kind=<span class="string">&#x27;bar&#x27;</span>,legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/7.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/8.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Age </span></span><br><span class="line"></span><br><span class="line">fig, (axis1,axis2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">15</span>,<span class="number">4</span>))</span><br><span class="line">axis1.set_title(<span class="string">&#x27;Original Age values - Titanic&#x27;</span>)</span><br><span class="line">axis2.set_title(<span class="string">&#x27;New Age values - Titanic&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># axis3.set_title(&#x27;Original Age values - Test&#x27;)</span></span><br><span class="line"><span class="comment"># axis4.set_title(&#x27;New Age values - Test&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get average, std, and number of NaN values in titanic_df</span></span><br><span class="line"><span class="comment"># 训练集中年龄的统计量的获取</span></span><br><span class="line">average_age_titanic   = titanic_df[<span class="string">&quot;Age&quot;</span>].mean()</span><br><span class="line">std_age_titanic       = titanic_df[<span class="string">&quot;Age&quot;</span>].std()</span><br><span class="line">count_nan_age_titanic = titanic_df[<span class="string">&quot;Age&quot;</span>].isnull().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get average, std, and number of NaN values in test_df</span></span><br><span class="line"><span class="comment"># 测试集中年龄的统计量的获取</span></span><br><span class="line"></span><br><span class="line">average_age_test   = test_df[<span class="string">&quot;Age&quot;</span>].mean()</span><br><span class="line">std_age_test       = test_df[<span class="string">&quot;Age&quot;</span>].std()</span><br><span class="line">count_nan_age_test = test_df[<span class="string">&quot;Age&quot;</span>].isnull().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate random numbers between (mean - std) &amp; (mean + std)</span></span><br><span class="line"><span class="comment"># 随机获取在均值的一倍标准差内的数据，用于填充大量的数值型缺失值</span></span><br><span class="line">rand_1 = np.random.randint(average_age_titanic - std_age_titanic, average_age_titanic + std_age_titanic, size = count_nan_age_titanic)</span><br><span class="line">rand_2 = np.random.randint(average_age_test - std_age_test, average_age_test + std_age_test, size = count_nan_age_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot original Age values</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> drop all null values, and convert to int</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Age&#x27;</span>].dropna().astype(<span class="built_in">int</span>).hist(bins=<span class="number">70</span>, ax=axis1)</span><br><span class="line"><span class="comment"># test_df[&#x27;Age&#x27;].dropna().astype(int).hist(bins=70, ax=axis1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fill NaN values in Age column with random values generated</span></span><br><span class="line"><span class="comment"># 经典的方法，通过布尔值过滤得到想要的“条件数据”</span></span><br><span class="line">titanic_df[<span class="string">&quot;Age&quot;</span>][np.isnan(titanic_df[<span class="string">&quot;Age&quot;</span>])] = rand_1</span><br><span class="line">test_df[<span class="string">&quot;Age&quot;</span>][np.isnan(test_df[<span class="string">&quot;Age&quot;</span>])] = rand_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert from float to int</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Age&#x27;</span>] = titanic_df[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">test_df[<span class="string">&#x27;Age&#x27;</span>]    = test_df[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot new Age Values</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Age&#x27;</span>].hist(bins=<span class="number">70</span>, ax=axis2)</span><br><span class="line"><span class="comment"># test_df[&#x27;Age&#x27;].hist(bins=70, ax=axis4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/9.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># .... continue with plot Age column</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># peaks for survived/not survived passengers by their age</span></span><br><span class="line">facet = sns.FacetGrid(titanic_df, hue=<span class="string">&quot;Survived&quot;</span>,aspect=<span class="number">4</span>)  <span class="comment"># aspect=4 长宽比4:1</span></span><br><span class="line">facet.<span class="built_in">map</span>(sns.kdeplot,<span class="string">&#x27;Age&#x27;</span>,shade= <span class="literal">True</span>)</span><br><span class="line">facet.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, titanic_df[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">max</span>()))</span><br><span class="line">facet.add_legend()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/10.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># average survived passengers by age</span></span><br><span class="line">fig, axis1 = plt.subplots(<span class="number">1</span>,<span class="number">1</span>,figsize=(<span class="number">18</span>,<span class="number">4</span>))</span><br><span class="line">average_age = titanic_df[[<span class="string">&quot;Age&quot;</span>, <span class="string">&quot;Survived&quot;</span>]].groupby([<span class="string">&#x27;Age&#x27;</span>],as_index=<span class="literal">False</span>).mean()</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Age&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, data=average_age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/11.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Cabin</span></span><br><span class="line"><span class="comment"># It has a lot of NaN values, so it won&#x27;t cause a remarkable impact on prediction</span></span><br><span class="line"><span class="comment"># 这里也是要学习的地方，对于含有大量缺失值，并且对预测无太大影响时，可以直接将其移除</span></span><br><span class="line">titanic_df.drop(<span class="string">&quot;Cabin&quot;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.drop(<span class="string">&quot;Cabin&quot;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习的地方，化繁为简，找到关注的重点为是否有家人，而不是具体的父母兄弟等</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Family&#x27;</span>] =  titanic_df[<span class="string">&quot;Parch&quot;</span>] + titanic_df[<span class="string">&quot;SibSp&quot;</span>]</span><br><span class="line">titanic_df[<span class="string">&#x27;Family&#x27;</span>].loc[titanic_df[<span class="string">&#x27;Family&#x27;</span>] &gt; <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Family&#x27;</span>].loc[titanic_df[<span class="string">&#x27;Family&#x27;</span>] == <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># 测试集和训练集作相同处理</span></span><br><span class="line">test_df[<span class="string">&#x27;Family&#x27;</span>] =  test_df[<span class="string">&quot;Parch&quot;</span>] + test_df[<span class="string">&quot;SibSp&quot;</span>]</span><br><span class="line">test_df[<span class="string">&#x27;Family&#x27;</span>].loc[test_df[<span class="string">&#x27;Family&#x27;</span>] &gt; <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">test_df[<span class="string">&#x27;Family&#x27;</span>].loc[test_df[<span class="string">&#x27;Family&#x27;</span>] == <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># drop Parch &amp; SibSp</span></span><br><span class="line">titanic_df = titanic_df.drop([<span class="string">&#x27;SibSp&#x27;</span>,<span class="string">&#x27;Parch&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">test_df    = test_df.drop([<span class="string">&#x27;SibSp&#x27;</span>,<span class="string">&#x27;Parch&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">fig, (axis1,axis2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,sharex=<span class="literal">True</span>,figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.factorplot(&#x27;Family&#x27;,data=titanic_df,kind=&#x27;count&#x27;,ax=axis1)</span></span><br><span class="line">sns.countplot(x=<span class="string">&#x27;Family&#x27;</span>, data=titanic_df, order=[<span class="number">1</span>,<span class="number">0</span>], ax=axis1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># average of survived for those who had/didn&#x27;t have any family member</span></span><br><span class="line">family_perc = titanic_df[[<span class="string">&quot;Family&quot;</span>, <span class="string">&quot;Survived&quot;</span>]].groupby([<span class="string">&#x27;Family&#x27;</span>],as_index=<span class="literal">False</span>).mean()</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Family&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, data=family_perc, order=[<span class="number">1</span>,<span class="number">0</span>], ax=axis2)</span><br><span class="line"></span><br><span class="line">axis1.set_xticklabels([<span class="string">&quot;With Family&quot;</span>,<span class="string">&quot;Alone&quot;</span>], rotation=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/12.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># As we see, children(age &lt; ~16) on aboard seem to have a high chances for Survival.</span></span><br><span class="line"><span class="comment"># So, we can classify passengers as males, females, and child</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_person</span>(<span class="params">passenger</span>):</span><br><span class="line">    age,sex = passenger</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;child&#x27;</span> <span class="keyword">if</span> age &lt; <span class="number">16</span> <span class="keyword">else</span> sex</span><br><span class="line"></span><br><span class="line">titanic_df[<span class="string">&#x27;Person&#x27;</span>] = titanic_df[[<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>]].apply(get_person,axis=<span class="number">1</span>)</span><br><span class="line">test_df[<span class="string">&#x27;Person&#x27;</span>]    = test_df[[<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>]].apply(get_person,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># No need to use Sex column since we created Person column</span></span><br><span class="line">titanic_df.drop([<span class="string">&#x27;Sex&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.drop([<span class="string">&#x27;Sex&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dummy variables for Person column, &amp; drop Male as it has the lowest average of survived passengers</span></span><br><span class="line">person_dummies_titanic  = pd.get_dummies(titanic_df[<span class="string">&#x27;Person&#x27;</span>])</span><br><span class="line">person_dummies_titanic.columns = [<span class="string">&#x27;Child&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">person_dummies_titanic.drop([<span class="string">&#x27;Male&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">person_dummies_test  = pd.get_dummies(test_df[<span class="string">&#x27;Person&#x27;</span>])</span><br><span class="line">person_dummies_test.columns = [<span class="string">&#x27;Child&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line">person_dummies_test.drop([<span class="string">&#x27;Male&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic_df = titanic_df.join(person_dummies_titanic)</span><br><span class="line">test_df    = test_df.join(person_dummies_test)</span><br><span class="line"></span><br><span class="line">fig, (axis1,axis2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.factorplot(&#x27;Person&#x27;,data=titanic_df,kind=&#x27;count&#x27;,ax=axis1)</span></span><br><span class="line">sns.countplot(x=<span class="string">&#x27;Person&#x27;</span>, data=titanic_df, ax=axis1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># average of survived for each Person(male, female, or child)</span></span><br><span class="line">person_perc = titanic_df[[<span class="string">&quot;Person&quot;</span>, <span class="string">&quot;Survived&quot;</span>]].groupby([<span class="string">&#x27;Person&#x27;</span>],as_index=<span class="literal">False</span>).mean()</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Person&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, data=person_perc, ax=axis2, order=[<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;child&#x27;</span>])</span><br><span class="line"></span><br><span class="line">titanic_df.drop([<span class="string">&#x27;Person&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.drop([<span class="string">&#x27;Person&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/13.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Pclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.factorplot(&#x27;Pclass&#x27;,data=titanic_df,kind=&#x27;count&#x27;,order=[1,2,3])</span></span><br><span class="line">sns.factorplot(<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Survived&#x27;</span>,order=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], data=titanic_df,size=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dummy variables for Pclass column, &amp; drop 3rd class as it has the lowest average of survived passengers</span></span><br><span class="line">pclass_dummies_titanic  = pd.get_dummies(titanic_df[<span class="string">&#x27;Pclass&#x27;</span>])</span><br><span class="line">pclass_dummies_titanic.columns = [<span class="string">&#x27;Class_1&#x27;</span>,<span class="string">&#x27;Class_2&#x27;</span>,<span class="string">&#x27;Class_3&#x27;</span>]</span><br><span class="line">pclass_dummies_titanic.drop([<span class="string">&#x27;Class_3&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pclass_dummies_test  = pd.get_dummies(test_df[<span class="string">&#x27;Pclass&#x27;</span>])</span><br><span class="line">pclass_dummies_test.columns = [<span class="string">&#x27;Class_1&#x27;</span>,<span class="string">&#x27;Class_2&#x27;</span>,<span class="string">&#x27;Class_3&#x27;</span>]</span><br><span class="line">pclass_dummies_test.drop([<span class="string">&#x27;Class_3&#x27;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic_df.drop([<span class="string">&#x27;Pclass&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test_df.drop([<span class="string">&#x27;Pclass&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic_df = titanic_df.join(pclass_dummies_titanic)</span><br><span class="line">test_df    = test_df.join(pclass_dummies_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/14.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始预测</span></span><br><span class="line">   <span class="comment"># define training and testing sets</span></span><br><span class="line"></span><br><span class="line">   X_train = titanic_df.drop(<span class="string">&quot;Survived&quot;</span>,axis=<span class="number">1</span>)</span><br><span class="line">   Y_train = titanic_df[<span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">   X_test  = test_df.drop(<span class="string">&quot;PassengerId&quot;</span>,axis=<span class="number">1</span>).copy()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Logistic Regression</span></span><br><span class="line"></span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg.fit(X_train, Y_train)</span><br><span class="line">Y_pred = logreg.predict(X_test)</span><br><span class="line"></span><br><span class="line">logreg.score(X_train, Y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/15.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(X_train, Y_train)</span><br><span class="line">Y_pred = svc.predict(X_test)</span><br><span class="line">svc.score(X_train, Y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/16.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Random Forests</span></span><br><span class="line"></span><br><span class="line">random_forest = RandomForestClassifier(n_estimators=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">random_forest.fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">Y_pred = random_forest.predict(X_test)</span><br><span class="line"></span><br><span class="line">random_forest.score(X_train, Y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/17.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">knn.fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">Y_pred = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line">knn.score(X_train, Y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/18.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Gaussian Naive Bayes</span></span><br><span class="line"></span><br><span class="line">gaussian = GaussianNB()</span><br><span class="line"></span><br><span class="line">gaussian.fit(X_train, Y_train)</span><br><span class="line"></span><br><span class="line">Y_pred = gaussian.predict(X_test)</span><br><span class="line"></span><br><span class="line">gaussian.score(X_train, Y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/19.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># get Correlation Coefficient for each feature using Logistic Regression</span></span><br><span class="line">coeff_df = DataFrame(titanic_df.columns.delete(<span class="number">0</span>))</span><br><span class="line">coeff_df.columns = [<span class="string">&#x27;Features&#x27;</span>]</span><br><span class="line">coeff_df[<span class="string">&quot;Coefficient Estimate&quot;</span>] = pd.Series(logreg.coef_[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># preview</span></span><br><span class="line">coeff_df</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/20.png" alt=""></p>
<h5 id="补充说明">补充说明</h5>
<p>关于pd.get_dummies 使用</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/titanic/0.png" alt=""></p>
<h5 id="参考-4">参考</h5>
<p><a href="https://www.kaggle.com/omarelgabry/titanic/a-journey-through-titanic"><em>A journey through titanic</em></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kaggle</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle——American Pubs[Python] </title>
    <url>/2017/03/19/Kaggle%E2%80%94%E2%80%94American-Pubs-Python/</url>
    <content><![CDATA[<p>Kaggle案例学习——American Pubs [Python分析]<br>
源码[notebook形式]已经发布在此数据集的<a href="https://www.kaggle.com/shenxiangzhuang/d/erikhambardzumyan/pubs/let-s-see">kernel</a>上，亦可在Kaggle上直接查看。[这次是原创~]<br>
这里仅记录下源码。<br>
数据集：</p>
<blockquote>
<p>Income - Your Approximate Monthly Income (in Armenian Dram)<br>
Fav_Pub - Which is your Favorite Pub?<br>
WTS -Maximum willingness to spend at the pub<br>
Freq - How often do you visit pubs?<br>
Prim_Imp - Which feature is of primary importantance for you?<br>
Sec_Imp - Which feature is of secondary importantance for you?<br>
Stratum - From which regional stratum are you?<br>
Lifestyle - What is your lifestyle?<br>
Occasions- On which occasions do you go to pubs most of the time?</p>
</blockquote>
<p>源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="comment"># function to split the data for cross-validation</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC, LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># EDA</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;/home/shen/PycharmProjects/MyPython/Kaggle/American Pubs/armenian_pubs.csv&quot;</span> )</span><br><span class="line">data.head()</span><br><span class="line"></span><br><span class="line">data.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=============================\n&#x27;</span>, data.notnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line">columns = data.columns</span><br><span class="line"><span class="comment"># Notice that there are &#x27;Age &#x27;, &#x27;Gender &#x27;, &#x27;Income &#x27;, not &#x27;Age&#x27;, &#x27;Gender&#x27;, &#x27;Income&#x27;.</span></span><br><span class="line"><span class="comment"># In other words, we&#x27;d better remove the additional space.</span></span><br><span class="line">data.columns = [<span class="string">&#x27;Timestamp&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Fav_Pub&#x27;</span>, <span class="string">&#x27;WTS&#x27;</span>, <span class="string">&#x27;Freq&#x27;</span>, <span class="string">&#x27;Prim_Imp&#x27;</span>, <span class="string">&#x27;Sec_Imp&#x27;</span>, <span class="string">&#x27;Stratum&#x27;</span>, <span class="string">&#x27;Lifestyle&#x27;</span>, <span class="string">&#x27;Occasions&#x27;</span>]</span><br><span class="line">columns = data.columns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Age</span></span><br><span class="line">sns.countplot(<span class="string">&#x27;Age&#x27;</span>,data=data)</span><br><span class="line"><span class="comment"># Or we can use matplotlib</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Agedata = data[&#x27;Age&#x27;]</span></span><br><span class="line"><span class="string">Agebins = list(range(Agedata.min(), Agedata.max()))</span></span><br><span class="line"><span class="string">plt.hist(Agedata, bins=Agebins)</span></span><br><span class="line"><span class="string">plt.title(&#x27;Age&#x27;)</span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gender</span></span><br><span class="line">sns.countplot(<span class="string">&#x27;Gender&#x27;</span>,data=data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Income</span></span><br><span class="line">Incomedata = data[<span class="string">&#x27;Income&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(Incomedata.notnull().<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(Incomedata.describe())</span><br><span class="line">sns.boxplot(Incomedata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Notice that there are some outliers, let&#x27;s remove them and plot them again for the detail</span></span><br><span class="line">Incomedata_cleaned = Incomedata[Incomedata &lt; <span class="number">1000000</span>]</span><br><span class="line">sns.boxplot(Incomedata_cleaned)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The rest...yes, still countplot...I love it :)</span></span><br><span class="line">cols = [<span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Freq&#x27;</span>, <span class="string">&#x27;Prim_Imp&#x27;</span>, <span class="string">&#x27;Sec_Imp&#x27;</span>, <span class="string">&#x27;Stratum&#x27;</span>, <span class="string">&#x27;Lifestyle&#x27;</span>, <span class="string">&#x27;Occasions&#x27;</span>]</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">36</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cols)):</span><br><span class="line">    fig.add_subplot(<span class="built_in">len</span>(cols),<span class="number">1</span>, i+<span class="number">1</span>)</span><br><span class="line">    sns.countplot(cols[i], data=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s try do some predict by training the data</span></span><br><span class="line"><span class="comment"># Try to transform str value to numeric value</span></span><br><span class="line"><span class="comment"># We&#x27;ll use the method as fellow to do this job</span></span><br><span class="line">le = preprocessing.LabelEncoder()</span><br><span class="line">le.fit(data[<span class="string">&#x27;Occupation&#x27;</span>].unique())</span><br><span class="line"><span class="built_in">print</span>(le.classes_)</span><br><span class="line">le.transform(data[<span class="string">&#x27;Occupation&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numcols = [<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;WTS&#x27;</span>]</span><br><span class="line">strcols = [<span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Prim_Imp&#x27;</span>, <span class="string">&#x27;Sec_Imp&#x27;</span>, <span class="string">&#x27;Stratum&#x27;</span>, <span class="string">&#x27;Lifestyle&#x27;</span>,<span class="string">&#x27;Occasions&#x27;</span>,<span class="string">&#x27;Freq&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># numcols</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Classify the age</span></span><br><span class="line">Cdata = data.copy()</span><br><span class="line"></span><br><span class="line">Simplage = Cdata[<span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line">fig.add_subplot(<span class="number">311</span>)</span><br><span class="line">sns.boxplot(Simplage)</span><br><span class="line">Simplage[Simplage &lt; <span class="number">18</span>] = <span class="number">0</span></span><br><span class="line">Simplage[(Simplage &gt;= <span class="number">18</span>) &amp; (Simplage &lt;<span class="number">23</span>)] = <span class="number">1</span></span><br><span class="line">Simplage[Simplage &gt;= <span class="number">23</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Simplage.head())</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">24</span>))</span><br><span class="line"><span class="comment"># Income</span></span><br><span class="line">Incomedata = Cdata[<span class="string">&#x27;Income&#x27;</span>]</span><br><span class="line"><span class="comment"># Many people are student with no income, so we use o to fill the missing value</span></span><br><span class="line">Simplincome = Incomedata.fillna(<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">#print(&#x27;==============\n&#x27;, Simplincome.notnull().sum())</span></span><br><span class="line"><span class="built_in">print</span>(Simplincome.describe())</span><br><span class="line">fig.add_subplot(<span class="number">312</span>)</span><br><span class="line">sns.boxplot(Simplincome)</span><br><span class="line">Simplincome[Simplincome &lt;= <span class="number">2000</span>] = <span class="number">0</span></span><br><span class="line">Simplincome[(<span class="number">2000</span> &lt; Simplincome) &amp; (Simplincome &lt;= <span class="number">4000</span>)] = <span class="number">1</span></span><br><span class="line">Simplincome[(<span class="number">4000</span> &lt; Simplincome) &amp; (Simplincome &lt;= <span class="number">6000</span>)] = <span class="number">2</span></span><br><span class="line">Simplincome[Simplincome &gt; <span class="number">8000</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Simplincome.head())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Classify the WTS</span></span><br><span class="line">Simplwts = Cdata[<span class="string">&#x27;WTS&#x27;</span>]</span><br><span class="line"><span class="comment">#print(Simplwts.notnull().sum())</span></span><br><span class="line"><span class="comment"># fill these missing values</span></span><br><span class="line">fig.add_subplot(<span class="number">313</span>)</span><br><span class="line">sns.boxplot(<span class="string">&#x27;WTS&#x27;</span>, data=Cdata)</span><br><span class="line"></span><br><span class="line">Simplwts = Simplwts.fillna(<span class="number">5000</span>)</span><br><span class="line"><span class="comment">#print(Simplwts.notnull().sum())</span></span><br><span class="line"><span class="comment">#print(Simplwts.describe())</span></span><br><span class="line"><span class="comment"># Classify</span></span><br><span class="line">Simplwts[Simplwts &lt;= <span class="number">2000</span>] = <span class="number">0</span></span><br><span class="line">Simplwts[(<span class="number">2000</span> &lt; Simplwts) &amp; (Simplwts &lt;= <span class="number">4000</span>)] = <span class="number">1</span></span><br><span class="line">Simplwts[(<span class="number">4000</span> &lt; Simplwts) &amp; (Simplwts &lt;= <span class="number">6000</span>)] = <span class="number">2</span></span><br><span class="line">Simplwts[Simplwts &gt; <span class="number">8000</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment">#print(Simplwts.head())</span></span><br><span class="line"></span><br><span class="line">newdata = pd.concat([Simplage, Simplincome, Simplwts], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(newdata.head())</span><br><span class="line"><span class="built_in">print</span>(newdata.notnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str cols</span></span><br><span class="line"><span class="built_in">print</span>(Cdata.notnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># fillna and label them</span></span><br><span class="line">ontodict = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gettrans</span>(<span class="params">colname</span>):</span><br><span class="line">    coldata = Cdata[colname]</span><br><span class="line">    coldata = coldata.fillna(coldata.mode()[<span class="number">0</span>])  <span class="comment"># the [0] looks like indispensable</span></span><br><span class="line">    le = preprocessing.LabelEncoder()</span><br><span class="line">    le.fit(coldata.unique())</span><br><span class="line">    <span class="comment">#print(colname, &#x27;--&gt;&#x27;, le.classes_)</span></span><br><span class="line">    ontodict[colname] = le.classes_</span><br><span class="line">    newcoldata = le.transform(coldata)</span><br><span class="line">    newdata[colname] = newcoldata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> colname <span class="keyword">in</span> strcols:</span><br><span class="line">    gettrans(colname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(newdata.head())</span><br><span class="line"><span class="built_in">print</span>(newdata.notnull().<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(ontodict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s make Freq as the value that can be predicted by other values</span></span><br><span class="line">x = newdata[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;WTS&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Occupation&#x27;</span>, <span class="string">&#x27;Prim_Imp&#x27;</span>, <span class="string">&#x27;Sec_Imp&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Stratum&#x27;</span>,<span class="string">&#x27;Lifestyle&#x27;</span>, <span class="string">&#x27;Occasions&#x27;</span>]]</span><br><span class="line">y = newdata[<span class="string">&#x27;Freq&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># split into train and test sets</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># take a look at the shape of each of these</span></span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line"><span class="built_in">print</span>(y_train.shape)</span><br><span class="line"><span class="built_in">print</span>(x_test.shape)</span><br><span class="line"><span class="built_in">print</span>(y_test.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># predict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logistic Regression</span></span><br><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg.fit(x_train, y_train)</span><br><span class="line">Y_pred = logreg.predict(x_test)</span><br><span class="line">logreg.score(x_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># knn</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">3</span>)</span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line">Y_pred = knn.predict(x_test)</span><br><span class="line">knn.score(x_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SVM</span></span><br><span class="line">svc = SVC()</span><br><span class="line">svc.fit(x_train, y_train)</span><br><span class="line">Y_pred = svc.predict(x_test)</span><br><span class="line">svc.score(x_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Random Forests</span></span><br><span class="line">random_forest = RandomForestClassifier(n_estimators=<span class="number">50</span>)</span><br><span class="line">random_forest.fit(x_train, y_train)</span><br><span class="line">Y_pred = random_forest.predict(x_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random_forest.score(x_train, y_train)</span><br><span class="line">random_forest.score(x_test, y_test)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kaggle</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle——GUNS-DEATHS[Python]</title>
    <url>/2017/03/02/Kaggle%E2%80%94%E2%80%94GUNS-DEATHS-Python/</url>
    <content><![CDATA[<p>Kaggle案例二——Guns Deaths——Python分析</p>
<p>数据集的理解：</p>
<blockquote>
<p>Our data has almost 101,000 rows (gun death incidents) and 10 columns (categories).<br>
Here’s an explanation of each column:<br>
this is an identifier column, which contains the row number. It’s common in CSV files to include a unique identifier for each row, but we can ignore it in this analysis.<br>
year: the year in which the fatality occurred.<br>
month: the month in which the fatality occurred.<br>
intent: the intent of the perpetrator of the crime. This can be Suicide, Accidental, NA, Homicide, or Undetermined.<br>
police: whether a police officer was involved with the shooting. Either 0 (false) or 1 (true).<br>
sex: the gender of the victim. Either M or F.<br>
age: the age of the victim.<br>
race: the race of the victim. Either Asian/Pacific Islander, Native American/Native Alaskan, Black, Hispanic, or White.<br>
hispanic: a code indicating the Hispanic origin of the victim.<br>
place: where the shooting occurred. Has several categories, which you’re encouraged to explore on your own.<br>
education: educational status of the victim. Can be one of the following:<br>
1: Less than High School<br>
2: Graduated from High School or equivalent<br>
3: Some College<br>
4: At least graduated from College<br>
5: Not available<br>
It’s good practice to get to know our data set before begining to analyze.</p>
</blockquote>
<h6 id="导入数据，清洗并熟悉数据">导入数据，清洗并熟悉数据</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1. Importing, cleaning and getting familiar with the data</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据，[为了可读性和易操作性]简单处理，预览数据</span></span><br><span class="line">guns = pd.read_csv(<span class="string">&#x27;guns.csv&#x27;</span>, index_col = <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(guns.shape)</span><br><span class="line"><span class="built_in">print</span>(guns.head())</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/1.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">guns.index.name = <span class="string">&#x27;Index&#x27;</span></span><br><span class="line"><span class="comment"># for readability and concistency - capitalizing column names</span></span><br><span class="line">guns.columns = <span class="built_in">map</span>(<span class="built_in">str</span>.capitalize, guns.columns)</span><br><span class="line"><span class="built_in">print</span>(guns.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/2.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 总体观察数据</span></span><br><span class="line"><span class="built_in">print</span>(guns.info())  <span class="comment"># 总体信息</span></span><br><span class="line"><span class="built_in">print</span>(guns.dtypes)  <span class="comment"># 变量类型</span></span><br><span class="line"><span class="comment"># print(guns.describe)  # 数值型变量的一些分=分位数等信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失值的处理[这里开始竟然忘了。。。]</span></span><br><span class="line"><span class="built_in">print</span>(guns.notnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In order to see the percentage of valid data:</span></span><br><span class="line"><span class="built_in">print</span>(guns.notnull().<span class="built_in">sum</span>() * <span class="number">100.0</span>/guns.shape[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/3.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Organizing the data by a column value: first by the year, then by month:</span></span><br><span class="line">guns.sort_values([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;Month&#x27;</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(guns.head(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/4.png" alt=""></p>
<h6 id="探索并分析数据">探索并分析数据</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2. Exploring and analyzing the data [这里我们关注的时Intent]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(guns.Intent.value_counts(ascending=<span class="literal">False</span>))</span><br><span class="line"><span class="comment"># Looking at the normalized values makes the picture clearer.</span></span><br><span class="line"><span class="comment"># Note: &#x27;normalize=False&#x27; excludes the &#x27;NaN&#x27;s where here it includes them</span></span><br><span class="line"><span class="built_in">print</span>(guns.Intent.value_counts(ascending=<span class="literal">False</span>, dropna=<span class="literal">False</span>, normalize=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/5.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/55.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 数值型变量的[分位数]描述</span></span><br><span class="line">cols = [<span class="string">&#x27;Education&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    <span class="built_in">print</span>(col, <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(guns[col][guns[col].notnull()].describe())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更多分位数的数据</span></span><br><span class="line">percentiles = np.arange(<span class="number">0.1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    <span class="built_in">print</span>(col, <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(guns[col][guns[col].notnull()].describe(percentiles=percentiles))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/7.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Education</span></span><br><span class="line"><span class="comment"># Age &lt; 16 数据[关于教育]的处理</span></span><br><span class="line"><span class="built_in">print</span>(guns[guns[<span class="string">&#x27;Age&#x27;</span>] &lt; <span class="number">16</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(guns[guns[<span class="string">&#x27;Age&#x27;</span>] &lt; <span class="number">16</span>].head())</span><br><span class="line"></span><br><span class="line">index_temp = guns[(guns[<span class="string">&#x27;Age&#x27;</span>] &lt; <span class="number">16</span>) &amp; ((guns[<span class="string">&#x27;Education&#x27;</span>].isnull()) | (guns[<span class="string">&#x27;Education&#x27;</span>] == <span class="number">5.0</span>))].index</span><br><span class="line">guns.loc[index_temp, <span class="string">&#x27;Education&#x27;</span>] = <span class="number">1.0</span></span><br><span class="line"><span class="built_in">print</span>(guns[guns.Education.isnull()].shape)</span><br><span class="line"></span><br><span class="line">index_temp = guns[guns.Age &lt; <span class="number">5</span>].index</span><br><span class="line">guns.loc[index_temp, <span class="string">&#x27;Education&#x27;</span>] = <span class="number">0.0</span></span><br><span class="line"><span class="built_in">print</span>(guns[<span class="string">&#x27;Education&#x27;</span>][guns.Education.notnull()].describe())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/8.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s get rid of rows that has &#x27;5.0&#x27; (Not available) and NaN in the &#x27;education&#x27; column:</span></span><br><span class="line"><span class="comment"># subset = can include a list of column names</span></span><br><span class="line">guns.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">guns = guns[guns.Education != <span class="number">5.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(guns.Education.value_counts())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/9.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> guns.columns:</span><br><span class="line">    <span class="keyword">if</span> col <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(guns[col].unique())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/10.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 一些实用的处理技巧</span></span><br><span class="line"><span class="comment"># Year Month</span></span><br><span class="line"><span class="comment"># evaluating the percentage change between years</span></span><br><span class="line">n2012 = guns[<span class="number">2012</span> == guns[<span class="string">&#x27;Year&#x27;</span>]].shape[<span class="number">0</span>]</span><br><span class="line">(guns.Year.value_counts(sort=<span class="literal">False</span>) - n2012) * <span class="number">100.</span>/ n2012    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nexpected_month = guns.shape[<span class="number">0</span>]/<span class="number">12.</span></span><br><span class="line">(guns.Month.value_counts(sort=<span class="literal">True</span>) - nexpected_month) * <span class="number">100.</span>/nexpected_month        </span><br><span class="line"></span><br><span class="line">guns.sort_values([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;Month&#x27;</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/11.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面简单通过月份看死亡率不太严谨，接下来考虑闰年和特殊月份天数问题</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># The purpose of *10000 and the *100 are to convert 2012, 01, 01 into 20120101 for readability</span></span><br><span class="line">guns[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime((guns.Year * <span class="number">10000</span> + guns.Month * <span class="number">100</span> + <span class="number">1</span>).apply(<span class="built_in">str</span>),<span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">guns.dtypes.tail(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 删除无用的变量，简化数据集[这里Date的引入与在Titanic上对于family的处理是一样的]</span></span><br><span class="line"><span class="keyword">del</span> guns[<span class="string">&#x27;Year&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> guns[<span class="string">&#x27;Month&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">monthly_rates = pd.DataFrame(guns.groupby(<span class="string">&#x27;Date&#x27;</span>).size(), columns=[<span class="string">&#x27;Count&#x27;</span>])</span><br><span class="line">monthly_rates.index.to_datetime</span><br><span class="line"><span class="built_in">print</span>(monthly_rates.index.dtype)</span><br><span class="line"><span class="built_in">print</span>(monthly_rates.shape)</span><br><span class="line">monthly_rates.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算新列 Days_per_month</span></span><br><span class="line">days_per_month = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> monthly_rates.index:</span><br><span class="line">    days_per_month.append(calendar.monthrange(val.year, val.month)[<span class="number">1</span>])</span><br><span class="line">monthly_rates[<span class="string">&#x27;Days_per_month&#x27;</span>] = days_per_month</span><br><span class="line">monthly_rates.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;Averahe_per_day&#x27; 代表各年各月份，平均每天死于gun的人数</span></span><br><span class="line">monthly_rates[<span class="string">&#x27;Average_per_day&#x27;</span>] = monthly_rates[<span class="string">&#x27;Count&#x27;</span>]*<span class="number">1.</span>/monthly_rates[<span class="string">&#x27;Days_per_month&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(monthly_rates.shape)</span><br><span class="line">monthly_rates.tail()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求三年的平均值</span></span><br><span class="line">month_rate_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">13</span>):</span><br><span class="line">    bool_temp = monthly_rates.index.month == i</span><br><span class="line">    month_average = (<span class="built_in">sum</span>(monthly_rates.loc[bool_temp, <span class="string">&#x27;Average_per_day&#x27;</span>]))/<span class="number">3.</span></span><br><span class="line">    month_rate_dict[i] = month_average</span><br><span class="line"></span><br><span class="line">avg_month_rate = pd.DataFrame.from_dict(<span class="built_in">list</span>(month_rate_dict.items()))</span><br><span class="line">avg_month_rate.columns = [<span class="string">&#x27;Month&#x27;</span>, <span class="string">&#x27;Value&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculating the expected cases for each day [+1. becuase 2012 was a leap year]</span></span><br><span class="line">nexpected_day = guns.shape[<span class="number">0</span>]/(<span class="number">365</span>*<span class="number">3</span> + <span class="number">1.</span>)</span><br><span class="line"></span><br><span class="line">avg_month_rate[<span class="string">&#x27;Percent_change&#x27;</span>] = (avg_month_rate.Value - nexpected_day) * <span class="number">100.</span>/ nexpected_day</span><br><span class="line"><span class="built_in">print</span>(avg_month_rate.sort(<span class="string">&#x27;Percent_change&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Police</span></span><br><span class="line"><span class="comment"># 删除无用列[数据无有效的信息]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> * guns.Police.value_counts(normalize=<span class="literal">True</span>))</span><br><span class="line"><span class="keyword">del</span> guns[<span class="string">&#x27;Police&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(guns.shape)</span><br><span class="line"><span class="built_in">print</span>(guns.head())</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/12.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Race</span></span><br><span class="line"><span class="built_in">print</span>(guns.Race.value_counts(sort=<span class="literal">True</span>, normalize=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># Question: Which race appears the most in the df and which appears the least?</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里的细节值得注意，我们不能因为看到White的case比如较多就认为死于gun的人当中White就最多，</span></span><br><span class="line"><span class="string">正如答案所言，在不知道总体人种比例时，我们不能妄下论断</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Answer: We can not conclude anything by those numbers unless we take in account the distribution of races in the US population.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些技巧</span></span><br><span class="line"><span class="comment"># About Sample</span></span><br><span class="line"><span class="comment"># a sample of about 10% of the data may look like this:</span></span><br><span class="line">sample_guns = guns.sample(n=<span class="number">10000</span>)</span><br><span class="line">sample_guns.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># How do you define a categorical columns/pd.Series? </span></span><br><span class="line"><span class="comment"># E.g please order guns[&#x27;intent&#x27;] by this order: &#x27;Homicide&#x27;,&#x27;Suicide&#x27;,&#x27;Accidental&#x27;,&#x27;Undetermined&#x27;</span></span><br><span class="line"></span><br><span class="line">list_ordered = [<span class="string">&#x27;Homicide&#x27;</span>,<span class="string">&#x27;Suicide&#x27;</span>,<span class="string">&#x27;Accidental&#x27;</span>,<span class="string">&#x27;Undetermined&#x27;</span>]</span><br><span class="line">guns[<span class="string">&#x27;Intent&#x27;</span>] = guns[<span class="string">&#x27;Intent&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">guns.Intent.cat.set_categories(list_ordered, inplace=<span class="literal">True</span>)</span><br><span class="line">guns.sort_values([<span class="string">&#x27;Intent&#x27;</span>]).head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Undeterminded对预测Intent无太大作用，删除</span></span><br><span class="line">guns = guns[guns.Intent != <span class="string">&#x27;Undetermined&#x27;</span>]</span><br><span class="line">guns.Intent.value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># removing last value in list ordered - which is &#x27;Undetermined&#x27;</span></span><br><span class="line">list_ordered = list_ordered[:-<span class="number">1</span>]</span><br><span class="line">guns.Intent.cat.set_categories(list_ordered, inplace=<span class="literal">True</span>)</span><br><span class="line">guns.Intent.value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># **Question:** Given a Series which contains strings, how do you find the length of each of the strings?</span></span><br><span class="line">guns.Race.<span class="built_in">str</span>.<span class="built_in">len</span>().unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># **Question:** For the same series, how do you know if any given entry contains a string segment. E.g: Which entries int the &#x27;intent&#x27; column contain the segment &#x27;cide&#x27;?</span></span><br><span class="line">guns.Intent.<span class="built_in">str</span>.contains(<span class="string">&#x27;cide&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="数据可视化">数据可视化</h6>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/13.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/14.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/15.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/16.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/17.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/18.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/19.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/20.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/21.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/kaggle/guns/22.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3. Visualizing the data </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Line Charts / Time analysis</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;white&#x27;</span>, color_codes=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2012</span></span><br><span class="line">plt.plot(monthly_rates.index[:<span class="number">12</span>], monthly_rates[<span class="string">&#x27;Count&#x27;</span>][:<span class="number">12</span>], </span><br><span class="line">         linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">3.</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># notice the y column in the previous plot begins at 2200; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s look at the real picture from 0 </span></span><br><span class="line"></span><br><span class="line">plt.plot(monthly_rates.index[:<span class="number">12</span>], monthly_rates[<span class="string">&#x27;Count&#x27;</span>][:<span class="number">12</span>],</span><br><span class="line"></span><br><span class="line">        linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">3.</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">plt.ylim(ymin=<span class="number">0</span>, ymax=<span class="number">3500</span>)</span><br><span class="line"></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Month&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Gun Deaths\ncount&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Monthly Gun Death Count in the US, 2012&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># years 2012 - 2014</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changing linestyle to a constant line = seeing intersections more clearly</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">plt.plot(monthly_rates.index.month[<span class="number">0</span>:<span class="number">12</span>], monthly_rates[<span class="string">&#x27;Count&#x27;</span>][<span class="number">0</span>:<span class="number">12</span>], label=<span class="string">&#x27;2012&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2.</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(monthly_rates.index.month[<span class="number">12</span>:<span class="number">24</span>], monthly_rates[<span class="string">&#x27;Count&#x27;</span>][<span class="number">12</span>:<span class="number">24</span>], label=<span class="string">&#x27;2013&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2.</span>, alpha=<span class="number">0.8</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(monthly_rates.index.month[<span class="number">24</span>:<span class="number">36</span>], monthly_rates[<span class="string">&#x27;Count&#x27;</span>][<span class="number">24</span>:<span class="number">36</span>], label=<span class="string">&#x27;2014&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2.</span>, alpha=<span class="number">0.8</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(xmin=<span class="number">1</span>, xmax=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">plt.ylim(ymax=<span class="built_in">max</span>(monthly_rates[<span class="string">&#x27;Count&#x27;</span>])+<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(np.arange(<span class="number">1</span>, <span class="number">13</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>, frameon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Month&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Gun Death\nCount&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Monthly Gun Death Count in the US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># From zero</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">labels = [<span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;2013&#x27;</span>, <span class="string">&#x27;2014&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">    start_index = i*<span class="number">12</span></span><br><span class="line">    end_index = (i+<span class="number">1</span>)*<span class="number">12</span></span><br><span class="line">    subset = monthly_rates[start_index:end_index]</span><br><span class="line">    plt.plot(subset.index.month, subset[<span class="string">&#x27;Count&#x27;</span>], color=colors[i], label=labels[i],</span><br><span class="line">            linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">2.</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(xmin=<span class="number">1</span>, xmax=<span class="number">12</span>)</span><br><span class="line">plt.ylim(ymin=<span class="number">0</span>, ymax=<span class="built_in">max</span>(monthly_rates[<span class="string">&#x27;Count&#x27;</span>])+<span class="number">100</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">plt.xticks(np.arange(<span class="number">1</span>, <span class="number">13</span>, <span class="number">1</span>))</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;center right&#x27;</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Month&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Number of Gun Death Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Monthly Gun Death Count in the US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bar plot</span></span><br><span class="line">intent_sex = guns.groupby([<span class="string">&#x27;Intent&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>])[<span class="string">&#x27;Intent&#x27;</span>].count().unstack(<span class="string">&#x27;Sex&#x27;</span>)</span><br><span class="line">ax = intent_sex.plot(kind=<span class="string">&#x27;bar&#x27;</span>, stacked=<span class="literal">True</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Intent&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">ax.legend(labels=[<span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>], frameon=<span class="literal">False</span>, loc=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Gender distribution\nGun Deaths US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个不太好的图</span></span><br><span class="line">intent_edu = guns.groupby([<span class="string">&#x27;Intent&#x27;</span>, <span class="string">&#x27;Education&#x27;</span>])[<span class="string">&#x27;Intent&#x27;</span>].count().unstack(<span class="string">&#x27;Education&#x27;</span>)</span><br><span class="line"><span class="comment"># creating a range of 5 colors - from light to dark</span></span><br><span class="line">edu_legend_labels = [<span class="string">&#x27;Less than\nElementry school&#x27;</span>,<span class="string">&#x27;Less than \nHigh School&#x27;</span>, <span class="string">&#x27;Graduated from\nHigh School\nor equivalent&#x27;</span>, </span><br><span class="line">                 <span class="string">&#x27;Some College&#x27;</span>, <span class="string">&#x27;At least\ngraduated\nfrom College&#x27;</span>]</span><br><span class="line">colors = plt.cm.GnBu(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">ax = intent_edu.plot(kind=<span class="string">&#x27;bar&#x27;</span>, stacked=<span class="literal">True</span>, color=colors, width=<span class="number">0.5</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Intent&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">ax.legend(edu_legend_labels, ncol=<span class="number">1</span>, frameon=<span class="literal">False</span>, prop=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">10</span>&#125;, loc=<span class="number">0</span>)</span><br><span class="line">plt.ylim(ymin=<span class="number">0</span>, ymax=<span class="number">90000</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Education distribution\n in Gun Deaths US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上图略显拥挤，我们用下面的水平图的进行改进</span></span><br><span class="line">intent_edu = guns.groupby([<span class="string">&#x27;Intent&#x27;</span>, <span class="string">&#x27;Education&#x27;</span>])[<span class="string">&#x27;Intent&#x27;</span>].count().unstack(<span class="string">&#x27;Education&#x27;</span>)</span><br><span class="line">ax = intent_edu.plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">15</span>,<span class="number">6</span>), stacked=<span class="literal">True</span>, color=colors, alpha=<span class="number">0.6</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Intent&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">ax.legend(edu_legend_labels, loc=<span class="number">0</span>,  prop=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">12</span>&#125;, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>, xmax=<span class="number">80000</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Education distribution\nin Gun Deaths US: 2012-2014&#x27;</span>, fontsize=<span class="number">20</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the percentage visual is more informative</span></span><br><span class="line">education = pd.crosstab(guns.Education, guns.Intent)</span><br><span class="line">education.div(education.<span class="built_in">sum</span>(<span class="number">1</span>).astype(<span class="built_in">float</span>), axis=<span class="number">0</span>).plot(kind=<span class="string">&#x27;bar&#x27;</span>, stacked=<span class="literal">True</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Intent Percentage by Education&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Education level&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Percentage&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper center&#x27;</span>, bbox_to_anchor=(<span class="number">1.1</span>,<span class="number">0.9</span>))</span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Place</span></span><br><span class="line">intent_place = guns.groupby([<span class="string">&#x27;Intent&#x27;</span>, <span class="string">&#x27;Place&#x27;</span>])[<span class="string">&#x27;Intent&#x27;</span>].count().unstack(<span class="string">&#x27;Place&#x27;</span>)</span><br><span class="line"></span><br><span class="line">colors = plt.cm.GnBu(np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">ax = intent_place.plot(kind=<span class="string">&#x27;barh&#x27;</span>, stacked=<span class="literal">True</span>, color=colors, alpha=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Intent&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>, length=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(loc=<span class="number">0</span>, ncol=<span class="number">2</span>, prop=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">10</span>&#125;, frameon=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Location distribution\nin Gun Deaths US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 归类的思想</span></span><br><span class="line"><span class="comment">#These are too many categories and it&#x27;s hard to arrive to conclusions</span></span><br><span class="line"><span class="comment"># let&#x27;s merge &#x27;street&#x27; with &#x27;trade/service area&#x27; and the rest to &#x27;Other&#x27;</span></span><br><span class="line">index_temp = guns[(guns[<span class="string">&#x27;Place&#x27;</span>] == <span class="string">&#x27;Trade/service area&#x27;</span>) | (guns.Place == <span class="string">&#x27;Industrial/construction&#x27;</span>)].index</span><br><span class="line">guns.loc[index_temp, <span class="string">&#x27;Place&#x27;</span>] = <span class="string">&#x27;Street&#x27;</span></span><br><span class="line">index_temp = guns[(guns[<span class="string">&#x27;Place&#x27;</span>] != <span class="string">&#x27;Street&#x27;</span>) &amp; (guns.Place != <span class="string">&#x27;Home&#x27;</span>)].index</span><br><span class="line">guns.loc[index_temp, <span class="string">&#x27;Place&#x27;</span>] = <span class="string">&#x27;Other&#x27;</span></span><br><span class="line"></span><br><span class="line">guns.Place.value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s take another look:</span></span><br><span class="line">intent_place = guns.groupby([<span class="string">&#x27;Intent&#x27;</span>, <span class="string">&#x27;Place&#x27;</span>])[<span class="string">&#x27;Intent&#x27;</span>].count().unstack(<span class="string">&#x27;Place&#x27;</span>)</span><br><span class="line">colors = plt.cm.GnBu(np.linspace(<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line">ax = intent_place.plot(kind=<span class="string">&#x27;barh&#x27;</span>, stacked=<span class="literal">True</span>, color=colors, alpha=<span class="number">0.6</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Intent&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;upper right&#x27;</span>, prop=&#123;<span class="string">&#x27;size&#x27;</span>:<span class="number">10</span>&#125;, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Location distribution\nin Gun Deaths US: 2012-2014&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the percentage visual is more informative</span></span><br><span class="line">place_died = pd.crosstab(guns.Place, guns.Intent)</span><br><span class="line">place_died.div(place_died.<span class="built_in">sum</span>(<span class="number">1</span>).astype(<span class="built_in">float</span>), axis=<span class="number">0</span>).plot(kind=<span class="string">&#x27;bar&#x27;</span>, stacked=<span class="literal">True</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Intent Percentage by Place&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Place of death&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Percentage&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper center&#x27;</span>, bbox_to_anchor=(<span class="number">1.1</span>,<span class="number">0.9</span>))</span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line"><span class="comment"># barplot of gender grouped by intent </span></span><br><span class="line">pd.crosstab(guns.Sex, guns.Intent).plot(kind=<span class="string">&#x27;bar&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Gender Distribution by Intent&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Gender&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="number">0</span>)</span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># barplot of education grouped by intent </span></span><br><span class="line">pd.crosstab(guns.Education, guns.Intent).plot(kind=<span class="string">&#x27;bar&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Education Distribution by Intent&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Education&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">sns.despine()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Histograms</span></span><br><span class="line"></span><br><span class="line">age_freq = guns.Age.value_counts()</span><br><span class="line">sorted_age_freq = age_freq.sort_index()</span><br><span class="line">sorted_age_freq.head()</span><br><span class="line">plt.hist(guns[<span class="string">&#x27;Age&#x27;</span>], <span class="built_in">range</span>=(<span class="number">0</span>,<span class="number">107</span>), alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>, xmax=<span class="number">110</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Count&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Age distribution&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine(bottom=<span class="literal">True</span>, left=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sex and Intent</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">suicide = guns[guns[<span class="string">&#x27;Intent&#x27;</span>] == <span class="string">&#x27;Suicide&#x27;</span>]</span><br><span class="line">homicide = guns[guns[<span class="string">&#x27;Intent&#x27;</span>] == <span class="string">&#x27;Homicide&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ax1.hist(suicide.Age, <span class="number">20</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Suicide gun deaths\nAge Distribution&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">ax2.hist(homicide.Age, <span class="number">20</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;Homicide gun deaths\nAge Distribution&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;Frequency&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Frequency&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax1.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">ax2.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">ax1.set_xlim(xmin=<span class="number">0</span>, xmax=<span class="number">110</span>)</span><br><span class="line">ax2.set_xlim(xmin=<span class="number">0</span>, xmax=<span class="number">110</span>)</span><br><span class="line">sns.despine(bottom=<span class="literal">True</span>, left=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cross</span></span><br><span class="line">g = sns.FacetGrid(suicide, col=<span class="string">&#x27;Sex&#x27;</span>)  </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.05</span>))</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Suicide ages: Gender comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">g = sns.FacetGrid(homicide, col=<span class="string">&#x27;Sex&#x27;</span>) </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.05</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>, ylabel=<span class="string">&#x27;Percentage&#x27;</span>, )</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Homicide ages: Gender comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Race and age</span></span><br><span class="line">g = sns.FacetGrid(suicide, col=<span class="string">&#x27;Race&#x27;</span>)  </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="literal">None</span>))</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Suicide ages: Race comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">g = sns.FacetGrid(homicide, col=<span class="string">&#x27;Race&#x27;</span>) </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="literal">None</span>))</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Homicide ages: Race comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># in order to get in in the same order for better comparison:</span></span><br><span class="line">race_ordered = [<span class="string">&#x27;Black&#x27;</span>, <span class="string">&#x27;White&#x27;</span>, <span class="string">&#x27;Hispanic&#x27;</span>, <span class="string">&#x27;Asian/Pacific Islander&#x27;</span>, <span class="string">&#x27;Native American/Native Alaskan&#x27;</span>]</span><br><span class="line">guns[<span class="string">&#x27;Race&#x27;</span>] = guns[<span class="string">&#x27;Race&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">guns.Race.cat.set_categories(race_ordered, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">suicide = guns[guns[<span class="string">&#x27;Intent&#x27;</span>] == <span class="string">&#x27;Suicide&#x27;</span>]</span><br><span class="line">homicide = guns[guns[<span class="string">&#x27;Intent&#x27;</span>] == <span class="string">&#x27;Homicide&#x27;</span>]</span><br><span class="line"></span><br><span class="line">g = sns.FacetGrid(suicide, col=<span class="string">&#x27;Race&#x27;</span>)  </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Suicide ages: Race comparison&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">g = sns.FacetGrid(homicide, col=<span class="string">&#x27;Race&#x27;</span>) </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Homicide ages: Race comparison&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># we can ignore education = 0 - since these are all very young ages</span></span><br><span class="line">g = sns.FacetGrid(suicide[suicide.Education &gt; <span class="number">0</span>], col=<span class="string">&#x27;Education&#x27;</span>)</span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Suicide ages: Education comparison&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">g = sns.FacetGrid(homicide[homicide.Education &gt; <span class="number">0</span>], col=<span class="string">&#x27;Education&#x27;</span>) </span><br><span class="line">g.<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.subplots_adjust(top=<span class="number">0.8</span>)</span><br><span class="line">g.<span class="built_in">set</span>(xlim=(<span class="number">0</span>, <span class="number">110</span>), ylim=(<span class="number">0</span>, <span class="number">0.06</span>), xlabel=<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">g.fig.suptitle(<span class="string">&#x27;Homicide ages: Education comparison&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># KDE-PLOT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># limit the x-axis</span></span><br><span class="line"><span class="comment"># Intent-Age</span></span><br><span class="line">sns.FacetGrid(guns, hue=<span class="string">&#x27;Intent&#x27;</span>, size=<span class="number">4</span>).<span class="built_in">map</span>(sns.kdeplot, <span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="number">9</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Density&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">sns.despine(left=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Age distribution\nHomicide vs. Suicide&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sex-Age</span></span><br><span class="line">sns.FacetGrid(guns, hue=<span class="string">&#x27;Sex&#x27;</span>, size=<span class="number">4</span>).<span class="built_in">map</span>(sns.kdeplot, <span class="string">&#x27;Age&#x27;</span>).add_legend()</span><br><span class="line">sns.despine(left=<span class="literal">True</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Age distribution\nMale vs. Female&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Intent:Sex-Age</span></span><br><span class="line">sns.FacetGrid(suicide, hue=<span class="string">&#x27;Sex&#x27;</span>, size=<span class="number">4</span>).<span class="built_in">map</span>(sns.kdeplot, <span class="string">&#x27;Age&#x27;</span>).add_legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">sns.despine(left=<span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Suicide ages: Gender comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.FacetGrid(homicide, hue=<span class="string">&#x27;Sex&#x27;</span>, size=<span class="number">4</span>).<span class="built_in">map</span>(sns.kdeplot, <span class="string">&#x27;Age&#x27;</span>).add_legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">sns.despine(left=<span class="literal">True</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Homicide ages: Gender comparison&#x27;</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Box plot</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">data_to_plot = [suicide.Age, homicide.Age]</span><br><span class="line">plt.xlim(xmin=<span class="number">0</span>, xmax=<span class="number">110</span>)</span><br><span class="line">plt.boxplot(data_to_plot)</span><br><span class="line">plt.ylim(ymin=-<span class="number">1</span>, ymax=<span class="number">110</span>)</span><br><span class="line">plt.xticks([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&#x27;Suicide&#x27;</span>, <span class="string">&#x27;Homicide&#x27;</span>], fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;both&#x27;</span>,length=<span class="number">0</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Ages in Suicide vs. Homicide&#x27;</span>,</span><br><span class="line">          fontsize=<span class="number">14</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">sns.despine(bottom=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#sns.set(style=&#x27;ticks&#x27;)</span></span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;Intent&#x27;</span>, y=<span class="string">&#x27;Age&#x27;</span>, hue=<span class="string">&#x27;Sex&#x27;</span>, data=guns, palette=<span class="string">&#x27;PRGn&#x27;</span>, width=<span class="number">0.6</span>)</span><br><span class="line">sns.despine(bottom=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Violin-plot</span></span><br><span class="line">sns.violinplot(x=<span class="string">&#x27;Intent&#x27;</span>, y=<span class="string">&#x27;Age&#x27;</span>, hue=<span class="string">&#x27;Sex&#x27;</span>, split=<span class="literal">True</span>, data=guns, size=<span class="number">4</span>, inner=<span class="string">&#x27;quart&#x27;</span>)</span><br><span class="line">sns.despine(bottom=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Kaggle</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex in Ubuntu16.04</title>
    <url>/2019/04/30/LaTex-in-Ubuntu16-04/</url>
    <content><![CDATA[<h3 id="Overview-25">Overview</h3>
<p>Ubuntu16.04 LTS中LaTex环境配置（这里是2018版）。</p>
<h3 id="Remove-Old-Version">Remove Old Version</h3>
<p>参考<a href="https://tex.stackexchange.com/questions/95483/how-to-remove-everything-related-to-tex-live-for-fresh-install-on-ubuntu">tex.stackexchange</a></p>
<h3 id="Tex-Live">Tex Live</h3>
<h4 id="Ubuntu-安装源">Ubuntu 安装源</h4>
<p>直接<code>sudo apt-get install texlive-full</code>即可，完整版需要磁盘空间较大。</p>
<h4 id="安装包（现在采用的方法）">安装包（现在采用的方法）</h4>
<h5 id="Tex-Live-2">Tex Live</h5>
<p>参考<a href="https://stone-zeng.github.io/2018-05-13-install-texlive-ubuntu/">stone-zeng</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/install-tl-unx.tar.gz</span><br><span class="line">tar -xzf install-tl-unx.tar.gz</span><br><span class="line">cd install-tl-2018*</span><br></pre></td></tr></table></figure>
<p>之后直接以GUI模式安装<code>sudo ./install-tl -gui -repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/</code></p>
<h5 id="设置环境变量">设置环境变量</h5>
<p>打开<code>~/.bashrc</code>，最后添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/texlive/2018/bin/x86_64-linux:$PATH</span><br><span class="line">export MANPATH=/usr/local/texlive/2018/texmf-dist/doc/man:$MANPATH</span><br><span class="line">export INFOPATH=/usr/local/texlive/2018/texmf-dist/doc/info:$INFOPATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还需保证开启 sudo 模式后路径仍然可用。命令行中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure>
<p>找到如下一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults        env_reset</span><br><span class="line">Defaults        mail_badpass</span><br><span class="line">Defaults        secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&quot;</span><br></pre></td></tr></table></figure>
<p>将第三行更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defaults        secure_path=&quot;/usr/local/texlive/2018/bin/x86_64-linux:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin&quot;</span><br></pre></td></tr></table></figure>
<p>也就是加入 TeX Live 的执行路径</p>
<h5 id="字体设置">字体设置</h5>
<p>要在整个系统中使用 TeX 字体，还需要将 TeX 自带的配置文件复制到系统目录下。命令行中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /usr/local/texlive/2018/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-texlive.conf</span><br></pre></td></tr></table></figure>
<p>后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fc-cache -fv</span><br></pre></td></tr></table></figure>
<p>刷新字体数据库。</p>
<h3 id="安装宏包">安装宏包</h3>
<h4 id="tmlgr自动安装">tmlgr自动安装</h4>
<p>首先再次配置镜像，参考<a href="https://tex.stackexchange.com/questions/145186/problem-with-updating-tlmgr-bad-hostname">这里</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure>
<p>之后运行<code>tlmgr install &lt;package name&gt;</code>即可。</p>
<h4 id="压缩包手动安装">压缩包手动安装</h4>
<p>参考<a href="https://github.com/hokein/Wiki/wiki/ubuntu%E4%B8%8B%E5%AE%8F%E5%8C%85latex%E5%AE%89%E8%A3%85">这里</a></p>
<p>Step1. 先找到系统默认宏包的位置，一般是在目录 /usr/share/texmf/tex/latex</p>
<p>Step2. 把需要安装的宏包放到上面的目录下。</p>
<p>Step3. 执行下面的命令更新一下即可: ~/$ sudo texhash</p>
<h3 id="TexMaker">TexMaker</h3>
<p>直接<code>sudo apt-get install texmaker</code>即可。也可以到<a href="http://www.xm1math.net/texmaker/">官网</a>选择安装更新的版本（已经18.04起步了Orz</p>
<h3 id="Templates">Templates</h3>
<p><a href="https://github.com/ElegantLaTeX">ElegantLaTeX</a></p>
<h3 id="Videos">Videos</h3>
<p><a href="https://www.bilibili.com/video/av50392724?p=2">米神LaTex+Emacs</a></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Opencv3学习笔记</title>
    <url>/2017/04/06/Learning-Opencv3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h6 id="关于遍历">关于遍历</h6>
<p>再学到P123时，发现书上的代码是无法运行的，先来看下它的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> sz[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">cv::Mat	<span class="title">m</span><span class="params">(<span class="number">3</span>, sz, CV_32FC3)</span></span>;		<span class="comment">//	A	three-dimensional	array	of	size	4-by-4-by-4</span></span><br><span class="line">cv::<span class="built_in">randu</span>( m, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);			<span class="comment">//	fill	with	random	numbers	from	-1.0	to	1.0</span></span><br><span class="line"><span class="type">float</span> max = <span class="number">0.0f</span>;														<span class="comment">//	minimum	possible	value	of	L2	norm</span></span><br><span class="line">cv::MatConstIterator&lt;cv::Vec3f&gt; it = m.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>( it != m.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">    len2 = (*it)[<span class="number">0</span>]*(*it)[<span class="number">0</span>]+(*it)[<span class="number">1</span>]*(*it)[<span class="number">1</span>]+(*it)[<span class="number">2</span>]*(*it)[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>( len2 &gt; max ) max = len2;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先，len2未声明，再者，MatConstIterator的用法可能有变化。<br>
参考<a href="http://docs.opencv.org/trunk/d5/dd2/classcv_1_1NAryMatIterator.html">官方文档示例代码</a>解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sz[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">cv::Mat	<span class="title">m</span><span class="params">(<span class="number">3</span>, sz, CV_32FC3)</span></span>;		<span class="comment">//	A	three-dimensional	array	of	size	4-by-4-by-4</span></span><br><span class="line">    cv::<span class="built_in">randu</span>( m, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);			<span class="comment">//	fill	with	random	numbers	from	-1.0	to	1.0</span></span><br><span class="line">    <span class="type">float</span> max = <span class="number">0.0f</span>;														<span class="comment">//	minimum	possible	value	of	L2	norm</span></span><br><span class="line">    cv::MatConstIterator_&lt;cv::Vec3f&gt; it = m.<span class="built_in">begin</span>&lt;cv::Vec3f&gt;();</span><br><span class="line">    <span class="keyword">while</span>( it != m.<span class="built_in">end</span>&lt;cv::Vec3f&gt;() ) &#123;</span><br><span class="line">        <span class="type">float</span> len2 = (*it)[<span class="number">0</span>]*(*it)[<span class="number">0</span>]+(*it)[<span class="number">1</span>]*(*it)[<span class="number">1</span>]+(*it)[<span class="number">2</span>]*(*it)[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>( len2 &gt; max ) max = len2;</span><br><span class="line">        it++;</span><br><span class="line">        std::cout&lt;&lt;max&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Regression In R</title>
    <url>/2017/10/22/Linear-Regression-In-R/</url>
    <content><![CDATA[<h4 id="Overview-26">Overview</h4>
<p>开了统计预测与决策的课，老师上课用的Eviews，用了下感觉一般，所以找R来实现看看。所以就先从回归开始了…</p>
<h4 id="Code-20">Code</h4>
<p>首先是随便Google了一个简单几页的<a href="http://www.montefiore.ulg.ac.be/~kvansteen/GBIO0009-1/ac20092010/Class8/Using%20R%20for%20linear%20regression.pdf">教程</a>走了一般流程,发现挺靠谱的…接着用两天撸完了<em>R in Action</em>的第八章，也就是回归部分。写的很好，用RMD做了笔记，放在<a href="http://rpubs.com/shenxiangzhuang/regression">这里</a></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下HBase使用</title>
    <url>/2020/02/23/Linux%E4%B8%8BHBase%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概览-2">概览</h2>
<p>HBase的安装与使用。注意HBase是建立在HDFS之上的。</p>
<h2 id="安装">安装</h2>
<p>参考林子雨老师的<a href="https://dblab.xmu.edu.cn/blog/2442-2/#more-2442">HBase2.2.2安装和编程实践指南</a>。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Hadoop使用</title>
    <url>/2020/02/23/Linux%E4%B8%8BHadoop%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概览-3">概览</h2>
<p>记录Hadoop安装使用过程遇到的问题与解决方案。因为在公司都是使用搭建好的集群,所以一般没有什么配置上的问题.这里主要记录在自己搭建的伪分布式集群中遇到的问题.</p>
<h2 id="报错：Connection-refused">报错：Connection refused</h2>
<p>运行<code>hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar grep input output 'dfs[a-z.]+'</code>报的错。</p>
<p>注意执行操作之前要先启动Hadoop，可以通过<code>start-dfs.sh</code>或者<code>start-all.sh</code>[^1]。原因就是Hadoop未启动成功，通过<code>jps</code>看到<code>namenode</code>并未启动。比较奇怪的是安装的时候测试还是可以的，而且是完全按照<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">官方文档</a>来的。</p>
<p>问题就在官方文档…林子雨老师的<a href="http://dblab.xmu.edu.cn/blog/2441-2/">Hadoop3.1.3安装教程</a>提到了这点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</span><br><span class="line"></span><br><span class="line">此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</span><br></pre></td></tr></table></figure>
<p>也就是说我们按照官网的方法配置<code>core-site.xml </code>与<code>hdfs-site.xml</code>的话，重启的时候必须重新<code>format</code>，否则就无法启动<code>namenode</code>!谁没事每次启动都去格式化依次，太坑了Orz</p>
<p>按照林子雨老师的方法配置就不会出现这个问题。对<code>core-site.xml </code>配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对<code>hdfs-site.xml</code>配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为林老师是将Hadoop放在<code>/usr/local</code>, 而我是在<code>/home/shensir/Application</code>,所以将上面的<code>/usr/local</code>部分替换为<code>/home/shensir/Application</code>即可。</p>
<p>另外一点就是HDFS网页的访问地址在Linux是<code>http://localhost:9870</code>，好像也有的是<code>50070</code>端口的。我这里测试是前者。</p>
<h2 id="报错：Retrying-connect-to-server-0-0-0-0-0-0-0-0-8032">报错：Retrying connect to server: 0.0.0.0/0.0.0.0:8032</h2>
<p>也是运行<code>hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar grep input output 'dfs[a-z.]+'</code>时候出错。推测是YARN配置和上面的冲突了，把YARN的配置全部清空再重启就可以了。</p>
<p>[^1]: 注意这里在加入环境变量后调用的, 其位于<code>sbin</code>文件夹下。</p>
<h2 id="伪分布式-YARN上显示的内存与核数与本机器不一致">伪分布式: YARN上显示的内存与核数与本机器不一致</h2>
<p>用的是实验室的服务器,32核100G+,然后部署的伪分布式,起了YARN, 在8088端口看节点配置发现只有8G,核数也不对, 原来是因为这个要自己写配置文件设置的(之前还以为是自动检测Orz)…</p>
<p>参考<a href="https://stackoverflow.com/questions/31768479/hadoop-not-utilizing-available-memory">Hadoop not utilizing available memory</a>, 在Hadoop安装目录下找到<code>etc/hadoop/yarn-site.xml</code>, 添加如下内容,指定当前节点可供分配的内存为80G,可用核数为24个(注意内存单位默认是M, 所以这里写81920):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>81920<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>24<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外注意,我们必须重启YARN才可以使得配置生效,所以执行<code>stop-yarn.sh</code>后<code>start-yarn.sh</code>,再到8088端口去看就可以看到可用内存已经设置成功.</p>
<h2 id="伪分布式-Container-is-running-beyond-memory-limits">伪分布式: <a href="https://stackoverflow.com/questions/21005643/container-is-running-beyond-memory-limits">Container is running beyond memory limits</a></h2>
<p>报错类似<code>Container [pid=28920,containerID=container_1389136889967_0001_01_000121] is running beyond virtual memory limits. Current usage: 1.2 GB of 1 GB physical memory used; 2.2 GB of 2.1 GB virtual memory used. Killing container.</code></p>
<p>参考标题链接给的解决方案,可以调整<code>yarn.nodemanager.vmem-pmem-ratio</code>或者关闭虚拟内存检查(不推荐).</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Scala与Spark使用</title>
    <url>/2020/02/23/Linux%E4%B8%8BScala%E4%B8%8ESpark%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概览-4">概览</h2>
<p>原生Spark与Scala的使用。</p>
<h2 id="安装-2">安装</h2>
<p>参考林子雨老师教程<a href="https://dblab.xmu.edu.cn/blog/1307-2/">Spark的安装和使用</a>。</p>
<h2 id="使用">使用</h2>
<h3 id="PySpark安装与使用">PySpark安装与使用</h3>
<h4 id="安装-从Spark复制文件">安装: 从Spark复制文件</h4>
<p>在安装好Spark(目前自己电脑是在<code>/home/shensir/Application/spark/</code>)，并设置好环境变量之后，在终端直接运行<code>pyspark</code>就可以直接运行。此时在终端通过<code>which pyspark</code>也可以打印出上述路径。但是要想在脚本中使用还需要做额外的配置。</p>
<p>在安装好Spark之后，将<code>/home/shensir/Application/spark/bin/pyspark</code>文件夹直接复制到Python的库文件目录下即可，比如我想在conda的虚拟环境<code>ML</code>中使用，那么就将上述<code>pyspark</code>文件夹直接复制到<code>/home/shensir/anaconda3/envs/ML/lib/python3.6/site-packages</code>即可在脚本中使用，这是安装原生Spark后使用PySpark的方法之一。可以通过在该虚拟环境打开IPython，并运行<code>import pypsark</code>就行测试。</p>
<blockquote>
<p>我开始在测试的时候会报错，说是少py4j库，直接conda install py4j，然后测试就可以了。</p>
</blockquote>
<h4 id="安装-直接安装PySpark第三方库">安装: 直接安装PySpark第三方库</h4>
<p>我们也可以直接使用PySpark，即通过第三库的方式直接安装使用. 比如我们可以新创建一个虚拟的conda环境，然后在该环境内部通过pip或者conda进行安装。安装完成后我们进入该虚拟环境，终端输入<code>which pyspark</code>会发现此时的路径是在虚拟环境内部的，比如我这里在虚拟环境<code>myspark</code>中安装，得到的路径就是<code>/home/shensir/anaconda3/envs/myspark/bin/pyspark</code>. 此时我们可以在终端和脚本中任意调用PySpark使用了。</p>
<h4 id="使用-IPython启动PySpark-Shell">使用: IPython启动PySpark Shell</h4>
<p>在上述安装完成的时候，终端输入<code>pyspark</code>会进入默认的IDLE,而不是IPython, 那么我们如何设置其以IPython启动呢？答案就是在上面的提到的路径。无论使用上述那种方法安装，我们通过<code>which pyspark</code>定位到PySpark的路径，然后直接编辑该文件即可,比如我们得到的路径为<code>/home/shensir/anaconda3/envs/myspark/bin/pyspark</code>，通过<code>vim /home/shensir/anaconda3/envs/myspark/bin/pyspark</code>打开，文件的最后是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYSPARK_DRIVER_PYTHON</span><br><span class="line">export PYSPARK_DRIVER_PYTHON_OPTS</span><br><span class="line">exec &quot;$&#123;SPARK_HOME&#125;&quot;/bin/spark-submit pyspark-shell-main --name &quot;PySparkShell&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>只需要在最后设置<code>PYSPARK_DRIVER_PYTHON</code>为<code>ipython</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYSPARK_DRIVER_PYTHON=&quot;ipython&quot;</span><br></pre></td></tr></table></figure>
<p>最后注意一下这里版本上的差异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># In Spark 2.0, IPYTHON and IPYTHON_OPTS are removed and pyspark fails to launch if either option</span><br><span class="line"># is set in the user&#x27;s environment. Instead, users should set PYSPARK_DRIVER_PYTHON=ipython</span><br><span class="line"># to use IPython and set PYSPARK_DRIVER_PYTHON_OPTS to pass options when starting the Python driver</span><br><span class="line"># (e.g. PYSPARK_DRIVER_PYTHON_OPTS=&#x27;notebook&#x27;).  This supports full customization of the IPython</span><br><span class="line"># and executor Python executables.</span><br></pre></td></tr></table></figure>
<h4 id="使用-在Jupyter-Notebook使用PySpark">使用: 在Jupyter Notebook使用PySpark</h4>
<p>实际上只需要在Jupyter Notebook中添加该环境的Kernel就可以了，Kernel安装参考<a href="https://ipython.readthedocs.io/en/stable/install/kernel_install.html">文档</a>. 首先确保<code>ipykernel</code>库已经安装，安装直接通过<code>conda install ipykernel</code>即可。之后进入虚拟环境<code>conda activate myspark</code>， 终端执行<code>python -m ipykernel install --user --name myspark --display-name &quot;Python(pyspark)&quot;</code></p>
<p>根据文档，上面安装Kernel的格式为<code>python -m ipykernel install --user --name myenv --display-name &quot;Python (myenv)&quot;</code></p>
<p>这样我们就安装好了一个环境为<code>myspark</code>的Jupyter Notebook Kernel, 终端执行<code>jupyter notebook</code>进入，可以发现新的Kernel, 显示为<code>Python(pyspark)</code></p>
<h3 id="从本地-HDFS读取文件">从本地&amp;HDFS读取文件</h3>
<p>参考<a href="https://stackoverflow.com/questions/27299923/how-to-load-local-file-in-sc-textfile-instead-of-hdfs">stackoverflow</a></p>
<h4 id="从HDFS读取">从HDFS读取</h4>
<p>一般来说，我们执行下面的读取命令都是默认从HDFS读取文件</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data = sc.textFile(path)</span><br></pre></td></tr></table></figure>
<p>而且要注意的是，目录默认不是HDFS的根目录，而是在<code>/user/用户名</code>,我这里就是在<code>/user/shensir</code>，所以要读取上层或者其他目录下的文件可以使用相对路径，比如<code>'../../data/bike-data'</code>来读取根目录的<code>data</code>文件夹下的<code>bike-data</code>文件.</p>
<h4 id="从本地读取">从本地读取</h4>
<p>要想在本地读取也很简单，需要用如下方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = sc.textFile(&quot;file://&quot; + path)</span><br></pre></td></tr></table></figure>
<p>这里的<code>path</code>为本地文件的绝对路径，暂时还不知道如何使用相对路径。</p>
<h3 id="使用YARN">使用YARN</h3>
<p>配置Spark On YARN. 首先在配置Hadoop的时候根据<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html#YARN_on_a_Single_Node">Hadoop: Setting up a Single Node Cluster</a>对YARN进行一定的配置，主要是对<code>/home/shensir/Application/hadoop/etc/hadoop</code>文件夹下的<code>mapred-site.xml</code>和<code>yarn-site.xml</code>进行配置，具体内容参考链接。</p>
<p>之后将任务提交到YARN会出现错误<code>java.nio.channels.ClosedChannelException</code>,主要原因是在YARN默认配置下我们的内存不够分配。这里需要根据自己机器的配置来合理设定，不过现在暂时可以采取关闭这个虚拟内存检测的方法，就是在<code>yarn-site.xml</code>中加入如下配置(不推荐，暂时设置)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>总之，这样可以先将任务RUN起来。参考<a href="https://blog.csdn.net/caiwenguang1992/article/details/77574182">这里</a></p>
<h4 id="Spark-History-Server使用">Spark History Server使用</h4>
<p>参考<a href="https://docs.cloudera.com/documentation/enterprise/5-6-x/topics/admin_spark_history_server.html">cloudera</a>配置。首先创建存放历史文件的文件夹<code>hdfs dfs -mkdir -p logs/history</code></p>
<blockquote>
<p>注意这里-p的意思是如果没有parent directory则一并创建。与之相反的是删除时的-rm -r</p>
</blockquote>
<p>之后设置权限(这里还另外与用户组的配置等相关，这里可以暂时不管)，直接赋权<code>hdfs dfs -chmod -R 1777 /user/shensir/logs/history</code></p>
<p>之后修改文件<code>/home/shensir/Application/spark/conf/spark-defaults.conf</code>， 如果没有就从同文件夹下的<code>spark-defaults.conf.template</code>复制过来，添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spark.eventLog.enabled=true</span><br><span class="line">spark.eventLog.dir= hdfs://localhost:9000/user/shensir/logs/history</span><br><span class="line">spark.history.fs.logDirectory=hdfs://localhost:9000/user/shensir/logs/history</span><br><span class="line">spark.history.ui.port=18080</span><br><span class="line">spark.yarn.historyServer.address=http://localhost:18080</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>localhost:9000</code>就是<code>namenode_host:namenode_port</code>.上面两个路径的更多讨论见<a href="https://stackoverflow.com/questions/32001248/whats-the-difference-between-spark-eventlog-dir-and-spark-history-fs-logdirecto">stackoverflow</a></p>
</blockquote>
<p>之后终端运行<code>start-history-server.sh</code>打开history server, 通过jps看到可以看到<code>HistoryServer</code>已经启动.注意此时终端运行<code>jps</code>应该显示以下几个节点的正确运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25202 ResourceManager</span><br><span class="line">19539 Jps</span><br><span class="line">3701 HistoryServer</span><br><span class="line">24936 SecondaryNameNode</span><br><span class="line">25355 NodeManager</span><br><span class="line">24508 NameNode</span><br><span class="line">24686 DataNode</span><br></pre></td></tr></table></figure>
<p>此时就可以使用<code>spark-shell --master yarn</code>, <code>pyspark --master yarn</code>, <code>spark-submit xxx.py --master yarn</code>开始任务的执行了，打开<code>http://localhost:8088</code>可以看到YARN的WEB UI，对于完成的Application，点击后面的History便可以重建Spark UI，目标地址类似如下形式<code>http://localhost:18080/history/application_1589083440750_0005/jobs/</code></p>
<p>同时，浏览器访问<code>http://localhost:9870/explorer.html#/user/shensir/logs/history</code>即可以在HDFS文件中看到上面的历史文件.</p>
<h2 id="问题解决">问题解决</h2>
<h3 id="SBT换源问题">SBT换源问题</h3>
<p>这个真的是众所周知，林老师也是一提，网上的答案也大多是错的！错的很微妙…</p>
<p>错的教程就是类似<a href="https://www.jianshu.com/p/8d3ded620051">这样</a>， 正确的是<a href="https://blog.csdn.net/weixin_41115760/article/details/89034839">这样</a>, 有什么区别呢，就是相差一个<code>s</code>,也就是说文件<code>~/.sbt/repositories</code>的内容应该是下面这样(注意是<code>https</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[repositories]</span><br><span class="line">local</span><br><span class="line">osc: https://maven.aliyun.com/nexus/content/groups/public/</span><br><span class="line">typesafe: https://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">sonatype-oss-releases</span><br><span class="line">maven-central</span><br><span class="line">sonatype-oss-snapshots</span><br></pre></td></tr></table></figure>
<p>配置成功的标志是发现下面输出的下载地址为<code>https://maven.aliyun.com/nexus/content/groups/public/...</code>开头，当然还有飞起的速度:-)</p>
<blockquote>
<p>还有个隐藏的问题就是在公司的时候要注意设置公司的代理IP</p>
</blockquote>
<h3 id="Spark-ERROR-Failed-to-construct-terminal-falling-back-to-unsupported">[Spark-ERROR] Failed to construct terminal; falling back to unsupported</h3>
<p>启动<code>spark-shell</code>的时候出现这行报错，通过<code>~/.zshrc</code>添加<code>export TERM=xterm-color</code>解决，貌似这是<code>sbt</code>的锅…参考<a href="https://github.com/sbt/sbt/issues/3240">Github</a></p>
<h3 id="Spark-WARN-NativeCodeLoader-Unable-to-load-native-hadoop-library">[Spark-WARN] NativeCodeLoader: Unable to load native-hadoop library</h3>
<p>也是启动<code>spark-shell</code>的时候出现的报错。通过<code>vim ./conf/spark-env.sh</code>编辑，在最后加入<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HADOOP_HOME/lib/native</code>即可。参考<a href="https://www.stefaanlippens.net/spark-native-hadoop.html">&quot;Native-Hadoop&quot; Library Load Issues with Spark</a></p>
<h3 id="伪分布式-启动PySpark或者Spark-Shell时设置的executor个数不生效">伪分布式: 启动PySpark或者Spark-Shell时设置的executor个数不生效</h3>
<p>比如终端执行<code>pyspark --master yarn --num-executors 4 --executor-memory 4G</code>,发现启动正常,但是到4040端口看executor个数会发现executor instance并没有4个.原因是资源分配不够,如果当前伪分布式节点资源够用的话,参考<a href="https://datahonor.com/2020/02/23/Linux%E4%B8%8BHadoop%E4%BD%BF%E7%94%A8/">Linux下Hadoop使用</a>中的解决方案,即在配置文件<code>yarn-site.xml</code>设置当前节点可用资源. 参考<a href="https://stackoverflow.com/questions/29940711/apache-spark-setting-executor-instances-does-not-change-the-executors">Apache Spark: setting executor instances does not change the executors</a>.</p>
<h3 id="伪分布式-Total-size-of-serialized-results-of-16-tasks-1048-5-MB-is-bigger-than-spark-driver-maxResultSize-1024-0-MB">伪分布式: <a href="https://stackoverflow.com/questions/47996396/total-size-of-serialized-results-of-16-tasks-1048-5-mb-is-bigger-than-spark-dr">Total size of serialized results of 16 tasks (1048.5 MB) is bigger than spark.driver.maxResultSize (1024.0 MB)</a></h3>
<p>参考链接方法,在<code>conf/spark-defaults.conf</code>中添加<code>spark.driver.maxResultSize=4g</code>, 设置Master可以接受的结果最大为4G, 注意这样设置要保证Master分配的内存一定是要大于4G的.</p>
<p>###　伪分布式：<a href="https://stackoverflow.com/questions/21138751/spark-java-lang-outofmemoryerror-java-heap-space">Spark java.lang.OutOfMemoryError: Java heap space</a></p>
<p>其实这个就是堆内存不够了，下面的解答中有让设置<code>spark.storage.memoryFraction</code>参数的(在<code>conf/spark-default.conf</code>)，但是这个参数已经在Spark1.6之后已经废除了，因为用于缓存和用于堆的内存已经统一。所以还是先看看有没有数据倾斜，然后不行就只能加内存了。</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下载百度云文件——Aria2</title>
    <url>/2019/04/14/Linux%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E6%96%87%E4%BB%B6%E2%80%94%E2%80%94Aria2/</url>
    <content><![CDATA[<h3 id="Overview-27">Overview</h3>
<p>如题，偶尔需要从百度云下载文件，发现用<code>Aria2</code>+浏览器插件的模式挺好用的。</p>
<h3 id="Steps">Steps</h3>
<p>首先安装Firefox的插件<a href="https://addons.mozilla.org/zh-CN/firefox/addon/baidu-pan-exporter/"><code>网盘助手</code></a>。安装好重启下浏览器。</p>
<p>在安装<code>Aria2</code>,命令<code>sudo apt-get install aria2</code>。这之后需要对其进行一些配置，参考<a href="https://www.jianshu.com/p/6e6a02e1f15e">这里</a>.</p>
<p>这样，再次在浏览百度云文件的时候，会出现<code>导出下载</code>选项，后即可自动启动下载任务。之后可以浏览器登录<code>http://aria2c.com/</code>查看下载进度。</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十四：Look-up tables</title>
    <url>/2017/05/04/Look-up-tables/</url>
    <content><![CDATA[<h5 id="Overview-28">Overview</h5>
<p>在处理图像的时候，我们可能需要对所有的像素点，根据其像素值的大小，统一进行一个映射的操作，这个时候我们就需要look-up tables来完成这项工作。</p>
<blockquote>
<p>A look-up table is a simple one-to-one (or many-to-one) function that defines how pixel values are transformed into new values. It is a 1D array with, in the case of regular gray-level images, 256 entries.</p>
<p>Entry i of the table gives you the new intensity value of the corresponding gray level, which is expressed as follows:<br>
<code>newIntensity= lookup[oldIntensity];</code></p>
</blockquote>
<h5 id="Code-21">Code</h5>
<h6 id="一般的使用方法">一般的使用方法</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">getlut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">lut</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)&#123;</span><br><span class="line"><span class="comment">//0 becomes 255, 1 becomes 254, etc</span></span><br><span class="line">        lut.<span class="built_in">at</span>&lt;uchar&gt;(i) = <span class="number">255</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">getStrechlut</span><span class="params">(cv::Mat image, cv::Mat hist)</span></span>&#123;</span><br><span class="line">    <span class="comment">//number of pixel in percentile</span></span><br><span class="line">    <span class="type">float</span> percentile = <span class="number">0.01</span>;</span><br><span class="line">    <span class="type">float</span> number = image.<span class="built_in">total</span>()*percentile;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> imin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> count=<span class="number">0.0</span>;imin&lt;<span class="number">256</span>;imin++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((count+=hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(imin)) &gt;= number)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> imax=<span class="number">255</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> count = <span class="number">0.0</span>; imax &gt;= <span class="number">0</span>; imax--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((count+=hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(imax)) &gt;= number)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">lut</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)&#123;</span><br><span class="line">        lut.<span class="built_in">at</span>&lt;uchar&gt;(i) = <span class="number">255.0</span>*(i-imin)/(imax-imin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lut;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>,<span class="number">0</span>); <span class="comment">// gray</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// The histogram object</span></span><br><span class="line">    Histogram1D h;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Histogram&quot;</span>, h.<span class="built_in">getHistogramImage</span>(image));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Compute the histogram</span></span><br><span class="line">    cv::Mat histo = h.<span class="built_in">getHistogram</span>(image);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get lut and apply</span></span><br><span class="line">    cv::Mat lut = <span class="built_in">getlut</span>();</span><br><span class="line">    cv::Mat result = h.<span class="built_in">applyLookUp</span>(image, lut);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;inverse lut image&quot;</span>, result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//get strech lut and apply</span></span><br><span class="line">    cv::Mat strechlut = <span class="built_in">getStrechlut</span>(image, histo);</span><br><span class="line">    cv::Mat strechresult = h.<span class="built_in">applyLookUp</span>(image, strechlut);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;strech lut histo&quot;</span>, h.<span class="built_in">getHistogramImage</span>(strechresult));</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;strech lut image&quot;</span>, strechresult);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170504/Selection_050414%3A18%3A23.png" alt=""></p>
<h6 id="对之前颜色空间缩减的改进">对之前颜色空间缩减的改进</h6>
<p>之前<a href="http://datahonor.com/2017/04/09/OPenCV-%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E7%BC%A9%E5%87%8F%E4%B8%8E%E9%81%8D%E5%8E%86/">颜色空间缩减</a> 时，我们用了手动遍历的方法进行修改对应的像素值，我们可以用look-up tables进行简化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReduce</span><span class="params">(cv::Mat &amp;image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//creating the 1d lookup table</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">lookup</span><span class="params">(<span class="number">1</span>,<span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//defining the color reduction lookup</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">        lookup.<span class="built_in">at</span>&lt;uchar&gt;(i) = i/div*div+div/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//lookip table applied on all channels;</span></span><br><span class="line">    cv::<span class="built_in">LUT</span>(image, lookup, image);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Clone,保护原来图像不受损坏</span></span><br><span class="line">    cv::Mat imageClone = image.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">colorReduce</span>(imageClone, <span class="number">64</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, imageClone);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix in C</title>
    <url>/2018/01/08/Matrix-in-C/</url>
    <content><![CDATA[<h3 id="Overview-29">Overview</h3>
<p>最近在看<em>Data Stuctures Using C</em>，在做Arrays的作业时涉及到 pass 2D array (matrix) in a function的问题，这里作下总结，参考<a href="https://stackoverflow.com/questions/3911400/how-to-pass-2d-array-matrix-in-a-function-in-c">这里</a>.</p>
<h3 id="Code-22">Code</h3>
<p>这里要实现在函数中传递二维数组有三种方法。</p>
<h4 id="Use-an-array-of-arrays">Use an array of arrays</h4>
<p>相对来说，这种方法是最容易实现的，也是最好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 18-1-8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix1[nrow][ncol], <span class="type">int</span> matrix2[nrow][ncol],</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> matrix3[nrow][ncol])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">int</span> matrix1[nrow1][ncol1], <span class="type">int</span> matrix2[nrow2][ncol2], <span class="type">int</span> matrix3[nrow1][ncol2])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol], <span class="type">int</span> matrix3[ncol][nrow])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test data</span></span><br><span class="line"><span class="comment">// 1 3 5 7 9 1 2 3 4</span></span><br><span class="line"><span class="comment">// 2 4 6 8 0 1 2 3 4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> nrow, ncol;</span><br><span class="line">	nrow = <span class="number">3</span>;</span><br><span class="line">	ncol = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> matrix1[nrow][ncol];</span><br><span class="line">	<span class="type">int</span> matrix2[nrow][ncol];</span><br><span class="line">	<span class="type">int</span> matrix3[nrow][ncol];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">readMatrix</span>(nrow, ncol, matrix1);</span><br><span class="line">	<span class="built_in">showMatrix</span>(nrow, ncol, matrix1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">readMatrix</span>(nrow, ncol, matrix2);</span><br><span class="line">	<span class="built_in">showMatrix</span>(nrow, ncol, matrix2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m1 + m2 = &quot;</span>);</span><br><span class="line">	<span class="built_in">addMatrix</span>(nrow, ncol, matrix1, matrix2, matrix3);</span><br><span class="line">	<span class="built_in">showMatrix</span>(nrow, ncol, matrix3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m1 X m2 = &quot;</span>);</span><br><span class="line">	<span class="built_in">mulMatrix</span>(nrow, ncol, nrow, ncol, matrix1, matrix2, matrix3);</span><br><span class="line">	<span class="built_in">showMatrix</span>(nrow, ncol, matrix3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;transform matrix: &quot;</span>);</span><br><span class="line">	<span class="built_in">transMatrix</span>(nrow, ncol, matrix1, matrix3);</span><br><span class="line">	<span class="built_in">showMatrix</span>(ncol, nrow, matrix3);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol])</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter matrix data: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;matrix[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, matrix[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix1[nrow][ncol], <span class="type">int</span> matrix2[nrow][ncol],</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> matrix3[nrow][ncol])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			matrix3[i][j] = matrix1[i][j] + matrix2[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> matrix1[nrow1][ncol1], <span class="type">int</span> matrix2[nrow2][ncol2], <span class="type">int</span> matrix3[nrow1][ncol2])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow1; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol2; ++j) &#123;</span><br><span class="line">			matrix3[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nrow1; ++k) &#123;</span><br><span class="line">				matrix3[i][j] += matrix1[i][k] * matrix2[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> nrow, <span class="type">int</span> ncol, <span class="type">int</span> matrix[nrow][ncol], <span class="type">int</span> matrix3[ncol][nrow])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			matrix3[j][i] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<pre><code>Enter matrix data: 1 3 5 7 9 1 2 3 4

   1    3    5 
   7    9    1 
   2    3    4 
Enter matrix data: 2 4 6 8 0 1 2 3 4

   2    4    6 
   8    0    1 
   2    3    4 
m1 + m2 = 
   3    7   11 
  15    9    2 
   4    6    8 
m1 X m2 = 
  36   19   29 
  88   31   55 
  36   20   31 
transform matrix: 
   1    7    2 
   3    9    3 
   5    1    4 
</code></pre>
<h4 id="Use-an-array-of-pointers-to-arrays">Use an array of pointers to arrays</h4>
<p>用二重指针实现二维数组也是差不多的，只不过当中涉及动态分配内存的问题。而这里又涉及到多次分配和释放内存的问题，所以定义了分配和释放内存的函数，然后就变成了三重指针，感觉可读性不如上面的好…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">(<span class="type">int</span> ***pmatrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeMemory</span><span class="params">(<span class="type">int</span> ***pmatrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> **matrix1, <span class="type">int</span> **matrix2, <span class="type">int</span> **matrix3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> **matrix1, <span class="type">int</span> **matrix2, <span class="type">int</span> **matrix3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> **matrix3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test data</span></span><br><span class="line"><span class="comment">// 1 3 5 7 9 1 2 3 4</span></span><br><span class="line"><span class="comment">// 2 4 6 8 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> nrow = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> ncol = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> **matrix1;</span><br><span class="line">	<span class="type">int</span> **matrix2;</span><br><span class="line">	<span class="type">int</span> **matrix3;</span><br><span class="line">	<span class="built_in">allocateMemory</span>(&amp;matrix1, nrow, ncol);</span><br><span class="line">	<span class="built_in">allocateMemory</span>(&amp;matrix2, nrow, ncol);</span><br><span class="line">	<span class="built_in">allocateMemory</span>(&amp;matrix3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">readMatrix</span>(matrix1, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(matrix1, nrow, ncol);</span><br><span class="line">	<span class="built_in">readMatrix</span>(matrix2, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(matrix2, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m1 + m2 = &quot;</span>);</span><br><span class="line">	<span class="built_in">addMatrix</span>(matrix1, matrix2, matrix3, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(matrix3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;m1 X m2 = &quot;</span>);</span><br><span class="line">	<span class="built_in">mulMatrix</span>(matrix1, matrix2, matrix3, nrow, ncol, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(matrix3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;transform matrix = &quot;</span>);</span><br><span class="line">	<span class="built_in">transMatrix</span>(matrix1, matrix3, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(matrix3, ncol, nrow);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">freeMemory</span>(&amp;matrix1, nrow, ncol);</span><br><span class="line">	<span class="built_in">freeMemory</span>(&amp;matrix2, nrow, ncol);</span><br><span class="line">	<span class="built_in">freeMemory</span>(&amp;matrix3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateMemory</span><span class="params">(<span class="type">int</span> ***pmatrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	*pmatrix = <span class="built_in">malloc</span>(nrow * <span class="keyword">sizeof</span> * *pmatrix);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		(*pmatrix)[i] = <span class="built_in">malloc</span>(ncol * <span class="keyword">sizeof</span> * (*pmatrix)[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeMemory</span><span class="params">(<span class="type">int</span> ***pmatrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nrow; ++j) &#123;</span><br><span class="line">		<span class="built_in">free</span>((*pmatrix)[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(*pmatrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter matrix data: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, *(matrix+i)+j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, *(*(matrix + i) + j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> **matrix1, <span class="type">int</span> **matrix2, <span class="type">int</span>**matrix3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			matrix3[i][j] = matrix1[i][j]+matrix2[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> **matrix1, <span class="type">int</span> **matrix2, <span class="type">int</span> **matrix3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow1; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol2; ++j) &#123;</span><br><span class="line">			matrix3[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; ncol1; ++k) &#123;</span><br><span class="line">				matrix3[i][j] += matrix1[i][k] * matrix2[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> **matrix3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			matrix3[j][i] = matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Enter matrix data: 1 3 5 7 9 1 2 3 4

  1   3   5 
  7   9   1 
  2   3   4 
Enter matrix data: 2 4 6 8 0 1 2 3 4

  2   4   6 
  8   0   1 
  2   3   4 
m1 + m2 = 
  3   7  11 
 15   9   2 
  4   6   8 
m1 X m2 = 
 36  19  29 
 88  31  55 
 36  20  31 
transform matrix = 
  1   7   2 
  3   9   3 
  5   1   4 
</code></pre>
<h4 id="Use-a-1-dimensional-array-and-fixup-the-indices">Use a 1-dimensional array and fixup the indices</h4>
<p>一开始还没有看到这种方法的特别之处，但是看前面两种方法就能看出。第一种是用的静态的数组，第二种是动态的数组，而且这两种方法，也只能对应选择静态和动态。而第三种却是两者都可以——<em>This can be used with both statically allocated (fixed-size) and dynamically allocated arrays</em>, 而本质上<em>C considers a two-dimensional array as an array of one-dimensional arrays</em>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array2, <span class="type">int</span> *array3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array2, <span class="type">int</span> *array3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test data</span></span><br><span class="line"><span class="comment">// 1 3 5 7 9 1 2 3 4</span></span><br><span class="line"><span class="comment">// 2 4 6 8 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> nrow, ncol;</span><br><span class="line">	nrow = <span class="number">3</span>;</span><br><span class="line">	ncol = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> *array1;</span><br><span class="line">	<span class="type">int</span> *array2;</span><br><span class="line">	<span class="type">int</span> *array3;</span><br><span class="line">	<span class="comment">// get memory</span></span><br><span class="line">	array1 = <span class="built_in">malloc</span>(nrow * ncol * <span class="keyword">sizeof</span> *array1);</span><br><span class="line">	array2 = <span class="built_in">malloc</span>(nrow * ncol * <span class="keyword">sizeof</span> *array2);</span><br><span class="line">	array3 = <span class="built_in">malloc</span>(nrow * ncol * <span class="keyword">sizeof</span> *array3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">readMatrix</span>(array1, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(array1, nrow, ncol);</span><br><span class="line">	<span class="built_in">readMatrix</span>(array2, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(array2, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nm1+m2: \n&quot;</span>);</span><br><span class="line">	<span class="built_in">addMatrix</span>(array1, array2, array3, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(array3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nm1xm2: \n&quot;</span>);</span><br><span class="line">	<span class="built_in">mulMatrix</span>(array1, array2, array3, nrow, ncol, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(array3, nrow, ncol);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\ntrans m1: \n&quot;</span>);</span><br><span class="line">	<span class="built_in">transMatrix</span>(array1, array3, nrow, ncol);</span><br><span class="line">	<span class="built_in">showMatrix</span>(array3, ncol, nrow);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free memory</span></span><br><span class="line">	<span class="built_in">free</span>(array1);</span><br><span class="line">	<span class="built_in">free</span>(array2);</span><br><span class="line">	<span class="built_in">free</span>(array3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readMatrix</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter Matrix data: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;array[i * ncol + j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMatrix</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, array[i * ncol + j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array2, <span class="type">int</span> *array3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			array3[i * ncol + j] = array1[i * ncol + j] + array2[i * ncol + j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mulMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array2, <span class="type">int</span> *array3,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="type">int</span> nrow1, <span class="type">int</span> ncol1, <span class="type">int</span> nrow2, <span class="type">int</span> ncol2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow1; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol2; ++j) &#123;</span><br><span class="line">			array3[i * ncol2 + j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; ncol1; ++k) &#123;</span><br><span class="line">				array3[i * ncol2 + j] += array1[i * ncol1 + k] * array2[k * ncol2 + j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transMatrix</span><span class="params">(<span class="type">int</span> *array1, <span class="type">int</span> *array3, <span class="type">int</span> nrow, <span class="type">int</span> ncol)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nrow; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncol; ++j) &#123;</span><br><span class="line">			array3[j * nrow + i] = array1[i * ncol + j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>Enter Matrix data: 1 3 5 7 9 1 2 3 4

  1  3  5
  7  9  1
  2  3  4
Enter Matrix data: 2 4 6 8 0 1 2 3 4

  2  4  6
  8  0  1
  2  3  4

m1+m2: 

  3  7 11
 15  9  2
  4  6  8

m1xm2: 

 36 19 29
 88 31 55
 36 20 31

trans m1: 

  1  7  2
  3  9  3
  5  1  4
</code></pre>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十九：Morphalogical Operations</title>
    <url>/2017/05/15/Morphalogical-Operations/</url>
    <content><![CDATA[<h4 id="Overview-30">Overview</h4>
<p>一些图像的形态学操作，主要包括Erosion, Dilation, Closing 和 Opening.</p>
<p>它们之间有一些巧妙的关系：</p>
<p>Erosion and Dilation:</p>
<blockquote>
<p>The erosion of an image is equivalent to the complement of the<br>
dilation of the complement image<br>
The dilation of an image is equivalent to the complement of the<br>
erosion of the complement image</p>
</blockquote>
<p>Closing and Opening:</p>
<blockquote>
<p>The opening and closing filters are simply defined in terms of the basic<br>
erosion and dilation operations. Closing is defined as the erosion of the<br>
dilation of an image. Opening is defined as the dilation of the erosion of<br>
an image.</p>
</blockquote>
<p>最后注意下Idempotent：</p>
<blockquote>
<p>Note that applying the same opening (and similarly the closing) operator on an image several times has no effect. Indeed, as the holes have been filled by the first opening filter, an additional application of the same filter will not produce any other changes to the image. In mathematical terms, these operators are said to be idempotent.</p>
</blockquote>
<p>对这些概念的理解可以参考Youtube的一套视频，讲的挺好(自备梯子:-)：</p>
<p><a href="https://www.youtube.com/watch?v=BldfktFW1bQ">传送门</a></p>
<h4 id="Code-23">Code</h4>
<h5 id="Erosion-and-Dilation">Erosion and Dilation</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/binary.bmp&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// Erode the image</span></span><br><span class="line">    <span class="comment">// with the default 3x3 structuring element (SE)</span></span><br><span class="line">    cv::Mat eroded;  <span class="comment">// the destination image</span></span><br><span class="line">    cv::<span class="built_in">erode</span>(image, eroded, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;eroded&quot;</span>, eroded);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Erode the image with a larger SE</span></span><br><span class="line">    <span class="comment">// create a 7x7 mat with containing all ls</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">element</span><span class="params">(<span class="number">7</span>, <span class="number">7</span>, CV_8U, cv::Scalar(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// erode the image with that SE</span></span><br><span class="line">    cv::<span class="built_in">erode</span>(image, eroded, element);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Eroded by 7x7 elements&quot;</span>, eroded);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Erode the image 3 times</span></span><br><span class="line">    cv::<span class="built_in">erode</span>(image, eroded, cv::<span class="built_in">Mat</span>(), cv::<span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), <span class="number">3</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;eroded 3 times&quot;</span>, eroded);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dilate the image</span></span><br><span class="line">    cv:: Mat dilate;</span><br><span class="line">    cv::<span class="built_in">dilate</span>(image, dilate, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;dilate&quot;</span>, dilate);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170515/Selection_051502.png" alt=""></p>
<h5 id="Closing-and-Opening">Closing and Opening</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/binary.bmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// Close the image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">element5</span><span class="params">(<span class="number">5</span> ,<span class="number">5</span>, CV_8U, cv::Scalar(<span class="number">1</span>))</span></span>;</span><br><span class="line">    cv::Mat closed;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, closed,   <span class="comment">// input and output</span></span><br><span class="line">                     cv::MORPH_CLOSE,  <span class="comment">// operator code</span></span><br><span class="line">                     element5);  <span class="comment">// structuring element</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Cloed&quot;</span>, closed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opening the image</span></span><br><span class="line">    cv::Mat opening;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, opening,   <span class="comment">// input and output</span></span><br><span class="line">                     cv::MORPH_OPEN,  <span class="comment">// operator code</span></span><br><span class="line">                     element5);  <span class="comment">// structuring element</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;opening&quot;</span>, opening);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// opening first, then closing</span></span><br><span class="line">    cv::Mat open_closed;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, open_closed, cv::MORPH_OPEN, element5);</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(open_closed, open_closed, cv::MORPH_CLOSE, element5);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;open_closed&quot;</span>, open_closed);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170515/Selection_051503.png" alt=""></p>
<h5 id="morphological-operators-on-gray-level-images">morphological operators on gray-level images</h5>
<p>关于灰度图的形态学操作：</p>
<blockquote>
<p>A good way to understand the effect of morphological operators on a<br>
gray-level image is to consider an image as a topological relief in which<br>
the gray levels correspond to elevation (or altitude).</p>
</blockquote>
<p>图像梯度与顶帽变换：</p>
<blockquote>
<p>morphological gradient: extracting the edges of an image<br>
top-hat transform:  extract local small foreground objects</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the gradient image using a 3x3 structuring element</span></span><br><span class="line">    cv::Mat result;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, result, cv::MORPH_GRADIENT, cv::<span class="built_in">Mat</span>());</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;gradient&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply the black top-hat transform using 7x7 structuring element</span></span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/book.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">element7</span><span class="params">(<span class="number">7</span>, <span class="number">7</span>, CV_8U, cv::Scalar(<span class="number">1</span>))</span></span>;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(image, result, cv::MORPH_BLACKHAT, element7);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;black hat&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052401.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二：Mouse trackbar</title>
    <url>/2017/04/27/Mouse-trackbar/</url>
    <content><![CDATA[<h4 id="Overview-31">Overview</h4>
<p>关于OpenCV如何捕捉鼠标动作进行图片的交互。这里回调函数可能有点不太好理解，简单讲就是说，在cv::setMouseCallback之后，在指定的窗口，鼠标动作将会被捕捉，根据捕捉到的动作，按照onMouse的定义进行操作，之后回到捕捉状态。如果没有鼠标动作，那么程序将会一直wait,等待退出。</p>
<h4 id="Code-24">Code</h4>
<h5 id="显示像素值">显示像素值</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mouse trackbar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/mangzai.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getImageInfo</span>(image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image );</span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">&quot;Original Image&quot;</span>, onMouse,</span><br><span class="line">                         <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;image));</span><br><span class="line">    <span class="built_in">cvWaitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMouse</span> <span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>*param)</span></span>&#123;</span><br><span class="line">    cv::Mat *im = <span class="built_in">reinterpret_cast</span>&lt;cv::Mat*&gt;(param);</span><br><span class="line">    <span class="keyword">switch</span> (event)&#123;</span><br><span class="line">        <span class="keyword">case</span> cv::EVENT_LBUTTONDOWN: <span class="comment">// left mouse button down event</span></span><br><span class="line">            <span class="comment">// display pixel value at (x,y)</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;) value is:&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(</span><br><span class="line">                              im-&gt;<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(x,y))) &lt;&lt;</span><br><span class="line">                      std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="动态模糊与做图">动态模糊与做图</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变量，保存滑动条的初始位置值</span></span><br><span class="line"><span class="type">int</span> blurAmount = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动条的回调函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onChange</span><span class="params">(<span class="type">int</span> pos, <span class="type">void</span>* userInput)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标的回调</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>, <span class="type">void</span>* userInput)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/tower.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Tower&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建滑动条</span></span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Tower Bar&quot;</span>, <span class="string">&quot;Tower&quot;</span>, &amp;blurAmount, <span class="number">30</span>, onChange, &amp;img);</span><br><span class="line">    <span class="built_in">setMouseCallback</span>(<span class="string">&quot;Tower&quot;</span>, onMouse, &amp;img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用onChange来初始化</span></span><br><span class="line">    <span class="built_in">onChange</span>(blurAmount, &amp;img);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁窗口</span></span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onChange</span><span class="params">(<span class="type">int</span> pos, <span class="type">void</span>* userInput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出的辅助变量</span></span><br><span class="line">    Mat imgBlur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像指针</span></span><br><span class="line">    Mat* img = (Mat*) userInput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用模糊滤波</span></span><br><span class="line">    <span class="built_in">blur</span>(*img, imgBlur, <span class="built_in">Size</span>(pos, pos));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示输出</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Tower&quot;</span>, imgBlur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>, <span class="type">void</span>* userInput)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event != EVENT_LBUTTONDOWN)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图像指针</span></span><br><span class="line">    Mat* img = (Mat*)userInput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制圆形</span></span><br><span class="line">    <span class="built_in">circle</span>(*img, <span class="built_in">Point</span>(x,y), <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">onChange</span>(blurAmount, img);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170515/Selection_051601.png" alt=""></p>
<h5 id="添加按钮">添加按钮</h5>
<p>这里，测试的时候没有成功，因为在编译OpenCV的时候没有添加Qt的支持，需要重新编译才行。这里先把代码放在这，有时间重新编译再测试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="type">bool</span> applyGray=<span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> applyBlur=<span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> applySobel=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyFilters</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat result;</span><br><span class="line">    img.<span class="built_in">copyTo</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(applyGray)&#123;</span><br><span class="line">        <span class="built_in">cvtColor</span>(result, result, COLOR_BGR2GRAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(applyBlur)&#123;</span><br><span class="line">        <span class="built_in">blur</span>(result, result, <span class="built_in">Size</span>(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(applySobel)&#123;</span><br><span class="line">        <span class="built_in">Sobel</span>(result, result, CV_8U, <span class="number">1</span>,<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Tower&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">grayCallback</span><span class="params">(<span class="type">int</span> state, <span class="type">void</span>*  userData)</span></span>&#123;</span><br><span class="line">    applyGray=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">applyFilters</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bgrCallback</span><span class="params">(<span class="type">int</span> state, <span class="type">void</span>*userData)</span></span>&#123;</span><br><span class="line">    applyGray = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">applyFilters</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">blurCallback</span><span class="params">(<span class="type">int</span> state, <span class="type">void</span>* userData)</span></span>&#123;</span><br><span class="line">    applyBlur = (<span class="type">bool</span>)state;</span><br><span class="line">    <span class="built_in">applyFilters</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sobelCallback</span><span class="params">(<span class="type">int</span> state, <span class="type">void</span>* userData)</span></span>&#123;</span><br><span class="line">    applySobel = !applySobel;</span><br><span class="line">    <span class="built_in">applyFilters</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    img = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/tower.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Tower&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    <span class="built_in">createButton</span>(<span class="string">&quot;Blur&quot;</span>, blurCallback);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有就是。。。开始以为安装Qt，在Qt运行才可以(其实并不是啦。。)，所以就在Qt下配置了下OpenCV。具体配置参考<a href="http://rodrigoberriel.com/2014/11/using-opencv-3-qt-creator-3-2-qt-5-3">这里</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql8.0 in Ubuntu16.04</title>
    <url>/2019/07/28/Mysql8-0-in-Ubuntu16-04/</url>
    <content><![CDATA[<h3 id="5-7版本更新到8-0">5.7版本更新到8.0</h3>
<p>好久每用过MySQL了，最近重新学下，发现已经更新到8.0了…原来的是5.7。不过在<a href="https://stackoverflow.com/questions/49963923/how-do-i-update-mysql-5-7-to-the-new-mysql-8-0">stackoverflow</a>查到更新是比较简单的。</p>
<p>更新的过程按照第一个答案说的直接执行就可以，这里不再重复。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nonparametric Statistics in R</title>
    <url>/2017/11/02/Nonparametric-Statistics-in-R/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>关于非参数统计，感觉还是比较实用的。这里记录下在R中的对应实现。本来打算自己把全部的方法总结下，但是看到了<a href="https://rpubs.com/xuefliang/153258">这个</a>，有前辈已经总结的比较好了。所以这里只是在此基础上进行一些更加详细的补充。</p>
<p>参考的书也是我们的教科书，中国统计出版社《非参数统计》，吴喜之，赵博娟两位老师写的。非常佩服作者基本全是自己实现全部的方法，虽说注释不太友好…偶尔有些错误。此外打算参考<em>Applied Nonparametric Statistical Methods</em>和<a href="https://onlinecourses.science.psu.edu/stat464/node/2">PSU的课程</a>一起学习.</p>
<h3 id="教科书代码">教科书代码</h3>
<p>放在<a href="https://github.com/coolStatistic/NonparameterStat-Course-WIth-R">Github</a></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Nonparametric Statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy日常积累</title>
    <url>/2017/03/06/Numpy%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>阅读书籍 <em>NumPy Beginner’s Guide [Second Edition]</em>，一些关于使用Numpy的笔记。</p>
<h5 id="1-ravel-and-flatten">1. ravel and flatten</h5>
<blockquote>
<p>参考<a href="http://stackoverflow.com/questions/28930465/what-is-the-difference-between-flatten-and-ravel-functions-in-numpy">这里</a></p>
<p>The difference is that flatten always returns a copy and ravel returns a view of the original array whenever possible. This isn’t visible in the printed output, but if you modify the array returned by ravel, it may modify the entries in the original array. If you modify the entries in an array returned from flatten this will never happen. ravel will often be faster since no memory is copied, but you have to be more careful about modifying the array it returns.</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/numpy/3.png" alt=""></p>
<h5 id="2-reshape-and-resize">2. reshape and resize</h5>
<blockquote>
<p>The resize method works just like the reshape method, but modifies the<br>
array it operates on</p>
</blockquote>
<blockquote>
<p>即，resize改变操作的对象，而reshape不改变。</p>
</blockquote>
<h5 id="3-Dates">3. Dates</h5>
<p>关于np.loadtxt函数导入日期的问题。</p>
<h6 id="3-1-converters">3.1 converters</h6>
<blockquote>
<p>converters : dict, optional<br>
A dictionary mapping column number to a function that will convert<br>
that column to a float.  E.g., if column 0 is a date string:<br>
<code>converters = &#123;0: datestr2num&#125;</code>.  Converters can also be used to<br>
provide a default value for missing data (but see also <code>genfromtxt</code>):<br>
<code>converters = &#123;3: lambda s: float(s.strip() or 0)&#125;</code>.  Default: None.</p>
</blockquote>
<h6 id="3-2-binary-to-str">3.2 binary to str</h6>
<p>首先，我们运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dates, close=np.loadtxt(<span class="string">&#x27;data.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, usecols=(<span class="number">1</span>,<span class="number">6</span>), unpack=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>结果报错：</p>
<blockquote>
<p><strong>ValueError: could not convert string to float: b’28-01-2011’</strong></p>
</blockquote>
<p>于是我们编写指定日期格式的函数，再次导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datestr2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> datetime.strptime(s, <span class="string">&quot;%d-%m-%Y&quot;</span>).date().weekday()</span><br><span class="line">    </span><br><span class="line">dates, close=np.loadtxt(<span class="string">&#x27;data.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, usecols=(<span class="number">1</span>,<span class="number">6</span>),</span><br><span class="line">converters=&#123;<span class="number">1</span>: datestr2num&#125;, unpack=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还是报错：</p>
<blockquote>
<p><strong>TypeError: strptime() argument 1 must be str, not bytes</strong></p>
</blockquote>
<p>这次是因为日期列是二进制的格式，而我们的strptime要求参数是字符型。<br>
修改datestr2num函数即可。继续运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datestr2num</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> datetime.strptime(s.decode(<span class="string">&#x27;ascii&#x27;</span>), <span class="string">&quot;%d-%m-%Y&quot;</span>).date().weekday()</span><br><span class="line">    </span><br><span class="line">dates, close=np.loadtxt(<span class="string">&#x27;data.csv&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>, usecols=(<span class="number">1</span>,<span class="number">6</span>),</span><br><span class="line">converters=&#123;<span class="number">1</span>: datestr2num&#125;, unpack=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这次OK了!</p>
<p>参考：*NumPy Beginner’s Guide [Second Edition] *，<a href="http://stackoverflow.com/questions/21117311/time-strptime-argument-0-must-be-str-not-bytes">stackoverflow</a></p>
<h5 id="4-argmax-argmin">4. argmax &amp; argmin</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/numpy/4.png" alt=""></p>
<p>也就是说，在使用argmax[argmin]时，我们一定注意数组中没有nan,否则我们将会得到错误的结果而找不出原因。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记六：图片颜色空间缩减与遍历</title>
    <url>/2017/04/09/OPenCV-%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E7%BC%A9%E5%87%8F%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h5 id="概览-5">概览</h5>
<p>记录下遍历图片的以及缩减图片颜色空间的几种办法，主要是记录下关于位运算进行像素的按位操作。<br>
首先我们直观上看下图片的存储格式：</p>
<ul>
<li>
<p>[ ] 灰度图像<br>
-<img src="http://img.blog.csdn.net/20160425221258898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
</li>
<li>
<p>[ ] 彩色图像<br>
<img src="http://img.blog.csdn.net/20160425221306945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
</li>
</ul>
<h5 id="几种遍历的方法">几种遍历的方法</h5>
<h6 id="利用指针进行">利用指针进行</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReducePtr</span><span class="params">(cv::Mat image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nl = image.rows; <span class="comment">// number of lines</span></span><br><span class="line">    <span class="comment">// total number or element per ;ine</span></span><br><span class="line">    <span class="type">int</span> nc = image.cols * image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nl; j++)&#123;</span><br><span class="line">        <span class="comment">//get the address of row j</span></span><br><span class="line">        uchar* data = image.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nc;i++)&#123;</span><br><span class="line">            <span class="comment">// process each pixel=======================</span></span><br><span class="line"></span><br><span class="line">            data[i] = data[i]/div*div + div/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// OR in this way</span></span><br><span class="line">            <span class="comment">//data[i] = (data[i]/div)*div + div/2;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//end of pixel processing=====================</span></span><br><span class="line">        &#125;<span class="comment">//end of line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解reduction核心算法,这里假设div为10.</span></span><br><span class="line"><span class="comment">// 去除‘余数’， 拉向中心</span></span><br><span class="line"><span class="comment">// 11  --&gt; data[i]/div*div + div/2 --&gt; 10 + 5 --&gt; 15</span></span><br><span class="line"><span class="comment">// 16  --&gt; data[i]/div*div + div/2 --&gt; 10 + 5 --&gt; 15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Clone,保护原来图像不受损坏</span></span><br><span class="line">    cv::Mat imageClone = image.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">colorReducePtr</span>(imageClone, <span class="number">64</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, imageClone);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="位运算">位运算</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReduceBit</span><span class="params">(cv::Mat &amp;image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nl = image.rows;</span><br><span class="line">    <span class="type">int</span> nc = image.cols*image.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="keyword">if</span>(image.<span class="built_in">isContinuous</span>())&#123;</span><br><span class="line">        nc = nc*nl;</span><br><span class="line">        nl = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(</span><br><span class="line">            <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(div))/<span class="built_in">log</span>(<span class="number">2.0</span>)+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    uchar mask = <span class="number">0xFF</span>&lt;&lt;n;</span><br><span class="line">    uchar div2 = div&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nl;j++)&#123;</span><br><span class="line">        uchar* data = image.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nc;i++)&#123;</span><br><span class="line">            *data &amp;= mask;   <span class="comment">//a &amp;= b; set a to a &amp; b</span></span><br><span class="line">            *data++ += div2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">colorReduceBit</span>(image);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>几点解释：</p>
<blockquote>
<p>0xFF&lt;&lt;n 是为左移运算，这里简单说就是1111 1111(0xFF的二进制表示)整体向左移动n个长度，右边空出部分用0补充。假设n=4,则结果为1111 0000</p>
</blockquote>
<blockquote>
<p><em>data &amp;= mask等价于</em>data = (<em>data &amp; mask),即先进行按位和再赋值给</em>data, 例如说*data = 11001100,那么根据上面叙述，n=4时mask=1111 0000 ，那么取按位和之后得到，1100 0000<br>
更直观地看，在这里div=64, 那么n=6, mask = 1100 0000, 也就是说，在按位的时候，每个像素点的二进制值的后六位将会被重置为0，只保留前两位。而1100 0000 = 192, 容易算出63&amp;192 = 0, 64&amp;192 = 64, 127&amp;192=64, 128&amp;192=128…很清楚的可以看出，0~255被分割为4段，每段单位为64。</p>
</blockquote>
<blockquote>
<p><em>data++ += div2;的运算等价于</em>data += div/2; data++[指针移动]，可以如下测试得到。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    *p++ += <span class="number">1</span>;</span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout&lt;&lt;p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>0x7ffe0d69780c<br>
2<br>
0x7ffe0d697810<br>
可以看到，a的值恰好增加了1，且指针p的位置增加了4,即一个单位int的长度。</p>
</blockquote>
<h6 id="Iterators">Iterators</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Iterators</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReduce</span><span class="params">(cv::Mat image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// div must be a power of 2</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(</span><br><span class="line">            <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(div))/<span class="built_in">log</span>(<span class="number">2.0</span>)+<span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// mask used to round the pixel value</span></span><br><span class="line">    uchar mask = <span class="number">0xFF</span>&lt;&lt;n;</span><br><span class="line">    uchar div2 = div&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get iterators</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scan all pixels</span></span><br><span class="line">    <span class="keyword">for</span>(;it!=itend;++it)&#123;</span><br><span class="line">        (*it)[<span class="number">0</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">0</span>] += div2;</span><br><span class="line"></span><br><span class="line">        (*it)[<span class="number">1</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">1</span>] += div2;</span><br><span class="line"></span><br><span class="line">        (*it)[<span class="number">2</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">2</span>] += div2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">colorReduce</span>(image);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="时间效率比较">时间效率比较</h5>
<p>这里，我们综合上面的三种方法进行时间效率的比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get run time [学习函数作为参数的用法]</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getTime</span><span class="params">(<span class="type">void</span>(*pfunc)(cv::Mat,<span class="type">int</span>), cv::Mat img,<span class="type">int</span> div)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> int64 start = cv::<span class="built_in">getTickCount</span>();</span><br><span class="line">    <span class="built_in">pfunc</span>(img, <span class="number">64</span>);</span><br><span class="line">    <span class="type">double</span> duration = (cv::<span class="built_in">getTickCount</span>()-start)/cv::<span class="built_in">getTickFrequency</span>();</span><br><span class="line">    std::cout&lt;&lt;duration&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> duration;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针，除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReducePtr</span><span class="params">(cv::Mat image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nl = image.rows; <span class="comment">// number of lines</span></span><br><span class="line">    <span class="comment">// total number or element per ;ine</span></span><br><span class="line">    <span class="type">int</span> nc = image.cols * image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nl; j++)&#123;</span><br><span class="line">        <span class="comment">// get the address of row j</span></span><br><span class="line">        uchar* data = image.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nc;i++)&#123;</span><br><span class="line">            <span class="comment">// process each pixel=======================</span></span><br><span class="line"></span><br><span class="line">            data[i] = data[i]/div*div + div/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// OR in this way</span></span><br><span class="line">            <span class="comment">//data[i] = (data[i]/div)*div + div/2;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//end of pixel processing=====================</span></span><br><span class="line">        &#125;<span class="comment">//end of line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//位运算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReduceBit</span><span class="params">(cv::Mat image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nl = image.rows;</span><br><span class="line">    <span class="type">int</span> nc = image.cols*image.<span class="built_in">channels</span>();</span><br><span class="line">    <span class="keyword">if</span>(image.<span class="built_in">isContinuous</span>())&#123;</span><br><span class="line">        nc = nc*nl;</span><br><span class="line">        nl = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四舍五入取指数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(</span><br><span class="line">            <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(div))/<span class="built_in">log</span>(<span class="number">2.0</span>)+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    uchar mask = <span class="number">0xFF</span>&lt;&lt;n;</span><br><span class="line">    uchar div2 = div&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nl;j++)&#123;</span><br><span class="line">        uchar* data = image.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nc;i++)&#123;</span><br><span class="line">            <span class="comment">// 下面这步等同于data[i] = data[i]/div*div</span></span><br><span class="line">            *data &amp;= mask;   <span class="comment">//a &amp;= b; set a to a &amp; b</span></span><br><span class="line">            *data++ += div2;  <span class="comment">// *data += div/2; data++[指针移动]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorReduceItr</span><span class="params">(cv::Mat image, <span class="type">int</span> div=<span class="number">64</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// div must be a power of 2</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(</span><br><span class="line">            <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(div))/<span class="built_in">log</span>(<span class="number">2.0</span>)+<span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// mask used to round the pixel value</span></span><br><span class="line">    uchar mask = <span class="number">0xFF</span>&lt;&lt;n;</span><br><span class="line">    uchar div2 = div&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get iterators</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scan all pixels</span></span><br><span class="line">    <span class="keyword">for</span>(;it!=itend;++it)&#123;</span><br><span class="line">        (*it)[<span class="number">0</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">0</span>] += div2;</span><br><span class="line"></span><br><span class="line">        (*it)[<span class="number">1</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">1</span>] += div2;</span><br><span class="line"></span><br><span class="line">        (*it)[<span class="number">2</span>] &amp;= mask;</span><br><span class="line">        (*it)[<span class="number">2</span>] += div2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;.../lake.png&quot;</span>);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">imagePtr</span><span class="params">(image)</span>, <span class="title">imageBit</span><span class="params">(image)</span>, <span class="title">imageItr</span><span class="params">(image)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ptr</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;colorReducePtr=====\nTime: &quot;</span>;</span><br><span class="line">    <span class="built_in">getTime</span>(colorReducePtr, imagePtr, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bit</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;colorReduceBit=====\nTime: &quot;</span>;</span><br><span class="line">    <span class="built_in">getTime</span>(colorReduceBit, imageBit, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Itr</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;colorReduceItr=====\nTime: &quot;</span>;</span><br><span class="line">    <span class="built_in">getTime</span>(colorReduceItr, imageItr, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Result&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colorReducePtr=====</span><br><span class="line">Time: 0.00144757</span><br><span class="line">colorReduceBit=====</span><br><span class="line">Time: 0.000849209</span><br><span class="line">colorReduceItr=====</span><br><span class="line">Time: 0.00298409</span><br></pre></td></tr></table></figure>
<p>可以明显看到位运算的高效</p>
<h5 id="参考-5">参考</h5>
<p><a href="http://www.lai18.com/content/10109307.html">OpenCv学习笔记(六)</a><br>
<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts">Bitwise operation</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Octave in Ubuntu</title>
    <url>/2017/05/06/Octave-IN-Ubuntu/</url>
    <content><![CDATA[<p>关于Ubuntu16.04LTS下Octave的安装和使用。</p>
<h5 id="安装-3">安装</h5>
<blockquote>
<p>sudo add-apt-repository ppa:octave/stable<br>
sudo apt-get update<br>
sudo apt-get install octave</p>
</blockquote>
<p>参考<a href="https://askubuntu.com/questions/645600/how-to-install-octave-4-0-0-in-ubuntu-14-04">这里</a></p>
<p>之后运行报错：</p>
<blockquote>
<p>The settings file /home/user/.config/octave/qt-settings does not exist and can not be created.<br>
Make sure you have read and write permissions to /home/user/.config/octave Octave GUI must be closed now.</p>
</blockquote>
<p>解决办法：</p>
<blockquote>
<p>cd .config/octave<br>
sudo chown user qt-settings</p>
</blockquote>
<p>其中user改为自己的用户名。chown为更改拥有者的命令。</p>
<p>参考<a href="https://unix.stackexchange.com/questions/292721/error-running-octave-in-ubuntu-16-04">这里</a></p>
<h5 id="使用-2">使用</h5>
<h6 id="安装包">安装包</h6>
<p>安装包的下载列表在<a href="https://octave.sourceforge.io/packages.php">这里</a>,直接下载即可。</p>
<p>尝试：</p>
<blockquote>
<p>pkg install /home/shensir/Documents/MyPrograming/octave/struct-1.0.14.tar.gz</p>
</blockquote>
<p>报错：</p>
<blockquote>
<p>pkg: please install the Debian package “liboctave-dev” to get the mkoctfile command<br>
error: called from ‘<strong>gripe_missing_component</strong>’ in file /usr/share/octave/4.0.2/m/help/<strong>gripe_missing_component</strong>.m near line 53, column 3</p>
</blockquote>
<p>解决报错：</p>
<blockquote>
<p>sudo apt-get install liboctave-dev</p>
</blockquote>
<p>安装成功：</p>
<blockquote>
<p>For information about changes from previous versions of the struct package, run ‘news struct’.</p>
</blockquote>
<p>查看已经安装的包：</p>
<blockquote>
<p>pkg list</p>
</blockquote>
<blockquote>
<p>Package Name  | Version | Installation directory<br>
optim  |   1.5.0 | /home/shensir/octave/optim-1.5.0<br>
struct  |  1.0.14 | /home/shensir/octave/struct-1.0.14<br>
symbolic  |   2.5.0 | /home/shensir/octave/symbolic-2.5.0</p>
</blockquote>
<p>调用安装的包：</p>
<blockquote>
<p>pkg load symbolic<br>
sym x</p>
</blockquote>
<p>嗯，报错了。。。</p>
<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
ImportError: No module named sympy
OctSymPy v2.5.0: this is free software without warranty, see source.
Initializing communication with SymPy using a popen2() pipe.
error: Python cannot import SymPy: have you installed SymPy?
error: called from
    assert_have_python_and_sympy at line 37 column 5
    python_ipc_popen2 at line 78 column 5
    python_ipc_driver at line 58 column 13
    python_cmd at line 164 column 9
    sym at line 340 column 9
</code></pre>
<p>貌似说python没有装sympy，检查了下，已经装了。注意到可能是Python路径设置的问题，就查了查官方给的symbolic的<a href="https://octave.sourceforge.io/symbolic/NEWS.html">文档</a>.</p>
<pre><code>  * The environment variable `PYTHON` controls which Python executable is
    used.  The command
         `sympref python C:\bin\python`
    has been deprecated; instead please use:
         `setenv PYTHON C:\bin\python`
</code></pre>
<p>于是[这里用的anaconda]：</p>
<blockquote>
<p>setenv PYTHON /home/shensir/anaconda3/bin/python</p>
</blockquote>
<p>搞定。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Octave</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV Wait!</title>
    <url>/2017/02/22/OpenCV-Play-Video/</url>
    <content><![CDATA[<p>环境： CLion Ubuntu16.04 OPenCV3.2.0</p>
<p>学习OpenCV基础时，在读取视频文件时发现一个问题。<br>
按照这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;opencv2/imgproc/imgproc.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">main</span><span class="params">(	<span class="type">int</span>	argc,	<span class="type">char</span>**	argv	)</span>	</span>&#123;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(	<span class="string">&quot;Example3&quot;</span>,	cv::WINDOW_AUTOSIZE	);</span><br><span class="line">    cv::VideoCapture	cap;</span><br><span class="line">    <span class="comment">//cap.open(	std::string(argv[1])	);</span></span><br><span class="line">    cap.<span class="built_in">open</span>(<span class="string">&quot;/home/shen/CLionProjects/MyCv/data/summaryVid.ogv&quot;</span>);</span><br><span class="line">    cv::Mat	frame;</span><br><span class="line">    <span class="keyword">for</span>(;;)	&#123;</span><br><span class="line">        cap	&gt;&gt;	frame;</span><br><span class="line">        <span class="keyword">if</span>(	frame.<span class="built_in">empty</span>() )	<span class="keyword">break</span>;					<span class="comment">//	Ran	out	of	film</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(	<span class="string">&quot;Example3&quot;</span>,	frame	);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(	<span class="built_in">cvWaitKey</span>(<span class="number">33</span>) &gt;= <span class="number">0</span> )	<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//if(	cv::waitKey(33) &gt;= 0 )	break;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>	<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码最后，第一个if可以播放完整视频，而第二个却只显示一帧画面。调试发现，cvWaitKey(33)在不按键时返回的是-1， cv::waitKey(33)返回的是255<br>
那么，问题来了，这两个函数不一样吗？查了查，没查到区别。。。<br>
经<a href="http://www.liusong.me/">废帝童鞋</a>帮助，发现是个<a href="https://github.com/opencv/opencv/pull/7866">bug</a>…<br>
酸爽的夜晚，继续前行…</p>
<p>参考： <strong>Learning	OpenCV	3: Computer	Vision	in	C++	with	the	OpenCV	Library</strong> [p58]</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV [Pyramid and Canny]</title>
    <url>/2017/02/23/OpenCV-Pyramid-and-Canny/</url>
    <content><![CDATA[<p>关于<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/pyramids/pyramids.html">图像金字塔</a>与边缘检测的结合。<br>
我们知道，cv::pyrDown会损失图像的信息，其后再使用cv::pyrUP进行放大，会变得“模糊”。但是在用于边缘检测时，损失部分细节，可以获得更简洁的轮廓图。<br>
测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>	<span class="title">main</span><span class="params">(	<span class="type">int</span>	argc,	<span class="type">char</span>**	argv	)</span>	</span>&#123;</span><br><span class="line">    cv::Mat	img_rgb,	img_gry,	img_cny;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(	<span class="string">&quot;Example	Gray&quot;</span>,		cv::WINDOW_AUTOSIZE	);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(	<span class="string">&quot;Example	Canny&quot;</span>,	cv::WINDOW_AUTOSIZE	);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(	<span class="string">&quot;Example	Canny  DU&quot;</span>,	cv::WINDOW_AUTOSIZE	);</span><br><span class="line"></span><br><span class="line">    img_rgb	=	cv::<span class="built_in">imread</span>(	argv[<span class="number">1</span>]	);				cv::<span class="built_in">cvtColor</span>(	img_rgb,	img_gry,	cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(	<span class="string">&quot;Example	Gray&quot;</span>,	img_gry	);</span><br><span class="line">    cv::<span class="built_in">Canny</span>(	img_gry,	img_cny,	<span class="number">10</span>,	<span class="number">100</span>,	<span class="number">3</span>,	<span class="literal">true</span>	);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(	<span class="string">&quot;Example	Canny&quot;</span>,	img_cny	);</span><br><span class="line"></span><br><span class="line">     (img_gry, img_gry);</span><br><span class="line">    cv::<span class="built_in">pyrUp</span>(img_gry, img_gry);</span><br><span class="line">    cv::<span class="built_in">Canny</span>(	img_gry,	img_cny,	<span class="number">10</span>,	<span class="number">100</span>,	<span class="number">3</span>,	<span class="literal">true</span>	);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(	<span class="string">&quot;Example	Canny  DU&quot;</span>,	img_cny	);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出图像：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/canny.png" alt="canny"></p>
<p>参考： <strong>Learning	OpenCV	3: Computer	Vision	in	C++	with	the	OpenCV	Library</strong> [p68]</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV4.1.0 on Ubuntu16.04</title>
    <url>/2019/09/05/OpenCV4-1-0-on-Ubuntu/</url>
    <content><![CDATA[<h3 id="安装编译">安装编译</h3>
<h4 id="大致流程">大致流程</h4>
<p>主要的参考资料还是<a href="https://docs.opencv.org/4.1.0/d7/d9f/tutorial_linux_install.html">官方文档</a>, 不过这里在设置<code>Python</code>路径方面并没有写的特别详细，所以参考了<a href="https://medium.com/dsc-manipal/opencv4-1-0-ubuntu-18-04-anaconda-dc427aa216d9">Medium文章</a>，这里是用了<code>conda</code>来创建了一个独立虚拟环境，使得路径的配置显得更加清晰。(此外也可以用<code>virtualenv</code>, 类似可以参考<a href="https://www.pyimagesearch.com/2018/08/15/how-to-install-opencv-4-on-ubuntu/">pyimagesearch</a>)。Medium文章中要注意一点，就是它的<code>OPENCV_EXTRA_MODULES_PATH</code>是直接写死的，我们要将其改为自己下载的<code>opencv_contrib</code>的路径（直接写绝对路径）。</p>
<h4 id="遇到的问题与解决方法">遇到的问题与解决方法</h4>
<p>问题主要就是网络的问题，就是在执行<code>cmake ...</code>命令之后，一般会卡在<code>IPPICV: Download: ippicv_2019_lnx_intel64_general_20180723.tgz</code>，这里国内的网络一般是不行，可以选择配置代理或者手动安装，网上教程很多，一般都是可以的。后面可能还会遇到<code>face_landmark_model.dat</code>数据下载卡住的情况，也可以通过配置代理或手动下载进行处理。</p>
<p>更多其他问题可以参考<a href="https://www.jianshu.com/p/259a6140da9d">Ubuntu16.04安装OpenCV</a>， 有一些其他问题的解决方法。</p>
<h3 id="Clion配置">Clion配置</h3>
<p>这里参考了之前用的<code>CMakeLists.txt</code>文件（那时候是在OpenCV3.4版本左右使用，现在依然是可以的），这里直接贴出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.14)</span><br><span class="line">project(CoolCV)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br><span class="line">add_executable(CoolCV main.cpp)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++14&quot;)</span><br><span class="line"></span><br><span class="line">find_package( OpenCV REQUIRED )</span><br><span class="line"></span><br><span class="line">#include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">target_link_libraries(CoolCV $&#123;OpenCV_LIBS&#125; )</span><br><span class="line">#target_link_libraries(CoolCV $&#123;PYTHON_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
        <tag>Ubuntu</tag>
        <tag>Clion</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记一：Read, Show and Write</title>
    <url>/2017/04/26/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9ARead-Show-and-Write/</url>
    <content><![CDATA[<h5 id="Overview-32">Overview</h5>
<p>看了一段时间的 <em>OpenCV 3 Computer Vision Application Programming Cookbook - Third Edition</em>,受益匪浅，目前看到了第8章，打算先暂停下，总结下前面学到的内容。<br>
这里，在开始的部分，我们介绍下图片文件的读写。</p>
<h5 id="Code-25">Code</h5>
<p>先看一段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//core header that declares the image data structure</span></span><br><span class="line"><span class="comment">//and the highgui header file that contains all the graphical interface</span></span><br><span class="line"><span class="comment">//functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print images&#x27;s info</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getImageInfo</span><span class="params">(cv::Mat image)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;=====Image Info=====\n&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;image.rows: &quot;</span>&lt;&lt;image.rows&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;image.cols: &quot;</span>&lt;&lt;image.cols&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;image.dims: &quot;</span>&lt;&lt;image.dims&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;image.channels: &quot;</span>&lt;&lt;image.<span class="built_in">channels</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something else...</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;====================\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image;  <span class="comment">// create an empty image</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read an input image</span></span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/mangzai.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(image.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;ERROR: Empty Image!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// exit with code -1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print info of the image</span></span><br><span class="line">    <span class="built_in">getImageInfo</span>(image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define the window(optional)</span></span><br><span class="line">    <span class="comment">// http://stackoverflow.com/questions/31155577/opencv-is-namedwindow-necessary-before-imshow</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Original Image&quot;</span>);</span><br><span class="line">    <span class="comment">// show the image</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let&#x27;s do something on the image</span></span><br><span class="line">    cv::Mat fliped;  <span class="comment">// we create another empty image</span></span><br><span class="line">    cv::<span class="built_in">flip</span>(image, fliped, <span class="number">1</span>); <span class="comment">// 1-&gt;positive for horizontal</span></span><br><span class="line">                                <span class="comment">// 0 for vertical, negative for both</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Fliped&quot;</span>, fliped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the image</span></span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;Filped.jpg&quot;</span>, fliped);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简单讲解下代码要注意的地方：</p>
<ol>
<li>cv::imread</li>
</ol>
<blockquote>
<p>源码：@param filename Name of file to be loaded.<br>
@param flags Flag that can take values of cv::ImreadModes<br>
*/<br>
CV_EXPORTS_W Mat imread( const String&amp; filename, int flags = IMREAD_COLOR );<br>
可以看到，两个参数分别是文件名和读取的方式，默认是COLOR即BGR方式读入。<br>
关于flags, 我们截取源码片段看一下：<br>
//! Imread flags<br>
enum ImreadModes {<br>
IMREAD_UNCHANGED = -1, //!&lt; If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).</p>
<p>IMREAD_GRAYSCALE = 0,  //!&lt; If set, always convert image to the single channel grayscale image.<br>
IMREAD_COLOR = 1,  //!&lt; If set, always convert image to the 3 channel BGR color image.</p>
<p>注意默认的是COLOR模式，即为1.</p>
</blockquote>
<ol start="2">
<li>image.empty()</li>
</ol>
<blockquote>
<p>这里是很有必要的习惯，我们要保证图片的正确载入，否则下面的操作将会失去意义。用Cpp写imread,image为空会自动报错，在用Python调用OpenCV接口读取的时候，即使图片为空也不会有报错，这点要注意下。</p>
</blockquote>
<ol start="3">
<li>namedWindow</li>
</ol>
<blockquote>
<p>namedWindow creates a window that can be used as a placeholder for images and trackbars. Created windows are referred to by their names.</p>
<p>The fuction namedWindow just makes sure that if you wish to do something with that same window afterwards (eg move, resize, close that window), you can do it by referencing it with the same name.</p>
<p>So if you just want to show it; you don’t need to use namedWindow().<br>
即是说，如果只用窗口展示图片的话，不需要namedWindow, 在需要对图片展示窗口进行操作（复用）时才用的到。</p>
</blockquote>
<ol start="4">
<li>cv::waitKey() 与 cvWaitKey()</li>
</ol>
<blockquote>
<p>@param delay Delay in milliseconds. 0 is the special value that means “forever”.<br>
*/<br>
CV_EXPORTS_W int waitKey(int delay = 0);</p>
<p>/* wait for key event infinitely (delay&lt;=0) or for “delay” milliseconds */<br>
CVAPI(int) cvWaitKey(int delay CV_DEFAULT(0));</p>
<p>看似并没有什么差别…但是这里有个之前发现的bug，参考<a href="http://datahonor.com/2017/02/22/OpenCV-Play-Video/">这里</a>.</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记七：Neighbor access</title>
    <url>/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%9ANeighbor-access/</url>
    <content><![CDATA[<h5 id="Overview-33">Overview</h5>
<p>前面介绍了几种获取特定位置像素点的方法，但是有些时候我们也需要同时获取其周围的像素点的值，这时候，我们仿照前面的做法，只需要多加上几个位置指针即可。</p>
<h5 id="Code-26">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharpen</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span>&#123;</span><br><span class="line">    <span class="comment">// allocate if necessary</span></span><br><span class="line">    result.<span class="built_in">create</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">    <span class="type">int</span> nchannels = image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for all rows(except first and last</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image.rows - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="type">const</span> uchar * previous = image.<span class="built_in">ptr</span>&lt;<span class="type">const</span> uchar&gt;(j<span class="number">-1</span>);</span><br><span class="line">        <span class="type">const</span> uchar * current = image.<span class="built_in">ptr</span>&lt;<span class="type">const</span> uchar&gt;(j);</span><br><span class="line">        <span class="type">const</span> uchar * next = image.<span class="built_in">ptr</span>&lt;<span class="type">const</span> uchar&gt;(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        uchar* output = result.<span class="built_in">ptr</span>&lt;uchar&gt;(j); <span class="comment">// output row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nchannels; i&lt;(image.cols<span class="number">-1</span>)*nchannels; i++)&#123;</span><br><span class="line">            <span class="comment">// apply sharpening operator</span></span><br><span class="line">            *output++ = cv::<span class="built_in">saturate_cast</span>&lt;uchar&gt;(</span><br><span class="line">                    <span class="number">5</span>*current[i]-current[i-nchannels]-</span><br><span class="line">                    current[i+nchannels]-previous[i]-next[i]</span><br><span class="line">                        );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set the unprocessed pixels to 0</span></span><br><span class="line">    result.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    result.<span class="built_in">row</span>(result.rows<span class="number">-1</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    result.<span class="built_in">col</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    result.<span class="built_in">col</span>(result.cols<span class="number">-1</span>).<span class="built_in">setTo</span>(cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sharpen2D</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Construct kernel (all entries initialized to 0)</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">kernel</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>, CV_32F, cv::Scalar(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">//assigns kernel values</span></span><br><span class="line">    kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5.0</span>;</span><br><span class="line">    kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1.0</span>;</span><br><span class="line">    kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">2</span>,<span class="number">1</span>) = <span class="number">-1.0</span>;</span><br><span class="line">    kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">-1.0</span>;</span><br><span class="line">    kernel.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="comment">//filter the image</span></span><br><span class="line">    cv::<span class="built_in">filter2D</span>(image, result, image.<span class="built_in">depth</span>(), kernel);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::Mat result1, result2;</span><br><span class="line">    <span class="built_in">sharpen</span>(image, result1);</span><br><span class="line">    <span class="built_in">sharpen2D</span>(image, result2);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result1&quot;</span>, result1);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Result2&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170427/8.png" alt=""></p>
<p>几点补充：</p>
<ul>
<li>[ ] cv::saturate_cast<uchar></li>
</ul>
<blockquote>
<p>其作用是保证像素点操作过程中出现的低于0或者大于255的值强制转化为0和255.</p>
</blockquote>
<ul>
<li>[ ] 彩色图像的操作</li>
</ul>
<blockquote>
<p>在对彩色图像进行处理的时候，每次对单个pixel的单个channel操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记九：Comparing colors using the Strategy design pattern</title>
    <url>/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%B9%9D%EF%BC%9AComparing-colors-using-the-Strategy-design-pattern/</url>
    <content><![CDATA[<h5 id="Overview-34">Overview</h5>
<p>介绍通过比较颜色来检测一片区域，并进行处理的方法，采用了Strategy design pattern.</p>
<blockquote>
<p>Let’s say we want to build a simple algorithm that will identify all of the<br>
pixels in an image that have a given color. For this, the algorithm has to<br>
accept an image and a color as input and will return a binary image<br>
showing the pixels that have the specified color. The tolerance with<br>
which we want to accept a color will be another parameter to be<br>
specified before running the algorithm.</p>
</blockquote>
<h5 id="Code-27">Code</h5>
<p>代码通过两种方式来进行颜色的比较， 一种是自己实现的，另一种是应用了OpenCV提供的函数absdiff等。最后将这种算法的效果和floodfill进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparing colors using the Strategy design pattern</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorDetector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// minimun accptable distance</span></span><br><span class="line">    <span class="type">int</span> maxDist;</span><br><span class="line">    <span class="comment">// target color</span></span><br><span class="line">    cv::Vec3b target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// image containing resulting binary map</span></span><br><span class="line">    cv::Mat result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty constructor</span></span><br><span class="line">    <span class="comment">// default parameter initialization here</span></span><br><span class="line">    <span class="built_in">ColorDetector</span>():<span class="built_in">maxDist</span>(<span class="number">50</span>),<span class="built_in">target</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// full constructor with target and distance</span></span><br><span class="line">    <span class="comment">// functor</span></span><br><span class="line">    <span class="built_in">ColorDetector</span>(uchar blue, uchar green, uchar red, <span class="type">int</span> maxDist=<span class="number">50</span>):</span><br><span class="line">            <span class="built_in">maxDist</span>(maxDist)&#123;</span><br><span class="line">        <span class="built_in">setTargetColor</span>(blue, green, red);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// functor--&gt; ()</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process_bycv</span>(image);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color distance threshold</span></span><br><span class="line">    <span class="comment">// Threshold must be positive,</span></span><br><span class="line">    <span class="comment">// otherwise distance threshold is set to 0.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColorDistanceThreshold</span><span class="params">(<span class="type">int</span> distance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(distance&lt;<span class="number">0</span>)</span><br><span class="line">            distance = <span class="number">0</span>;</span><br><span class="line">        maxDist = distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets the color distance threshold</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDistanceThreshold</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxDist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color to be detected</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTargetColor</span><span class="params">(uchar blue, uchar green, uchar red)</span></span>&#123;</span><br><span class="line">        <span class="comment">// BGR order</span></span><br><span class="line">        target = cv::<span class="built_in">Vec3b</span>(blue, green, red);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sets the color to be detected</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTargetColor</span><span class="params">(cv::Vec3b color)</span></span>&#123;</span><br><span class="line">        target = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets the color to be detected</span></span><br><span class="line">    <span class="function">cv::Vec3b <span class="title">getTargetColor</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process the image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">process</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">process_bycv</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDitanceToTargetColor</span><span class="params">(<span class="type">const</span> cv::Vec3b&amp; color)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getColorDistance</span>(color, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Compute the city-block distance between two colors</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getColorDistance</span><span class="params">(<span class="type">const</span> cv::Vec3b&amp;color1, <span class="type">const</span> cv::Vec3b&amp; color2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(color1[<span class="number">0</span>]-color2[<span class="number">0</span>]+</span><br><span class="line">                   <span class="built_in">abs</span>(color1[<span class="number">1</span>])-color2[<span class="number">1</span>]+</span><br><span class="line">                   <span class="built_in">abs</span>(color1[<span class="number">2</span>]-color2[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">ColorDetector::process</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span></span>&#123;</span><br><span class="line">    <span class="comment">// re-allocate binary map if necessary</span></span><br><span class="line">    <span class="comment">// same size as input image, but 1-channel</span></span><br><span class="line">    result.<span class="built_in">create</span>(image.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// processing</span></span><br><span class="line">    <span class="comment">// get the iterators</span></span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator it = image.<span class="built_in">begin</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;cv::Vec3b&gt;::const_iterator itend = image.<span class="built_in">end</span>&lt;cv::Vec3b&gt;();</span><br><span class="line">    cv::Mat_&lt;uchar&gt;::iterator itout = result.<span class="built_in">begin</span>&lt;uchar&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each pixel</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=itend;++it, ++itout)&#123;</span><br><span class="line">        <span class="comment">// compute distance from target color</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getColorDitanceToTargetColor</span>(*it) &lt;= maxDist)&#123;</span><br><span class="line">            *itout = <span class="number">255</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *itout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">ColorDetector::process_bycv</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image)</span> </span>&#123;</span><br><span class="line">    cv::Mat output;</span><br><span class="line">    <span class="comment">// compute abssolute difference with tarfet color</span></span><br><span class="line">    cv::<span class="built_in">absdiff</span>(image, cv::<span class="built_in">Scalar</span>(target) ,output);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//split the channels into 3 images;</span></span><br><span class="line">    std::vector&lt;cv::Mat&gt; images;</span><br><span class="line">    cv::<span class="built_in">split</span>(output, images);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the 3 channels (saturation might occurs here)</span></span><br><span class="line">    output = images[<span class="number">0</span>] + images[<span class="number">1</span>] + images[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// apply threshold</span></span><br><span class="line">    cv::<span class="built_in">threshold</span>(output, output, maxDist, <span class="number">255</span>, cv::THRESH_BINARY_INV);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. Create image processor object</span></span><br><span class="line">    ColorDetector cdetect;</span><br><span class="line">    <span class="comment">//2. Read input image</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(image.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. Set input parameters</span></span><br><span class="line">    cdetect.<span class="built_in">setTargetColor</span>(<span class="number">230</span>, <span class="number">190</span>, <span class="number">130</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. Process the image and display the result</span></span><br><span class="line">    cv::Mat result1 = cdetect.<span class="built_in">process</span>(image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;process&quot;</span>, result1);</span><br><span class="line"></span><br><span class="line">    cv::Mat result2 = cdetect.<span class="built_in">process_bycv</span>(image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;process_bycv&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// another way</span></span><br><span class="line">    <span class="function">ColorDetector <span class="title">colordetector</span><span class="params">(<span class="number">230</span>, <span class="number">190</span>, <span class="number">130</span>)</span></span>;</span><br><span class="line">    cv::Mat result = <span class="built_in">colordetector</span>(image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;colordetector result&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show the result in original image</span></span><br><span class="line">    cv::Mat image_masked, mask_inv;</span><br><span class="line">    mask_inv = <span class="number">255</span> - result;</span><br><span class="line">    cv::<span class="built_in">bitwise_and</span>(image, image, image_masked, mask_inv);</span><br><span class="line">    cv::<span class="built_in">add</span>(image_masked, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), image_masked, result);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image_masked&quot;</span>, image_masked);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//floodFill的用法</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">floodFill</span>(image, cv::<span class="built_in">Point</span>(<span class="number">100</span>,<span class="number">50</span>),cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),</span><br><span class="line">                  (cv::Rect*)<span class="number">0</span>, cv::<span class="built_in">Scalar</span>(<span class="number">35</span>,<span class="number">35</span>,<span class="number">35</span>), cv::<span class="built_in">Scalar</span>(<span class="number">35</span>,<span class="number">35</span>,<span class="number">35</span>),</span><br><span class="line">                  cv::FLOODFILL_FIXED_RANGE);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Flood fill&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170427/9.png" alt=""></p>
<p>关于floodfill和原算法的不同之处：</p>
<blockquote>
<p>Our ColorDetector class identifies the pixels in an image that have a<br>
color similar to a given target color. The decision to accept or not a pixel<br>
is simply made on a per-pixel basis. The cv::floodFill function<br>
proceeds in a very similar way with one important difference: in this<br>
case, the decision to accept a pixel also depends on the state of its<br>
neighbors. The idea is to identify a connected area of a certain color.<br>
The user specifies a starting pixel location and tolerance parameters that<br>
determine color similarity.</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二十一：MSER</title>
    <url>/2017/05/25/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%9AMSER/</url>
    <content><![CDATA[<h4 id="Overview-35">Overview</h4>
<p>Maximally Stable External Regions (MSER) 和分水岭算法类似，也是通过一种类似“浸水”的过程来找到图像中一些有意义的区域。但是和分水岭算法又有些不同：</p>
<blockquote>
<p>but this time, we will be interested in the basins that remain relatively stable for a period of time during the immersion process. It will be observed that these regions correspond to some distinctive parts of the scene objects pictured in the image.</p>
</blockquote>
<p>也就是说，这里关注的不仅仅是界限，更多地考虑随着浸水过程的进行，特定区域是否有明显的变化（比如当前区域的水面面积的方差是否小于给定的阀值），如果在一段浸水时间内，某些区域的面积未有太大的变化，那么这就是我们要找的MSER。</p>
<h4 id="Code-28">Code</h4>
<p>这里做图的时候要注意两点。第一，检测到的MSER是具有层级结构的，我们在绘图的时候要按照从大到小（面积）的顺序，且每次做图进行检查当前区域是否已经画过了。第二，这里会返回包含MSER的矩形，不过一般来说数目较多，全部做出来会使得结果显得比较凌乱，所以一般添加一些过滤条件来指定输出某些物体，比如通过指定矩形的长宽比来来输出包含窗户的矩形框。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Read the image</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/building.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!image.data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the image</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// basic MSER detector</span></span><br><span class="line">    cv::Ptr&lt;cv::MSER&gt;ptrMSER = cv::MSER::<span class="built_in">create</span>(<span class="number">5</span>,  <span class="comment">// delta value</span></span><br><span class="line">                                                  <span class="number">200</span>,  <span class="comment">// min acceptable area</span></span><br><span class="line">                                                     <span class="number">2000</span>); <span class="comment">// max acceptable area</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector of point sets</span></span><br><span class="line">    std::vector&lt;std::vector&lt;cv::Point&gt;&gt;points;</span><br><span class="line">    <span class="comment">// vector of rectangles</span></span><br><span class="line">    std::vector&lt;cv::Rect&gt;rects;</span><br><span class="line">    <span class="comment">// detect MSER features</span></span><br><span class="line">    ptrMSER-&gt;<span class="built_in">detectRegions</span>(image, points, rects);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;points.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; MSERs detected&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create white image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">output</span><span class="params">(image.size(), CV_8UC3)</span></span>;</span><br><span class="line">    output = cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OpenCV random number  generator</span></span><br><span class="line">    cv::RNG rng;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the MSERs in color areas</span></span><br><span class="line">    <span class="comment">// for each detected feature</span></span><br><span class="line">    <span class="comment">// reverse order to display the larger MSER first</span></span><br><span class="line">    <span class="keyword">for</span>(std::vector&lt;std::vector&lt;cv::Point&gt;&gt;::reverse_iterator it = points.<span class="built_in">rbegin</span>();</span><br><span class="line">            it!=points.<span class="built_in">rend</span>(); ++it)&#123;</span><br><span class="line">        <span class="comment">// generate a random color</span></span><br><span class="line">        <span class="function">cv::Vec3b <span class="title">c</span><span class="params">(rng.uniform(<span class="number">0</span>,<span class="number">254</span>), rng.uniform(<span class="number">0</span>,<span class="number">254</span>), rng.uniform(<span class="number">0</span>,<span class="number">254</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MSER size= &quot;</span>&lt;&lt;it-&gt;<span class="built_in">size</span>()&lt;&lt;std::endl;</span><br><span class="line">        <span class="comment">// for each point in MSER set</span></span><br><span class="line">        <span class="keyword">for</span>(std::vector&lt;cv::Point&gt;::iterator itPts = it-&gt;<span class="built_in">begin</span>();</span><br><span class="line">                itPts!=it-&gt;<span class="built_in">end</span>(); ++itPts)&#123;</span><br><span class="line">            <span class="comment">// do not overwrite MSER pixels</span></span><br><span class="line">            <span class="keyword">if</span>(output.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(*itPts)[<span class="number">0</span>] = <span class="number">255</span>)&#123;</span><br><span class="line">                output.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(*itPts) = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;MSER point sets&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;MSER point sets&quot;</span>, output);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;mser.bmp&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reload the input image</span></span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/building.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!image.data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract and display the elliptic MSERs</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;std::vector&lt;cv::Point&gt; &gt;::iterator it = points.<span class="built_in">begin</span>();</span><br><span class="line">         it != points.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for each point in MSER set</span></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;cv::Point&gt;::iterator itPts = it-&gt;<span class="built_in">begin</span>();</span><br><span class="line">             itPts != it-&gt;<span class="built_in">end</span>(); ++itPts) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Extract bouding rectangles</span></span><br><span class="line">            cv::RotatedRect rr = cv::<span class="built_in">minAreaRect</span>(*it);</span><br><span class="line">            <span class="comment">// check ellipse elongation</span></span><br><span class="line">            <span class="keyword">if</span> (rr.size.height / rr.size.height &gt; <span class="number">0.6</span> || rr.size.height / rr.size.height &lt; <span class="number">1.6</span>)</span><br><span class="line">                cv::<span class="built_in">ellipse</span>(image, rr, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the image</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;MSER ellipses&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;MSER ellipses&quot;</span>, image);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052404.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二十二：滤波</title>
    <url>/2017/05/25/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h4 id="Overview-36">Overview</h4>
<p>滤波在信号处理领域具有广泛的应用。同样的，我们可以通过 Fourier transform 或者 Cosine transform将空域（ spatial domain）上的图像信息转化到频域（frequency domain）。这里我们暂时不做深入了解，只需要了解：图像中的一些边缘和细节（变化较大的部分）对应频域中的高频部分，图像中较为平坦，变化不大的地方对应频域的低频部分。</p>
<p>基于上面的结论，我们称进行滤波的工具为滤波器(filter)，根据不同的过滤方式分为低通滤波器（ low-pass filter ）和高通滤波器( high-pass filter ).</p>
<p>我们将展示mean filter, gaussian filter, median filter 等多种滤波器的使用。</p>
<h4 id="Code-29">Code</h4>
<h5 id="Downsampling-images-with-filters">Downsampling images with filters</h5>
<p>我们在进行downsampling的时候，如果不进行低通滤波器的处理，直接去除行列的话，结果会比较糟糕：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052501.png" alt=""></p>
<p>可以看到，在直接downsampling的时候，原图像的细节，也就是高频部分无法在如此小的空间（如此少的像素数）上表现出来，还会出现spatial aliasing的现象。所以，我们一般进经过low-pass filter处理后在进行downsampling，这种做法即是遵从 Nyquist-Shannon theorem.而效果也是有较高的提升的：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052502.png" alt=""></p>
<p>下面是一些低通滤波器具体的应用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!image.data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::Mat result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mean filtered</span></span><br><span class="line">    cv::<span class="built_in">blur</span>(image, result, cv::<span class="built_in">Size</span>(<span class="number">5</span>,<span class="number">5</span>)); <span class="comment">// size of the filter</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Mean filtered Image&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gaussian filtered Image</span></span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(image, result, cv::<span class="built_in">Size</span>(<span class="number">5</span>,<span class="number">5</span>), <span class="number">1.5</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Gaussian filtered Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Gaussian filtered Image&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用高斯滤波后进行downsampling</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">reduced</span><span class="params">(image.rows/<span class="number">4</span>, image.cols/<span class="number">4</span>, CV_8U)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;reduced.rows; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;reduced.cols; j++)&#123;</span><br><span class="line">            reduced.<span class="built_in">at</span>&lt;uchar&gt;(i, j) = result.<span class="built_in">at</span>&lt;uchar&gt;(i*<span class="number">4</span>, j*<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;downsampling gaussian&quot;</span>, reduced);</span><br><span class="line">    cv::<span class="built_in">imwrite</span>(<span class="string">&quot;gaussian-redeced.jpg&quot;</span>, reduced);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像金字塔</span></span><br><span class="line">    cv::Mat reducedImage;</span><br><span class="line">    cv::<span class="built_in">pyrDown</span>(result, reducedImage);  <span class="comment">// reduce by half</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;pyDownImage&quot;</span>, reducedImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resizing</span></span><br><span class="line">    cv::Mat resized;</span><br><span class="line">    cv::<span class="built_in">resize</span>(image, resized, cv::<span class="built_in">Size</span>(), <span class="number">2</span>, <span class="number">2</span>, cv::INTER_LINEAR);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;resized&quot;</span>, resized);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Median filtered</span></span><br><span class="line">    cv::<span class="built_in">medianBlur</span>(image, result, <span class="number">5</span>); <span class="comment">// size of the filter</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Mean filtered Image&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052503.png" alt=""></p>
<p>median filter（注意其为no-linear）输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052504.png" alt=""></p>
<p>注意，基于图像金字塔的操作pyDown和pyUp是不可逆的。而pyDown在进行downsampling是也是进行了5x5 Gaussian filter to low-pass 处理的。</p>
<h5 id="Applying-directional-filters-to-detect-edges">Applying directional filters to detect edges</h5>
<p>高通的滤波器一般用来检测变化比较大的区域，这里通过sobel函数，用于图像的边缘检测。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::Mat sobelX, sobelY;</span><br><span class="line">    cv::<span class="built_in">Sobel</span>(image, sobelX, CV_8U, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0.4</span>, <span class="number">128</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;SobelX Image&quot;</span>, sobelX);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">Sobel</span>(image, sobelY, CV_8U, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0.4</span>, <span class="number">128</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;SobelY Image&quot;</span>, sobelY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute norm of Sobel</span></span><br><span class="line">    cv::<span class="built_in">Sobel</span>(image, sobelX, CV_16S, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">Sobel</span>(image, sobelY, CV_16S, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cv::Mat sobel;</span><br><span class="line">    <span class="comment">// compute the L1 norm</span></span><br><span class="line">    sobel = <span class="built_in">abs</span>(sobelX)+<span class="built_in">abs</span>(sobelY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find Sobel max value</span></span><br><span class="line">    <span class="type">double</span> sobmin, sobmax;</span><br><span class="line">    cv::<span class="built_in">minMaxLoc</span>(sobel, &amp;sobmin, &amp;sobmax);</span><br><span class="line">    <span class="comment">// Conversion to 8-bit image</span></span><br><span class="line">    <span class="comment">// -alpha*sobel + 255</span></span><br><span class="line">    cv::Mat sobelImage;</span><br><span class="line">    sobel.<span class="built_in">convertTo</span>(sobelImage,CV_8U, <span class="number">-255.</span>/sobmax, <span class="number">255</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Sobel Image&quot;</span>, sobelImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary Sobel Image(low)</span></span><br><span class="line">    cv::Mat sobeThreshold;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(sobelImage, sobeThreshold, <span class="number">230</span>, <span class="number">255</span>, cv::THRESH_BINARY);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Binary Sobel Image(low)&quot;</span>, sobeThreshold);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052505.png" alt=""></p>
<h5 id="band-pass-filter">band-pass filter</h5>
<p>如果我们先应用高斯滤波器去除高频的部分，再用sobel filter去除低频的部分，那么我们就得到了一个band-filter. 我们只要在上面程序的开头加上一个高斯滤波即可查看效果：</p>
<p><code>   cv::GaussianBlur(image, image, cv::Size(5,5), 1.5);</code></p>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052506.png" alt=""></p>
<h5 id="Computing-the-Laplacian-of-an-image">Computing the Laplacian of an image</h5>
<p>ps:这个公式推导不是很懂，所以暂时只是会用…</p>
<p>关于Laplacian:</p>
<blockquote>
<p>The Laplacian is another high-pass linear filter that is based on the computation of the image derivatives. As it will be explained, it computes second-order derivatives to measure the curvature of the image function.</p>
</blockquote>
<p>关于LOG：</p>
<blockquote>
<p>Since these larger kernels are computed using the second derivatives of the Gaussian function, the corresponding operator is often called Laplacian of Gaussian (LoG)</p>
</blockquote>
<p>由于高斯-拉普拉斯算子形状像一个草帽，所以又被称为“墨西哥草帽”</p>
<p>注意，拉氏算子是一种二阶导数算子，对图像中的噪声相对敏感，检测的边缘没有方向信息。因此，拉普拉斯算子很少直接用于检测边缘，而主要用于已知边缘像素后，确定图像的名区还是暗区。</p>
<p>关于DOG：</p>
<blockquote>
<p>. Now, if we subtract the two images that result from the filtering of an image by two Gaussian filters of different bandwidths, then the resulting image will be composed of those higher frequencies that one filter has preserved, and not the other. This operation is called Difference of Gaussians (DoG)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LaplacianZC</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// laplacina</span></span><br><span class="line">    cv::Mat laplace;</span><br><span class="line">    <span class="comment">// Aperture size of the laplacian kernel</span></span><br><span class="line">    <span class="type">int</span> aperture;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LaplacianZC</span>():<span class="built_in">aperture</span>(<span class="number">3</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the aperture size of the kernel</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAperture</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        aperture = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the floating point Laplacian</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">computeLaplacian</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Compute Laplacian</span></span><br><span class="line">        cv::<span class="built_in">Laplacian</span>(image, laplace, CV_32F, aperture);</span><br><span class="line">        <span class="keyword">return</span> laplace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the Laplacian result in 8-bits image</span></span><br><span class="line">    <span class="comment">// zero corresponds to gray level 128</span></span><br><span class="line">    <span class="comment">// if no scale is provide, then the max value will be</span></span><br><span class="line">    <span class="comment">// scaled to intensity 255</span></span><br><span class="line">    <span class="comment">// You must call cimputeLaplacianImage before calling this</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getLaplacianImage</span><span class="params">(<span class="type">double</span> scale=<span class="number">-1.0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(scale&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> lapmin, lapmax;</span><br><span class="line">            <span class="comment">// get min and max laplacian values</span></span><br><span class="line">            cv::<span class="built_in">minMaxLoc</span>(laplace, &amp;lapmin, &amp;lapmax);</span><br><span class="line">            <span class="comment">// scale the laplacian to 127</span></span><br><span class="line">            scale = <span class="number">127</span>/std::<span class="built_in">max</span>(-lapmin, lapmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// produce gray-level image</span></span><br><span class="line">        cv::Mat laplaceImage;</span><br><span class="line">        laplace.<span class="built_in">convertTo</span>(laplaceImage, CV_8U, scale, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">return</span> laplaceImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get a binary image of the zero-crossings</span></span><br><span class="line">    <span class="comment">// laplacian image should be CV_32F</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getZeroCrossings</span><span class="params">(cv::Mat laplace)</span></span>&#123;</span><br><span class="line">        <span class="comment">// threshold at 0</span></span><br><span class="line">        <span class="comment">// negtive values in black</span></span><br><span class="line">        <span class="comment">// positive values in white</span></span><br><span class="line">        cv::Mat signImage;</span><br><span class="line">        cv::<span class="built_in">threshold</span>(laplace, signImage, <span class="number">0</span>, <span class="number">255</span>, cv::THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert the +/- image into CV_8U</span></span><br><span class="line">        cv::Mat binary;</span><br><span class="line">        signImage.<span class="built_in">convertTo</span>(binary, CV_8U);</span><br><span class="line">        <span class="comment">// dilate the binary image of +/- regions</span></span><br><span class="line">        cv::Mat dilated;</span><br><span class="line">        cv::<span class="built_in">dilate</span>(binary, dilated, cv::<span class="built_in">Mat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the zero-crossing contours</span></span><br><span class="line">        <span class="keyword">return</span> dilated-binary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, image);</span><br><span class="line">    <span class="comment">// Compute Laplcian using LaplacianZC class</span></span><br><span class="line">    LaplacianZC laplacian;</span><br><span class="line">    laplacian.<span class="built_in">setAperture</span>(<span class="number">7</span>); <span class="comment">// 7x7 laplacian</span></span><br><span class="line">    cv::Mat flap = laplacian.<span class="built_in">computeLaplacian</span>(image);</span><br><span class="line"></span><br><span class="line">    cv::Mat laplace;</span><br><span class="line">    laplace = laplacian.<span class="built_in">getLaplacianImage</span>();</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Laplacian Image 7x7&quot;</span>, laplace);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary image of zero-crossing</span></span><br><span class="line">    cv::Mat Binary;</span><br><span class="line">    Binary = laplacian.<span class="built_in">getZeroCrossings</span>(flap);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Binary&quot;</span>, Binary);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DoG</span></span><br><span class="line">    cv::Mat gauss20, gauss22;</span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(image, gauss20, cv::<span class="built_in">Size</span>(), <span class="number">2.0</span>);</span><br><span class="line">    cv::<span class="built_in">GaussianBlur</span>(image, gauss22, cv::<span class="built_in">Size</span>(), <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute a difference of Gaussians</span></span><br><span class="line">    cv::Mat dog;</span><br><span class="line">    cv::<span class="built_in">subtract</span>(gauss22, gauss20, dog, cv::<span class="built_in">Mat</span>(), CV_32F);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the zero-crossings of DoG</span></span><br><span class="line">    cv::Mat zeros;</span><br><span class="line">    zeros = laplacian.<span class="built_in">getZeroCrossings</span>(dog);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;DoG&quot;</span>,zeros);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052508.png" alt=""></p>
<h4 id="Reference-9">Reference</h4>
<p><em>《数字图像处理》高教出版社</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二十四：Detecting corners in an image</title>
    <url>/2017/07/20/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ADetecting-corners-in-an-image/</url>
    <content><![CDATA[<h4 id="Overview-37">Overview</h4>
<p>关于图片关键点的检测中，corner点的检测。</p>
<blockquote>
<p>When searching for interesting feature points in images, corners come out as an interesting solution. They are indeed local features that can be easily localized in an image, and in addition, they should abound in scenes of man-made objects (where they are produced by walls, doors, windows, tables, and so on).</p>
</blockquote>
<p>这里主要是基于Harris feature detector的实现。</p>
<p>首先是corners的定义：</p>
<blockquote>
<p>To define the notion of corners in images, the Harris feature detector looks at the average directional change in intensity in a small window around a putative interest point… This average intensity change can then be computed in all possible directions, which leads to the definition of a corner as a point for which the average change is high in more than one direction.</p>
</blockquote>
<p>这里的公式没有看太懂，大致就是利用梯度找到对比度较强的点作为corner.</p>
<p>这里首先介绍了经典的Harris feature detector的实现，接着针对feature point clustering问题给出了两种解决的办法，分别是non-maxima suppression，通过dilate操作来实现；还有GFTT（good-features-to-track），通过设置两个interest points 之间的最小距离来解决。</p>
<h4 id="Code-30">Code</h4>
<h5 id="harrisDetector-h">harrisDetector.h</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-7-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_HARRISDETECTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_HARRISDETECTOR_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/mat.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">harrisDetector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 32-it float image of corner strength</span></span><br><span class="line">    cv::Mat cornerStrength;</span><br><span class="line">    <span class="comment">// 32-bit float image of thresholded corners</span></span><br><span class="line">    cv::Mat cornerTh;</span><br><span class="line">    <span class="comment">// image of local maxima(internal)</span></span><br><span class="line">    cv::Mat localMax;</span><br><span class="line">    <span class="comment">// size of neighborhood for derivatives smoothing</span></span><br><span class="line">    <span class="type">int</span> neighborhood;</span><br><span class="line">    <span class="comment">// aperture for gradient computation</span></span><br><span class="line">    <span class="type">int</span> aperture;</span><br><span class="line">    <span class="comment">// Harris parameter</span></span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line">    <span class="comment">// maximum strength for threshold computation</span></span><br><span class="line">    <span class="type">double</span> maxStrength;</span><br><span class="line">    <span class="comment">// calculated threshold(internal)</span></span><br><span class="line">    <span class="type">double</span> threshold;</span><br><span class="line">    <span class="comment">// size of neighborhood for non-max suppression</span></span><br><span class="line">    <span class="type">int</span> nonMaxSize;</span><br><span class="line">    <span class="comment">// kernel for non-max suppression</span></span><br><span class="line">    cv::Mat kernel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">harrisDetector</span>():<span class="built_in">neighborhood</span>(<span class="number">3</span>), <span class="built_in">aperture</span>(<span class="number">3</span>),</span><br><span class="line">                     <span class="built_in">k</span>(<span class="number">0.01</span>), <span class="built_in">maxStrength</span>(<span class="number">0.0</span>),</span><br><span class="line">                     <span class="built_in">threshold</span>(<span class="number">0.01</span>), <span class="built_in">nonMaxSize</span>(<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">// create kernel used in non-maxima suppression</span></span><br><span class="line">        <span class="built_in">setLocalMaxWindowSize</span>(nonMaxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create kernel used in non-maxima suppression</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLocalMaxWindowSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        nonMaxSize= size;</span><br><span class="line">        kernel.<span class="built_in">create</span>(nonMaxSize,nonMaxSize,CV_8U);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute Harris corners</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Harris computation</span></span><br><span class="line">        cv::<span class="built_in">cornerHarris</span>(image, cornerStrength,</span><br><span class="line">        neighborhood, aperture, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// internal threshold computation</span></span><br><span class="line">        cv::<span class="built_in">minMaxLoc</span>(cornerStrength, <span class="number">0</span>, &amp;maxStrength);</span><br><span class="line">        <span class="comment">// local maxima detection</span></span><br><span class="line">        cv::Mat dilated;</span><br><span class="line">        cv::<span class="built_in">dilate</span>(cornerStrength, dilated, cv::<span class="built_in">Mat</span>());</span><br><span class="line">        cv::<span class="built_in">compare</span>(cornerStrength, dilated, localMax, cv::CMP_EQ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the corner map from the computed Harris values</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getCornerMap</span><span class="params">(<span class="type">double</span> qualityLevel)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        cv::Mat cornerMap;</span><br><span class="line">        <span class="comment">// thresholding the corner strength</span></span><br><span class="line">        threshold = qualityLevel*maxStrength;</span><br><span class="line">        cv::<span class="built_in">threshold</span>(cornerStrength, cornerTh, threshold,</span><br><span class="line">        <span class="number">255</span>, cv::THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert to 8-bit image</span></span><br><span class="line">        cornerTh.<span class="built_in">convertTo</span>(cornerMap, CV_8U);</span><br><span class="line">        <span class="comment">// not-maxima suppression</span></span><br><span class="line">        cv::<span class="built_in">bitwise_and</span>(cornerMap, localMax, cornerMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cornerMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the feature points from the computed Harris values</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCorners</span><span class="params">(std::vector&lt;cv::Point&gt;&amp;points, <span class="type">double</span> qualityLeves)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get the corner map</span></span><br><span class="line">        cv::Mat cornerMap = <span class="built_in">getCornerMap</span>(qualityLeves);</span><br><span class="line">        <span class="comment">// Get the corners</span></span><br><span class="line">        <span class="built_in">getCorners</span>(points, cornerMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the feature points from the computed corner mao</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCorners</span><span class="params">(std::vector&lt;cv::Point&gt;&amp;points,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> cv::Mat&amp; cornerMap)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over the pixels to obtain all features</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; cornerMap.rows; y++)&#123;</span><br><span class="line">            <span class="type">const</span> uchar* rowPtr = cornerMap.<span class="built_in">ptr</span>&lt;uchar&gt;(y);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; cornerMap.cols; x++)&#123;</span><br><span class="line">                <span class="comment">// if it is a feature point</span></span><br><span class="line">                <span class="keyword">if</span>(rowPtr[x])&#123;</span><br><span class="line">                    points.<span class="built_in">push_back</span>(cv::<span class="built_in">Point</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Draw circles at feature point locations on an image</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawOnImage</span><span class="params">(cv::Mat&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> std::vector&lt;cv::Point&gt;&amp;points,</span></span></span><br><span class="line"><span class="params"><span class="function">                    cv::Scalar color = cv::Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> radius=<span class="number">3</span>, <span class="type">int</span> thickness=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">        std::vector&lt;cv::Point&gt;::const_iterator it = points.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// for all corners</span></span><br><span class="line">        <span class="keyword">while</span> (it != points.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// draw a circle at each corner location</span></span><br><span class="line">            cv::<span class="built_in">circle</span>(image, *it, radius, color, thickness);</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_HARRISDETECTOR_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-cpp-6">main.cpp</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;harrisDetector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">findHarrisCorner</span><span class="params">(<span class="type">const</span> Mat image)</span></span>&#123;</span><br><span class="line">    Mat HarriCorner;</span><br><span class="line">    <span class="built_in">cornerHarris</span>(image,</span><br><span class="line">                HarriCorner,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    Mat HarriCornerThreshed;</span><br><span class="line">    <span class="type">double</span> thresholdNum = <span class="number">0.0001</span>;</span><br><span class="line">    <span class="built_in">threshold</span>(HarriCorner, HarriCornerThreshed,</span><br><span class="line">                thresholdNum, <span class="number">255</span>, THRESH_BINARY_INV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HarriCornerThreshed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">MGFTT</span><span class="params">(Mat image)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Compute good features to track</span></span><br><span class="line">    std::vector&lt;cv::KeyPoint&gt;keypoints;</span><br><span class="line">    <span class="comment">// GFTT detector</span></span><br><span class="line">    cv::Ptr&lt;cv::GFTTDetector&gt;ptrGFTT =</span><br><span class="line">            cv::GFTTDetector::<span class="built_in">create</span>(</span><br><span class="line">                    <span class="number">500</span>,</span><br><span class="line">                    <span class="number">0.01</span>,</span><br><span class="line">                    <span class="number">10</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detect the GFTT</span></span><br><span class="line">    ptrGFTT-&gt;<span class="built_in">detect</span>(image, keypoints);</span><br><span class="line">    std::vector&lt;cv::KeyPoint&gt;::const_iterator it = keypoints.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != keypoints.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cv::<span class="built_in">circle</span>(image, it-&gt;pt, <span class="number">3</span>, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>);</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat image;</span><br><span class="line">    image = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/MyCV/data/church01.jpg&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Raw harrisCorner</span></span><br><span class="line">    Mat HarriCornerThreshed;</span><br><span class="line">    HarriCornerThreshed = <span class="built_in">findHarrisCorner</span>(image);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;HarrisCornerThreshed&quot;</span>, HarriCornerThreshed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// non-maxima suppression(for the problem of feature point clustering.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Harris detector instance</span></span><br><span class="line">    Mat image2;</span><br><span class="line">    image.<span class="built_in">copyTo</span>(image2);</span><br><span class="line"></span><br><span class="line">    harrisDetector harris;</span><br><span class="line">    <span class="comment">// Compute Harris values</span></span><br><span class="line">    harris.<span class="built_in">detect</span>(image2);</span><br><span class="line">    <span class="comment">// Detect Harris corners</span></span><br><span class="line">    std::vector&lt;cv::Point&gt; pts;</span><br><span class="line">    harris.<span class="built_in">getCorners</span>(pts, <span class="number">0.02</span>);</span><br><span class="line">    <span class="comment">// Draw Harris corners</span></span><br><span class="line">    harris.<span class="built_in">drawOnImage</span>(image2, pts);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;non-maxima suppression&quot;</span>, image2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  impose a minimum distance between two interest points.</span></span><br><span class="line">    <span class="comment">// (for the problem of feature point clustering.)</span></span><br><span class="line">    Mat image3;</span><br><span class="line">    image.<span class="built_in">copyTo</span>(image3);</span><br><span class="line"></span><br><span class="line">    Mat GfttImage;</span><br><span class="line">    GfttImage = <span class="built_in">MGFTT</span>(image3);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;GFTT&quot;</span>, GfttImage);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://otdfzpvtk.bkt.clouddn.com/Selection_072001.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记二十：Segmenting images using watersheds</title>
    <url>/2017/05/24/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%EF%BC%9ASegmenting-images-using/</url>
    <content><![CDATA[<h4 id="Overview-38">Overview</h4>
<p>关于分水岭算法：</p>
<blockquote>
<p>The watershed transformation is a popular image processing algorithm that is used to quickly segment an image into homogenous regions. It relies on the idea that when the image is seen as a topological relief, the homogeneous regions correspond to relatively flat basins delimited by steep edges.</p>
</blockquote>
<p>在同质区域的分割里，watersheds是很好用的一个算法，但是其存在over-segment的问题，也就是会错误地分割出很多小的区域。这点我们可以通过在应用算法前手动添加标记来弥补。</p>
<p>算法的进一步理解：</p>
<blockquote>
<p>use the topological map analogy in the description of the watershed algorithm. In order to create watershed segmentation, the idea is to progressively flood the image starting at level 0. As the level of water progressively increases (to levels 1, 2, 3, and so on), catchment basins are formed. The size of these basins also gradually increases and, consequently, the water of two different basins will eventually merge. When this happens, a watershed is created in order to keep the two basins separated. Once the level of water has reached its maximum level, the sets of these created basins and watersheds form the watershed segmentation.</p>
</blockquote>
<h4 id="Code-31">Code</h4>
<h5 id="watershedSegmentation-h">watershedSegmentation.h</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONS_WATERSHEDSEGMENTATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONS_WATERSHEDSEGMENTATION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONS_WATERSHEDSEGMENTATION_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WatershedSegmenter</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cv::Mat markers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMarkers</span><span class="params">(<span class="type">const</span> cv::Mat&amp; markerImage)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to image of ints</span></span><br><span class="line">        markerImage.<span class="built_in">convertTo</span>(markers, CV_32S);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">cv::Mat <span class="title">process</span><span class="params">(<span class="type">const</span> cv::Mat &amp; image)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply watershed</span></span><br><span class="line">        cv::<span class="built_in">watershed</span>(image, markers);</span><br><span class="line">        <span class="keyword">return</span> markers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return result in the form of an image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getSegmentation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cv::Mat tmp;</span><br><span class="line">        <span class="comment">// all segment with label higher than 255</span></span><br><span class="line">        <span class="comment">// will be assigned value 255</span></span><br><span class="line">        markers.<span class="built_in">convertTo</span>(tmp, CV_8U);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return watershed in the form of an image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">getWatersheds</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cv::Mat tmp;</span><br><span class="line">        <span class="comment">// -1*255+255 = 0  --&gt; 分水岭算法将边界标记为-1，如此转化为0，黑色，其余全白色</span></span><br><span class="line">        markers.<span class="built_in">convertTo</span>(tmp, CV_8U, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-cpp-7">main.cpp</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;watershedSegmentation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/cattle.png&quot;</span>);</span><br><span class="line">    cv::Mat binary = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/binary.bmp&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;raw image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;raw binary&quot;</span>, binary);</span><br><span class="line">    <span class="comment">// Eliminate noise and smaller objects</span></span><br><span class="line">    cv::Mat fg;</span><br><span class="line">    cv::<span class="built_in">erode</span>(binary, fg, cv::<span class="built_in">Mat</span>(), cv::<span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), <span class="number">4</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;fg&quot;</span>, fg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    threshold_type=CV_THRESH_BINARY:</span></span><br><span class="line"><span class="comment">//    dst(x,y) = max_value, if src(x,y)&gt;threshold ; 0, otherwise.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    threshold_type=CV_THRESH_BINARY_INV:</span></span><br><span class="line"><span class="comment">//    dst(x,y) = 0, if src(x,y)&gt;threshold; dst(x,y) = max_value,otherwise.</span></span><br><span class="line"></span><br><span class="line">    cv::Mat bg;</span><br><span class="line">    cv::<span class="built_in">dilate</span>(binary, bg, cv::<span class="built_in">Mat</span>(), cv::<span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>) ,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 使得原来为黑色[0]的，变为灰色[草地]， 原来为白色[255]的，变为黑色[牛群]</span></span><br><span class="line">    cv::<span class="built_in">threshold</span>(bg, bg, <span class="number">1</span>, <span class="number">128</span>, cv::THRESH_BINARY_INV);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;bg&quot;</span>, bg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create markers image</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">markers</span><span class="params">(binary.size(), CV_8U, cv::Scalar(<span class="number">0</span>))</span></span>;</span><br><span class="line">    markers = fg+bg;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;markers&quot;</span>, markers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create watershed segmentation object</span></span><br><span class="line">    WatershedSegmenter segmenter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set markers and process</span></span><br><span class="line">    segmenter.<span class="built_in">setMarkers</span>(markers);</span><br><span class="line">    segmenter.<span class="built_in">process</span>(image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display segmentation result</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Segmentation&quot;</span>, segmenter.<span class="built_in">getSegmentation</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display watersheds</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Watershed&quot;</span>, segmenter.<span class="built_in">getWatersheds</span>());</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052402.png" alt=""></p>
<h5 id="main-cpp-8">main.cpp</h5>
<p>我们可以手工添加标记来防止watersheds固有的over-segment问题，是为Marker-controlled watershed。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;watershedSegmentation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/tower.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify background pixels</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">imageMask</span><span class="params">(image.size(), CV_8U, cv::Scalar(<span class="number">0</span>))</span></span>;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(imageMask, cv::<span class="built_in">Point</span>(<span class="number">5</span>,<span class="number">5</span>), cv::<span class="built_in">Point</span>(image.cols<span class="number">-5</span>, image.rows<span class="number">-5</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Identify foreground pixels(int the middle of the image)</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(imageMask, cv::<span class="built_in">Point</span>(image.cols/<span class="number">2</span><span class="number">-10</span>, image.rows/<span class="number">2</span><span class="number">-10</span>), cv::<span class="built_in">Point</span>(image.cols/<span class="number">2</span>+<span class="number">10</span>, image.rows/<span class="number">2</span>+<span class="number">10</span>), cv::<span class="built_in">Scalar</span>(<span class="number">1</span>),<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set markers and process</span></span><br><span class="line">    WatershedSegmenter segmenter;</span><br><span class="line">    segmenter.<span class="built_in">setMarkers</span>(imageMask);</span><br><span class="line">    segmenter.<span class="built_in">process</span>(image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the image with markers</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Point</span>(<span class="number">5</span>,<span class="number">5</span>), cv::<span class="built_in">Point</span>(image.cols<span class="number">-1</span>, image.rows<span class="number">-5</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Point</span>(image.cols/<span class="number">2</span><span class="number">-10</span>,image.rows/<span class="number">2</span><span class="number">-10</span>),cv::<span class="built_in">Point</span>(image.cols/<span class="number">2</span>+<span class="number">10</span>,image.rows/<span class="number">2</span>+<span class="number">10</span>),cv::<span class="built_in">Scalar</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="number">10</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image with marker&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display watersheds</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Watershed&quot;</span>, segmenter.<span class="built_in">getWatersheds</span>());</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052403.png" alt=""></p>
<h4 id="Reference-10">Reference</h4>
<p><a href="http://cmm.ensmp.fr/~beucher/wtshed.html#mark">http://cmm.ensmp.fr/~beucher/wtshed.html#mark</a><br>
<a href="http://docs.opencv.org/3.1.0/d3/db4/tutorial_py_watershed.html">http://docs.opencv.org/3.1.0/d3/db4/tutorial_py_watershed.html</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记三：Draw on image</title>
    <url>/2017/04/27/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9ADraw-on-image/</url>
    <content><![CDATA[<h5 id="Overview-39">Overview</h5>
<p>有些时候，我们需要在图片上做一些标记，好比画些矩形，圆形或者一些文字。OpenCV提供了很好用的接口，除了文字有点丑…</p>
<h5 id="Code-32">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mouse trackbar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/mang.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  a rectangle on the top of the image</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, cv::<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>), cv::<span class="built_in">Point</span>(image.cols, <span class="number">50</span>), cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put some text</span></span><br><span class="line">    cv::<span class="built_in">putText</span>(image, <span class="string">&quot;A Text Test&quot;</span>, cv::<span class="built_in">Point</span>(image.cols/<span class="number">3</span>, <span class="number">30</span>), cv::FONT_HERSHEY_PLAIN, <span class="number">2.0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170427/Selection_002.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记八：Remapping</title>
    <url>/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%9ARemapping/</url>
    <content><![CDATA[<h5 id="Overview-40">Overview</h5>
<p>关于Remapping, <a href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/remap/remap.html">官方文档</a>已经解释的十分清楚了。</p>
<blockquote>
<p>It is the process of taking pixels from one place in the image and locating them in another position in a new image.</p>
<p>To accomplish the mapping process, it might be necessary to do some interpolation for non-integer pixel locations, since there will not always be a one-to-one-pixel correspondence between source and destination images.</p>
<p>We can express the remap for every pixel location (x,y) as:<br>
<code>g(x,y) = f ( h(x,y) )</code><br>
where g() is the remapped image, f() the source image and h(x,y) is the mapping function that operates on (x,y)</p>
</blockquote>
<p>注意这里对函数的理解，也就是remapping的过程，举个简单的例子，当remapping函数为h(x,y)=(x+1, y+1)时， 新的图像g(3,4) = f(h(3, 4)) = f(4, 5), 也就是说新得到的图像(3,4)处的像素点原来是在原图像的(4, 5)处。</p>
<h5 id="Code-33">Code</h5>
<p>这里是书上的一段代码，很简短，官方文档给的例子比较好些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remapping an image by createing wave effects</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wave</span><span class="params">(<span class="type">const</span> cv::Mat &amp;image, cv::Mat &amp;result)</span></span>&#123;</span><br><span class="line">    <span class="comment">//the mao function</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">srcX</span><span class="params">(image.rows, image.cols, CV_32F)</span></span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">srcY</span><span class="params">(image.rows, image.cols, CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creating the mapping</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image.rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; image.cols; j++) &#123;</span><br><span class="line">            <span class="comment">// new location of pixel at (i, j)</span></span><br><span class="line">            srcX.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j)=j;</span><br><span class="line">            srcY.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,j) = i+<span class="number">5</span>*<span class="built_in">sin</span>(j/<span class="number">10.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// applying the mapping</span></span><br><span class="line">    cv::<span class="built_in">remap</span>(image,result, srcX, srcY,cv::INTER_LINEAR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image1 = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    <span class="built_in">getImageInfo</span>(image1);</span><br><span class="line">    cv::Mat result;</span><br><span class="line">    <span class="built_in">wave</span>(image1, result);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170427/7.png" alt=""></p>
<h5 id="Reference-11">Reference</h5>
<p><a href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/remap/remap.html">Remapping</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记四：ROI</title>
    <url>/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9AROI/</url>
    <content><![CDATA[<h5 id="Overview-41">Overview</h5>
<p>在对图片进行处理的时候，我们关注的往往是图片的某些区域，称为regions of interest，即为ROI。我们的操作也是主要针对这些区域进行的。来看下面这个向图片上添加logo的例子。</p>
<h5 id="Code-34">Code</h5>
<p>我们直接将logo加到图片上去，即使使用权重，效果也是不好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image, logo;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/bao.jpeg&quot;</span>);</span><br><span class="line">    logo = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/logo.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;logo&quot;</span>, logo);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// define image ROI at image bottom-right</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">imageROI</span><span class="params">(image, cv::Rect(<span class="number">0</span>,<span class="number">0</span>, logo.cols, logo.rows))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  insert logo directly</span></span><br><span class="line">    logo.<span class="built_in">copyTo</span>(imageROI);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;add drictly&quot;</span>, image);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  add in weight</span></span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">addWeighted</span>(imageROI, <span class="number">0.7</span>, logo, <span class="number">0.3</span>, <span class="number">0</span>,imageROI);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;add in weight&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170427/1.png" alt=""></p>
<p>这里，我们应当专注于ROI的mask使用，用来提取logo的主体和ROI的背景。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image, logo;</span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/bao.jpeg&quot;</span>);</span><br><span class="line">    logo = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/logo.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;logo&quot;</span>, logo);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image);</span><br><span class="line">    <span class="comment">// define image ROI at image bottom-right</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">imageROI</span><span class="params">(image, cv::Rect(<span class="number">0</span>,<span class="number">0</span>, logo.cols, logo.rows))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::Mat logo_gray;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(logo, logo_gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    cv::Mat mask, mask_inv;</span><br><span class="line">    <span class="comment">//下面将logo主体形状[灰度值不再100-255的部分]标记为白色255，即在按位和时取此白色部分</span></span><br><span class="line">    cv::<span class="built_in">threshold</span>(logo_gray, mask, <span class="number">100</span>, <span class="number">255</span>, CV_THRESH_BINARY_INV);</span><br><span class="line">    <span class="comment">// mask_inv与mask颜色相反[黑白互换即0,255互换]，即在取按位和时取logo的背景部分</span></span><br><span class="line">    cv::<span class="built_in">bitwise_not</span>(mask,mask_inv);</span><br><span class="line"></span><br><span class="line">    cv::Mat img_bg, logo_fg;</span><br><span class="line">    <span class="comment">//取出ROI中和背景部分重合的区域，预留主体部分为黑色0</span></span><br><span class="line">    cv::<span class="built_in">bitwise_and</span>(imageROI,imageROI, img_bg, mask_inv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从logo中取出logo主体部分，预留非logo主体部分为黑色0</span></span><br><span class="line">    cv::<span class="built_in">bitwise_and</span>(logo,logo,logo_fg,mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相加合并图像</span></span><br><span class="line">    cv::<span class="built_in">add</span>(img_bg, logo_fg,imageROI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理过程中产生的图像</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;img_bg&quot;</span>, img_bg);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;logo_fg&quot;</span>, logo_fg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后完成合并的图像</span></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170427/2.png" alt=""></p>
<p>这段代码对初学者理解起来可能有些困难，我也是反复看了几次才搞懂…主要的流程就是，先将logo转化为灰度图，再进行threshold操作，用mask分离出logo主体，再通过mask作用于logo的按位和得到logo主体部分，其余背景为0（黑色）；同样地，再将mask_inv作用于原图片的ROI区域的按位和，得到ROI区域的背景，其中预留将要和logo主体重合的部分为0（黑色）。这样，再直接将抠出来的背景和logo相加，就得到看了想要的效果了。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV获取安卓手机摄像头的视频流</title>
    <url>/2017/07/22/OpenCV%E8%8E%B7%E5%8F%96%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%A7%86%E9%A2%91%E6%B5%81/</url>
    <content><![CDATA[<p>最近又拿来<em>OpenCV 3 Computer Vision Application Programming Cookbook</em>看，上学期学到第8章就停下来在这里写笔记总结了。略过了三维重建那章，看到了视频的处理，其实这个基本的操作基本会了。然后觉着电脑摄像头像素太差…突然想到能不能用下手机的摄像头:-)于是就搜了下，还真有…方法也挺简单的。</p>
<p>首先到Google play（当然有墙了orz…）下载<a href="https://play.google.com/store/apps/details?id=com.pas.webcam&amp;hl=en">IP Webcam</a>.然后把手机和电脑连到同一个WIFI下，手机端开启视频流服务。根据手机端的提示，我们到http://192.168.1.106:8080/ 即可看到手机摄像头的实时视频。</p>
<p>但是呢，我们获取的视频能够实时地被处理才有意义。所以，我们可以直接导入到OpenCV内，方便进一步的处理。下面给出两种办法，第一种是用了curl库，略显复杂：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curl/curl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">write_data</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    std::ostringstream *stream = (std::ostringstream*)userdata;</span><br><span class="line">    <span class="type">size_t</span> count = size * nmemb;</span><br><span class="line">    stream-&gt;<span class="built_in">write</span>(ptr, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function to retrieve the image as Cv::Mat data type</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">curlImg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    std::ostringstream stream;</span><br><span class="line">    curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, <span class="string">&quot;http://192.168.1.106:8080/shot.jpg&quot;</span>); <span class="comment">//the JPEG Frame url  //</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, write_data); <span class="comment">// pass the writefunction</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, &amp;stream); <span class="comment">// pass the stream ptr when the writefunction is called</span></span><br><span class="line">    res = <span class="built_in">curl_easy_perform</span>(curl); <span class="comment">// start curl</span></span><br><span class="line">    std::string output = stream.<span class="built_in">str</span>(); <span class="comment">// convert the stream into a string</span></span><br><span class="line">    <span class="built_in">curl_easy_cleanup</span>(curl); <span class="comment">// cleanup</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data = std::<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;( output.<span class="built_in">begin</span>(), output.<span class="built_in">end</span>() ); <span class="comment">//convert string into a vector</span></span><br><span class="line">    cv::Mat data_mat = cv::<span class="built_in">Mat</span>(data); <span class="comment">// create the cv::Mat datatype from the vector</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imdecode</span>(data_mat,<span class="number">1</span>); <span class="comment">//read an image from memory buffer</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>( <span class="string">&quot;Image output&quot;</span>, CV_WINDOW_AUTOSIZE );</span><br><span class="line">    <span class="type">double</span> scale=<span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat image = <span class="built_in">curlImg</span>(); <span class="comment">// get the image frame</span></span><br><span class="line">        <span class="comment">//可以不resize，不过电脑端会图像显示很大</span></span><br><span class="line">        cv::Size dsize = cv::<span class="built_in">Size</span>(image.cols*scale,image.rows*scale);</span><br><span class="line">        cv::Mat image2 = cv::<span class="built_in">Mat</span>(dsize,CV_32S);</span><br><span class="line">        <span class="built_in">resize</span>(image, image2,dsize);</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image output&quot;</span>,image2); <span class="comment">//display image frame</span></span><br><span class="line">        <span class="type">char</span> c = <span class="built_in">cvWaitKey</span>(<span class="number">33</span>); <span class="comment">// sleep for 33ms or till a key is pressed (put more then ur camera framerate mine is 30ms)</span></span><br><span class="line">        <span class="keyword">if</span> ( c == <span class="number">27</span> ) <span class="keyword">break</span>; <span class="comment">// break if ESC is pressed</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">destroyWindow</span>(<span class="string">&quot;Image output&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一种就比较简单，直接利用OpenCV自带的处理视频流的函数即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MCamera</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::VideoCapture capture;</span><br><span class="line">    capture.<span class="built_in">open</span>(<span class="string">&quot;http://192.168.1.106:8080/video&quot;</span>);</span><br><span class="line">    <span class="comment">// Check if video successfully opened</span></span><br><span class="line">    <span class="keyword">if</span>(capture.<span class="built_in">isOpened</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OK!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the frame rate</span></span><br><span class="line">    <span class="type">double</span> rate = capture.<span class="built_in">get</span>(CV_CAP_PROP_FPS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    cv::Mat frame;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Extracted Frame&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delay between each frame in ms</span></span><br><span class="line">    <span class="comment">// corresponds to video frame rate</span></span><br><span class="line">    <span class="type">int</span> delay = <span class="number">1000</span>/rate;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rate: &quot;</span> &lt;&lt; rate &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1/rate: &quot;</span> &lt;&lt; <span class="number">1</span>/rate &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for all frames in video</span></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        <span class="comment">// read next frame if any</span></span><br><span class="line">        <span class="keyword">if</span> (!capture.<span class="built_in">read</span>(frame))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Extracted Frame&quot;</span>, frame);</span><br><span class="line">        <span class="comment">// introduce a delay</span></span><br><span class="line">        <span class="comment">// or press key to stop</span></span><br><span class="line">        <span class="keyword">if</span>(cv::<span class="built_in">waitKey</span>(delay)&gt;=<span class="number">0</span>)</span><br><span class="line">            stop=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the video file</span></span><br><span class="line">    capture.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">MCamera</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方法就比较直观，也容易使用。这里我们是直接获使用和MJPEG URL进行视频流的获取，除此之外我们还有其他的请求方式：</p>
<blockquote>
<p><a href="http://192.168.1.106:8080/video">http://192.168.1.106:8080/video</a> 是 MJPEG URL.<br>
<a href="http://192.168.1.106:8080/shot.jpg">http://192.168.1.106:8080/shot.jpg</a> 获取最新一帧<br>
<a href="http://192.168.1.106:8080/audio.wav">http://192.168.1.106:8080/audio.wav</a> 是WAV格式的音频流<br>
<a href="http://192.168.1.106:8080/audio.aac">http://192.168.1.106:8080/audio.aac</a> 是AAC格式的音频流（如果硬件支持的话）<br>
<a href="http://192.168.1.106:8080/audio.opus">http://192.168.1.106:8080/audio.opus</a> 是Opus格式的音频流<br>
<a href="http://192.168.1.106:8080/focus">http://192.168.1.106:8080/focus</a> 对焦摄像头<br>
<a href="http://192.168.1.106:8080/nofocus">http://192.168.1.106:8080/nofocus</a> 释放对焦</p>
</blockquote>
<p>更多设置参考 <a href="http://192.168.1.106:8080/viewers.html#advanced%E3%80%82">http://192.168.1.106:8080/viewers.html#advanced。</a></p>
<p>这里两种方法的测试效果都是挺好的，播放都很流畅，几乎没有延迟。</p>
<p>其实ivideon也提供给我们一种不需要连接在同一WIFI下就可以查看安卓视频流的方法，那就是通过ivideon的帐号。在手机端登录，在浏览器也进行登录即可查看，但是没有找到相关的接口可以用Cpp直接请求来获取数据，可能需要自己模拟登录再抓包获取，不过还不会用Cpp写爬虫呢…这个测试的效果也并不太好，比较卡，而且延迟较高。等有时间再看下这个能不能解决吧。</p>
<p>除了使用自己的摄像头之外，网络上也有一些开放的IP Camera （之后我们可以用这些资源做些测试嘛0.0） , 我们可以直接在浏览器访问，OpenCV也为我们提供了很好的接口从网上直接读取视频。</p>
<p>比如这个地址：　<code>http://150.214.93.55/mjpg/video.mjpg</code>，　以及　<code>http://plazacam.studentaffairs.duke.edu/view/view.shtml?id=2862&amp;imagepath=/mjpg/video.mjpg&amp;size=1</code> 都是可以在浏览器直接看到实时的界面的，前面一种比较简单，像上面一样直接将地址替换即可。但是后面的这个地址是不能直接替换的，根据<a href="https://stackoverflow.com/questions/15584161/ip-camera-and-opencv">这里</a>我们尝试找到视频的真正地址为<code>http://plazacam.studentaffairs.duke.edu/mjpg/video.mjpg</code>,使用这个即可。但是参考的这个答案说：</p>
<blockquote>
<p>one way or the other, opencv seems to insist, that the url must end with “.mjpg” (dot mjpg), so if it doesn’t, add a dummy param to it, like : my/fancy/url?type=.mjpg</p>
</blockquote>
<p>还好有个seems to insist … 因为我们前面已经看到了，安卓手机的摄像头的地址并非以<code>.mjpg</code>结尾。</p>
<p>暂时先记录下，继续学习CV，等到能较好地识别视频中一些物体时再结合这个看能不能做个小应用玩玩。</p>
<p>参考：</p>
<p><a href="http://blog.leanote.com/post/leeyoung/opencv%E8%8E%B7%E5%8F%96android%E6%89%8B%E6%9C%BA%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%A7%86%E9%A2%91%E6%B5%81-2">opencv获取android手机摄像头的视频流 </a></p>
<p><a href="">IP camera and OPENCV</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV计算结果保存--YAML/XML</title>
    <url>/2017/05/15/OpenCV%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98-YAML/</url>
    <content><![CDATA[<p>在图像的操作与识别等过程中，我们很多时候要保存一些计算结果，方便后续的使用。OpenCV为我们提供了XML/YAML持久化层来完成这个任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入操作</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">&quot;Test.yml&quot;</span>, FileStorage::WRITE)</span></span>;</span><br><span class="line">    <span class="comment">// save as int</span></span><br><span class="line">    <span class="type">int</span> fps = <span class="number">5</span>;</span><br><span class="line">    fs&lt;&lt;<span class="string">&quot;fps&quot;</span>&lt;&lt;fps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mat</span></span><br><span class="line">    Mat m1 = Mat::<span class="built_in">eye</span>(<span class="number">2</span>, <span class="number">3</span>, CV_32F);</span><br><span class="line">    Mat m2 = Mat::<span class="built_in">ones</span>(<span class="number">3</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">    Mat result = (m1+<span class="number">1</span>).<span class="built_in">mul</span>(m1+<span class="number">3</span>);</span><br><span class="line">    fs&lt;&lt;<span class="string">&quot;Result&quot;</span>&lt;&lt;result;</span><br><span class="line"></span><br><span class="line">    fs.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取操作</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs_r</span><span class="params">(<span class="string">&quot;Test.yml&quot;</span>, FileStorage::READ)</span></span>;</span><br><span class="line"></span><br><span class="line">    Mat r;</span><br><span class="line">    fs_r[<span class="string">&quot;Result&quot;</span>] &gt;&gt; r;</span><br><span class="line">    std::cout&lt;&lt; r&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    fs_r.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>[8, 3, 3;<br>
3, 8, 3]</p>
</blockquote>
<p>此时，查看Test.YML文件：</p>
<pre><code>%YAML:1.0
---
fps: 5
Result: !!opencv-matrix
   rows: 2
   cols: 3
   dt: f
   data: [ 8., 3., 3., 3., 8., 3. ]
</code></pre>
<p>同样地，我们将上面文件的拓展名改为.xml，再次运行我们可以得到Test.xml文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;opencv_storage&gt;
&lt;fps&gt;5&lt;/fps&gt;
&lt;Result type_id=&quot;opencv-matrix&quot;&gt;
  &lt;rows&gt;2&lt;/rows&gt;
  &lt;cols&gt;3&lt;/cols&gt;
  &lt;dt&gt;f&lt;/dt&gt;
  &lt;data&gt;
    8. 3. 3. 3. 8. 3.&lt;/data&gt;&lt;/Result&gt;
&lt;/opencv_storage&gt;
</code></pre>
<p>参考：<em>OpenCV By Example</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV识别条形码——python实现[CPP补充]</title>
    <url>/2017/03/02/OpenCV%E8%AF%86%E5%88%AB%E6%9D%A1%E5%BD%A2%E7%A0%81%E2%80%94%E2%80%94python%E5%AE%9E%E7%8E%B0-CPP%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>在之前的[这篇文章](待测文件： 位于与当前cpp文件同目录的data文件夹下<br>
<a href="http://datahonor.com/2017/03/02/OpenCV%E8%AF%86%E5%88%AB%E6%9D%A1%E5%BD%A2%E7%A0%81%E2%80%94%E2%80%94python%E5%AE%9E%E7%8E%B0/">http://datahonor.com/2017/03/02/OpenCV识别条形码——python实现/</a>)，仿照教程做了一个条形码识别的程序，不过结果不太理想，就暂时放下，最近继续看OpenCV官方文档，看到了Template Matching，于是动手实验了一下，成功的解决了问题。</p>
<p>环境：ubuntu14.04， OpenCV3.2.0， Clion</p>
<h5 id="data-barcode-jpg">data/barcode.jpg</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/barcode.jpg" alt=""></p>
<h5 id="data-barcode-temp-png">/data/barcode_temp.png</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/barcode_temp.png" alt=""></p>
<h5 id="Code-35">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Function Headers</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatchingMethod</span><span class="params">( <span class="type">int</span>, <span class="type">void</span>* )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @function main */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Load image and template</span></span><br><span class="line">    img = <span class="built_in">imread</span>( argv[<span class="number">1</span>], <span class="number">1</span> );</span><br><span class="line">    templ = <span class="built_in">imread</span>( argv[<span class="number">2</span>], <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create windows</span></span><br><span class="line">    <span class="built_in">namedWindow</span>( image_window, CV_WINDOW_AUTOSIZE );</span><br><span class="line">    <span class="built_in">namedWindow</span>( result_window, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create Trackbar</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *trackbar_label = <span class="string">&quot;Method: \n 0: SQDIFF \n 1: SQDIFF NORMED \n 2: TM CCORR \n 3: TM CCORR NORMED \n 4: TM COEFF \n 5: TM COEFF NORMED&quot;</span>;</span><br><span class="line">    <span class="built_in">createTrackbar</span>( trackbar_label, image_window, &amp;match_method, max_Trackbar, MatchingMethod );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MatchingMethod</span>( <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @function MatchingMethod</span></span><br><span class="line"><span class="comment"> * @brief Trackbar callback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatchingMethod</span><span class="params">( <span class="type">int</span>, <span class="type">void</span>* )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Source image to display</span></span><br><span class="line">    Mat img_display;</span><br><span class="line">    img.<span class="built_in">copyTo</span>( img_display );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create the result matrix</span></span><br><span class="line">    <span class="type">int</span> result_cols =  img.cols - templ.cols + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result_rows = img.rows - templ.rows + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">create</span>( result_rows, result_cols, CV_32FC1 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Do the Matching and Normalize</span></span><br><span class="line">    <span class="built_in">matchTemplate</span>( img, templ, result, match_method );</span><br><span class="line">    <span class="built_in">normalize</span>( result, result, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Localizing the best match with minMaxLoc</span></span><br><span class="line">    <span class="type">double</span> minVal; <span class="type">double</span> maxVal; Point minLoc; Point maxLoc;</span><br><span class="line">    Point matchLoc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">minMaxLoc</span>( result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, <span class="built_in">Mat</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better</span></span><br><span class="line">    <span class="keyword">if</span>( match_method  == CV_TM_SQDIFF || match_method == CV_TM_SQDIFF_NORMED )</span><br><span class="line">    &#123; matchLoc = minLoc; &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; matchLoc = maxLoc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Show me what you got</span></span><br><span class="line">    <span class="built_in">rectangle</span>( img_display, matchLoc, <span class="built_in">Point</span>( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), Scalar::<span class="built_in">all</span>(<span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">rectangle</span>( result, matchLoc, <span class="built_in">Point</span>( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), Scalar::<span class="built_in">all</span>(<span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>( image_window, img_display );</span><br><span class="line">    <span class="built_in">imshow</span>( result_window, result );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后在Clion编译运行：</p>
<blockquote>
<p>cmake .      // 注意空格<br>
make<br>
./CvTest data/barcode.jpg data/barcode_temp.png    // CvTest是我的项目名称</p>
</blockquote>
<p>运行结果如下： 可通过滑动trackbar选择不同的matching方式<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/barcode-1.jpg" alt=""><br>
最后，要注意的是，上面的barcode_temp.png是直接从barcode.jpg中截取的照片，而我们使用的又是以来与Histgram的算法，所以模板图片的大小可能会对其识别有一定的影响，具体改进等继续学习以后再回来补充了。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV识别条形码——python实现</title>
    <url>/2017/03/02/OpenCV%E8%AF%86%E5%88%AB%E6%9D%A1%E5%BD%A2%E7%A0%81%E2%80%94%E2%80%94python%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>今天看到<a href="http://python.jobbole.com/80448/">这篇文章</a>，这里保留核心识别算法，稍微进行一些改动贴在这里学习研究。</p>
<p>环境：Win32, Anaconda3, Spyder, OpenCV3.1.0</p>
<p>文件目录：</p>
<blockquote>
<p>待测试图片文件夹test-imgs<br>
核心预测算法实现bar_code.py<br>
图片批处理imgs_pro.py</p>
</blockquote>
<h5 id="Code-36">Code</h5>
<h6 id="bar-code-py">bar_code.py</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Mon Dec 26 21:46:21 2016</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Administrator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#image_name = input(&quot;Enter the name of the picture:&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect</span>(<span class="params">image_name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在识别&quot;</span>+image_name+<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">    <span class="comment"># Load the image and convert it to grayscale</span></span><br><span class="line">    image = cv2.imread(image_name)</span><br><span class="line">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute the Scharr gradient magnitude representation of the iamges</span></span><br><span class="line">    <span class="comment"># in both the x and y direction</span></span><br><span class="line">    <span class="comment"># 原来代码下面是cv2.cv.CV_32F会报错-&gt;AttributeError: module &#x27;cv2&#x27; has no attribute &#x27;cv&#x27;</span></span><br><span class="line">    <span class="comment"># 在新版本变为cv2.CV_32F</span></span><br><span class="line">    gradX = cv2.Sobel(gray, ddepth = cv2.CV_32F, dx = <span class="number">1</span>, dy = <span class="number">0</span>, ksize = -<span class="number">1</span>)</span><br><span class="line">    gradY = cv2.Sobel(gray, ddepth = cv2.CV_32F, dx = <span class="number">0</span>, dy = <span class="number">1</span>, ksize = -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># substract the y-gradient from the x-gradient</span></span><br><span class="line">    gradient = cv2.subtract(gradX, gradY)</span><br><span class="line">    gradient = cv2.convertScaleAbs(gradient)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># blur and threhold the image</span></span><br><span class="line">    <span class="comment"># 这里(13,13)是kernel matrix size，自己可以改变看看识别效果</span></span><br><span class="line">    blurred = cv2.blur(gradient, (<span class="number">13</span>, <span class="number">13</span>))</span><br><span class="line">    <span class="comment"># 这里的阀值200,255也可以根据图片自定义</span></span><br><span class="line">    (_, thresh) = cv2.threshold(blurred, <span class="number">200</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct a closing kernel and apply it to the thresholded image</span></span><br><span class="line">    <span class="comment"># (20, 15)也是一个参数，用来获取需要的kernel</span></span><br><span class="line">    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">20</span>, <span class="number">15</span>))</span><br><span class="line">    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform a series of erosions and dilations</span></span><br><span class="line">    closed = cv2.erode(closed, <span class="literal">None</span>, iterations = <span class="number">4</span>)</span><br><span class="line">    closed = cv2.dilate(closed, <span class="literal">None</span>, iterations = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the contours in the thresholded image, then sort the contours</span></span><br><span class="line">    <span class="comment"># by their area, keeping only the largest one</span></span><br><span class="line">    <span class="comment"># ValueError: too many values to unpack (expected 2)</span></span><br><span class="line">    (img,cnts, _) = cv2.findContours(closed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    c = <span class="built_in">sorted</span>(cnts, key = cv2.contourArea, reverse = <span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># compute the rotated bounding box of the largest contour</span></span><br><span class="line">    rect = cv2.minAreaRect(c)</span><br><span class="line">    <span class="comment"># 原文这里使用cv2.cv.BoxPoints，新版本已经移除，换为cv2.boxPoints</span></span><br><span class="line">    box = np.int0(cv2.boxPoints(rect))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># draw a bounding box around the detected barcode</span></span><br><span class="line">    <span class="comment"># and display the image</span></span><br><span class="line">    cv2.drawContours(image, [box], -<span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv2.imshow(image_name, image)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done...\n##################################&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="imgs-pro-py">imgs_pro.py</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Mon Dec 26 23:22:01 2016</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Administrator</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> bar_code <span class="keyword">import</span> detect</span><br><span class="line"><span class="comment"># 切换到测试图片文件夹</span></span><br><span class="line">os.chdir(<span class="string">&#x27;test-imgs&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到所有的测试图片文件名</span></span><br><span class="line">image_names = os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> image_name <span class="keyword">in</span> image_names:</span><br><span class="line">        detect(image_name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="test-imgs文件夹">test-imgs文件夹</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/1.png" alt=""></p>
<h5 id="运行结果">运行结果</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/3.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/4.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/5.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/CV/6.png" alt=""></p>
<p>开始按照原来的程序识别效果不怎么好，自己调整了几个参数，效果还可以，但是可以看到还是有的识别不出。接下来我们会用OpenCV官方给出的<a href="http://datahonor.com/2017/03/02/OpenCV%E8%AF%86%E5%88%AB%E6%9D%A1%E5%BD%A2%E7%A0%81%E2%80%94%E2%80%94python%E5%AE%9E%E7%8E%B0-CPP%E8%A1%A5%E5%85%85/#more">Cpp</a>的例子来纠正这个问题。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Opencv3学习笔记--制作简易视频播放器</title>
    <url>/2017/04/03/Opencv%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<p><em>Learning Opencv3</em>上面的的一个代码，第一次看的时候基本没看懂，这次大概看懂了。这里先贴上代码，再来简单解释下代码流程。</p>
<h5 id="代码-2">代码</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_slider_position = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> g_run = <span class="number">1</span>, g_dontset = <span class="number">0</span>;</span><br><span class="line">cv::VideoCapture g_cap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onTrackbarSlide</span><span class="params">(<span class="type">int</span> pos, <span class="type">void</span>*)</span></span>&#123;</span><br><span class="line">    g_cap.<span class="built_in">set</span>(cv::CAP_PROP_POS_FRAMES, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!g_dontset)</span><br><span class="line">        g_run = <span class="number">1</span>;</span><br><span class="line">    g_dontset = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Example&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line">    g_cap.<span class="built_in">open</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/sampvideo.ogv&quot;</span>);</span><br><span class="line">    <span class="type">int</span> frames = (<span class="type">int</span>) g_cap.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_COUNT);</span><br><span class="line">    <span class="type">int</span> tmpw = (<span class="type">int</span>) g_cap.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_WIDTH);</span><br><span class="line">    <span class="type">int</span> tmph = (<span class="type">int</span>) g_cap.<span class="built_in">get</span>(cv::CAP_PROP_FRAME_HEIGHT);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Video has &quot;</span>&lt;&lt;frames&lt;&lt;<span class="string">&quot; frames of dimensions(&quot;</span>&lt;&lt;tmpw&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;tmph&lt;&lt;<span class="string">&quot;).&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">createTrackbar</span>(<span class="string">&quot;Position&quot;</span>,	<span class="string">&quot;Example&quot;</span>,	&amp;g_slider_position,	frames,</span><br><span class="line">                       onTrackbarSlide);</span><br><span class="line"></span><br><span class="line">    cv::Mat frame;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g_run != <span class="number">0</span>)&#123;</span><br><span class="line">            g_cap&gt;&gt;frame; <span class="keyword">if</span>(frame.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> current_pos = (<span class="type">int</span>) g_cap.<span class="built_in">get</span>(cv::CAP_PROP_POS_FRAMES);</span><br><span class="line"></span><br><span class="line">            g_dontset = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">setTrackbarPos</span>(<span class="string">&quot;Position&quot;</span>, <span class="string">&quot;Example&quot;</span>, current_pos);</span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">&quot;Example&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line">            g_run -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> c = (<span class="type">char</span>) <span class="built_in">cvWaitKey</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;s&#x27;</span>) <span class="comment">// single step</span></span><br><span class="line">            &#123;g_run =<span class="number">1</span>; cout&lt;&lt;<span class="string">&quot;single step, run = &quot;</span>&lt;&lt;g_run&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;r&#x27;</span>)  <span class="comment">// run mode</span></span><br><span class="line">            &#123;g_run = <span class="number">-1</span>; cout&lt;&lt;<span class="string">&quot;Run mode, run = &quot;</span>&lt;&lt;g_run&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="简单解释">简单解释</h5>
<p>重要参数解释：</p>
<blockquote>
<p>g_slider_position，进度条位置</p>
<p>g_run，控制视频播放模式，为正数[如5]时，表示距离视频暂停还有几个[这里是5个]frame将输出到屏幕，这里g_run为正数大都是1，故为step即但不模式； 当为负数时，将一直播放下去，因为g_run -=1的存在使得g_run一直为负。</p>
<p>g_dontest,为了鼠标点击进度条的动作而设计的参数。使得点击进度条后，自动进入step模式。</p>
<p>createTrackbar( TrackbarName, “Linear Blend”, &amp;alpha_slider, alpha_slider_max, on_trackbar );Whenever the user moves the Trackbar, the callback function on_trackbar is called</p>
</blockquote>
<p>运行流程：</p>
<blockquote>
<p>开始时g_slider_position为0,在main函数中输出到frame，后show，这个过程中，g_dontset被设置为1，使得在不进行<em>点击以移动进度条</em>动作时，进度条不会被重置到新的指定的位置,且g_dontset将一直被从0重置为1.此时，如果在cvWaitKey的10ms[图片显示时间]，按下‘s’则，按照前面参数说明，在播放一帧之后，视频将暂停；按下’r’，则g_run将由-1递减下去，一直为负，视频一直进行下去。若是此时点击移动进度条，则在g_dontset = 1之前[这时g_dontset=0]调用回调函数onTrackbarSlide，使得g_cap的位置被指定为当前帧的位置，接着g_run = 1， 进入单步模式，接着将show当前帧的画面和他的下一帧画面后进入暂停模式。</p>
</blockquote>
<p>个人理解，错误之处请指正。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Orange3使用</title>
    <url>/2017/08/20/Orange3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Overview-42">Overview</h4>
<p>之前了解到Anaconda的Navigator，感觉挺酷的一个东西…并未去研究，今天恰好又看到，就玩了玩Orange, 感觉还挺好用的一个工具，操作比较简单，可视化效果也不错。不过跟着<a href="https://www.youtube.com/watch?v=Iu8g2Twjn9U&amp;list=PLmNPvQr9Tf-ZSDLwOzxpvY-HrE0yv-8Fy&amp;index=14">官方教程</a>测试的时候数据集用的都比较小，可能数据集比较大的时候会有些慢。这里记录下使用的时候遇到的几个问题。</p>
<h4 id="Problems-Solutions">Problems&amp;Solutions</h4>
<h5 id="数据集的下载">数据集的下载</h5>
<p>在ADD-ON装上Bioinformatics的时候有的数据集因为网络原因会无法下载。用之前在SS全局代理中提到的proxychains可以解决。</p>
<p>在终端启动Navigator的时候加上proxychains即可：</p>
<blockquote>
<p>proxychains anaconda-navigator</p>
</blockquote>
<h5 id="Image-Analytics-安装">Image Analytics 安装</h5>
<p>在ADD-ON添加Image Analytics的时候会报错：</p>
<blockquote>
<p>_NamespacePath’ object has no attribute ‘sort’</p>
</blockquote>
<p>查看了下当时的安装命令为：</p>
<blockquote>
<p>python -m pip install Orange3-ImageAnalytics</p>
</blockquote>
<p>查了下是setuptools的问题，于是</p>
<blockquote>
<p>sudo apt-get install python3-setuptools</p>
</blockquote>
<p>之后直接从把Orange3-ImageAnalytics-0.1.7下载下来手动安装的（下载安装包README 有详细的安装步骤的介绍）：</p>
<blockquote>
<p>python <a href="http://setup.py">setup.py</a> install</p>
</blockquote>
<p>然后重启Orange就可以了。</p>
<p>ps:这里再次尝试从ADD-ON安装应该也可以。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Orange3</tag>
      </tags>
  </entry>
  <entry>
    <title>P value or Effect size</title>
    <url>/2021/02/03/P-value-or-Effect-size/</url>
    <content><![CDATA[<h1>Overview</h1>
<p>起因是看到<a href="https://mp.weixin.qq.com/s/uuBVGb6ElrdwO3dtX4ySvA">业务显著性与统计显著性</a>这篇文章，发现看完之后除了加深了下统计显著容易让人陷入认知误区的印象之外，更多的是一堆问号。文中提及的Effect size和Probability of Superiority这些概念之前没有了解过，当我想通过具体的例子了解一下时，我发现例子比概念本身更加难以理解…</p>
<blockquote>
<p>“以下面的虚拟实验为例。我们想研究做作业对学习效率的影响。这个实验对150个学生进行了AB随机分组，75个学生要求做作业，而另外75个学生不做作业，在一个月后用一个包含20道题的标准化考试来衡量效果，预期得分提升一个点。最后的结果是不做作业的那一组平均得分15.6分，而做作业的组，平均得分17.3，提高了1.7分。统计检验在97.5%的显著性要求下通过。如果分析就到此为止也没有什么问题，但是优秀的分析师会对平均提高1.7分进行进一步的解读。比如，在这个实验中，结合样本的均方差，组间差异平均提高1.7分意味着两组有88%的重合，或者说实验组随机挑选一个学生，这个学生有58.4%的概率比对照组随机挑选的一个学生的得分要高（称之为probability of  superiority）。此外，如果想要在实验组中获得比对照组多一个学生的成绩更好，我们平均需要让10.6个学生做作业，换句话说，如果有100个学生都严格执行了做作业的学习过程，相比他们不做作业的学习过程，平均来说有9.4个学生会得到更好的考试结果。这样的解读会让主管或者业务方更好地理解实验的应用意义。”</p>
</blockquote>
<p>个人而言，相比从例子本身去理解什么，先理解这个实验本身或者说理解这个实验的详细流程更为重要。换句话说，这个实验是<strong>描述</strong>了实验本身(也没有很详细)，同时给出了大致的分析方向。但是，很显然具体实验的<strong>过程</strong>才是更加重要的。这种分析方式有无限制或者<strong>前提假设</strong>？88%,58.4%,10.6, 9.4<strong>如何计算</strong>出来的？抛弃这些真正实用的操作过程和理论支撑，那么这个例子对实践的指导意义又能有多少呢？如果说是为了尽可能摆脱繁杂的背景知识来提供某种insight, 那后面扯上“并行”，“异步”又是为哪般呢…</p>
<p>另外，本文论述大多参考<a href="https://rpsychologist.com/cohend/">Interpreting Cohen’s <em>d</em> Effect Size: An Interactive Visualization</a>, 如果这篇文章可以解答疑惑，下面的论述也就没有必要了。</p>
<p><img src="https://i.loli.net/2021/02/03/EfxYWtzJV3aP1ow.png" alt="cohen"></p>
<h1>Definitions</h1>
<h2 id="Effect-size">Effect size</h2>
<p>首先看下Wikipedia对Effect size的定义：</p>
<blockquote>
<p>In statistics, an <strong>effect size</strong> is a number measuring the strength of the relationship between two  variables in a statistical population, or a sample-based estimate of  that quantity…Examples of effect sizes include … mean difference.</p>
</blockquote>
<p>论文<em>Using Effect Size—or Why the P Value Is Not Enough</em>也给出了Effect size的定义：</p>
<blockquote>
<p>In medical education research studies that compare different educational interventions, <strong>effect size</strong> is the<br>
magnitude of the difference between groups.</p>
</blockquote>
<p>简言之，Effect size可以用来衡量不同group之间的差异性。同是论文给出了Effect size的两种形式：</p>
<blockquote>
<p>Thus, effect size can refer to the <strong>raw difference</strong> between group means, or absolute effect size, as well as <strong>standardized measures</strong> of effect, which are calculated to transform the effect to an easily understood scale.</p>
</blockquote>
<p>也就是Effect size存在两种形式，一种是在原有量纲下直接做差得到的结果，一种是标准化之后的结果。我们下面将要论述的Cohen’s d就是属于后者。另外值得一提的是，Logistic Regression中经常提到的Odds ratio也属于Effect size Indices的一种。</p>
<h2 id="Cohen’s-d">Cohen’s d</h2>
<p>参考<a href="https://en.wikiversity.org/wiki/Cohen's_d">Wikiversity</a>中对Cohen’s d的定义：</p>
<blockquote>
<p><strong>Cohen’s d</strong> is an <a href="https://en.wikiversity.org/wiki/Effect_size">effect size</a> used to indicate the standardised difference between two means.</p>
</blockquote>
<p>上述定义固然清晰简洁，但是不够具体，<a href="https://en.wikipedia.org/wiki/Effect_size#Cohen's_d">Wikipedia</a>给出了具体的计算方式：<br>
$$<br>
d = \frac{\bar{x}_1 - \bar{x}_2}{s}<br>
$$</p>
<p>$$<br>
s = \sqrt{\frac{(n_1-1)s_{1}^{2} + (n_2-1)s_{2}^{2}}{n_1 + n_2 - 2}}<br>
$$</p>
<p>$$<br>
s_{1}^{2} = \frac{1}{n_1-1}\sum_{i=1}^{n_1}(x_{1, i}-\bar{x}_1)^2<br>
$$</p>
<p>此外，在Cohen, J. (1977). <em>Statistical power analysis for the behavioral sciencies</em>. Routledge.章节2.2 THE EFFECT SIZE INDEX: d中给出了具体的计算例子。</p>
<h1>How</h1>
<p>下面我们先不加解释地给出如何计算得到上面所说的那几个数字。因为原文对实验的描述并不全面，也就是不知道两组学生分数的标准差，所以我们很难模拟出来原始的例子…但是因为所有的计算几乎全部依赖于<code>Cohen's d</code>，所以通过尝试不同的值(:-), 发现只要让<code>Cohen's d=0.3</code>就可以得到相同的结果.</p>
<p>也就是说，当我们有真实的数据时，我们可以根据Definition中对Cohen’s d的定义计算出对应的值,记为$\delta$，之后的分析和各种数据指标的计算全部是基于这个值的。因为现在我们没有数据，所以只能以这个倒推出来的值$\delta=0.3$为起点展开后续的计算。</p>
<p>下面我将不加过多阐述地给出各个指标的计算流程，具体分析与推导见后续What。</p>
<p><strong>Overlap: overlapping coefficient (OVL):</strong><br>
$$<br>
OVL = 2 \Phi(-|\delta|/2) = 2\Phi(-0.15) = 2 \times 0.4403823 = 0.8807646 \approx 88%<br>
$$<br>
也就是上面例子中重叠占比88%的由来。注意这里$\Phi$为标准正态分布的累积密度函数(CDF), 这里的$\Phi(-0.15)$在R语言用<code>pnorm(-0.15)即可算得</code>.</p>
<p><strong>Probability of superiority: common language effect size (CL)</strong>:<br>
$$<br>
CL = \Phi(\frac{\delta}{\sqrt2}) = \Phi(0.3/\sqrt2) = 0.583998 \approx 58.4%<br>
$$<br>
也就是上面例子中58.4%的由来。</p>
<p><strong>Number Needed to Treat(NNT)</strong>:<br>
$$<br>
NNT = \frac{1}{\Phi(\delta + \Psi(CER))- CER} = \frac{1}{\Phi(0.3 + \Psi(0.2))- 0.2} = 10.6338<br>
$$<br>
关于这里的CER参考附录CER&amp;EER&amp;NNT. 这里$\Psi$函数为$\Phi$的反函数，在R中为<code>qnorm</code>. 上述计算就是10.6的由来。也就是说，那个例子的计算中是默认了CER为0.2的…</p>
<p><strong>TODO</strong>: 至于例子中这个9.4, 我直观感觉应该是$100 \times \frac{1}{10.6}=9.433962$，但是有点绕不过来Orz</p>
<p><strong>Cohen’s $U_3$</strong>:<br>
$$<br>
U_3 = \Phi(\delta) = \Phi(0.3) = 0.6179114 \approx 61.8%<br>
$$</p>
<p>在Cohen, J. (1977). <em>Statistical power analysis for the behavioral sciencies</em>. Routledge.中，定义了$U_1, U_2, U_3$，分别用来衡量不重叠性(“measures of nonoverlap”).这里的例子没有涉及，但也是很有用的概念。</p>
<h1>What</h1>
<p>在写这块的时候发现自己很难把问题讲清楚，所以就拜托Tomorrow学长写了这一部分<a href="https://yuanhang0.github.io/posts/effect-size">Two-Sample Test and Cohen’s d</a>, 文中给出了上述公式的详细推导.另外舍友也讨论了这个问题，他也从另一个角度定义并计算了上述问题，并检查了以上论述。感谢两位:-)</p>
<h1>And…</h1>
<h2 id="Where-is-the-P-value">Where is the P value?</h2>
<p>本文题目是<em>P value of Effect size</em>, 然而并未对P value作出更多的论述，主要是因为论文<em>Using Effect Size—or Why the P Value Is Not Enough</em>已经对两者作出了相当充分的讨论，无需赘述。此外关于P value的争论(P value culture)已经存在很久了，但是学校好像几乎没怎么提及…如<em>Ranstam, Jonas. “Why the P-value culture is bad and confidence intervals a better alternative.”</em>。P value本身并没有问题：“我就是个小小的P value, 我能有什么坏心思呢？”错的是我们不能正确地认识它。</p>
<h2 id="Probability-of-superiority-or-AUC…">Probability of superiority or AUC…</h2>
<p>之前写过一篇<a href="https://datahonor.com/2020/05/02/ROC-AUC/">ROC-AUC</a>详细介绍了ROC和AUC相关的东西：WHEN, WHERE, WHO, WHY, HOW. 主要是点出来AUC与非参数统计中Wilcoxon-Mann-Whitney statistic的关联。而这里的所说的Probability of superiority其实就是AUC，核心就是对“配对比较”的理解，“配对”无非就是做一个笛卡尔积。</p>
<p>（另外一提，在ROC-AUC这篇文章中介绍的计算AUC的最快的方法，是WXG 的算法岗面试题）</p>
<h2 id="当我们谈论直观时我们在谈论什么">当我们谈论<strong>直观</strong>时我们在谈论什么</h2>
<p>文章最开始给出的那段话，无非是为了让人了解到所谓进一步做分析的必要性。但是仅仅给出一堆莫名奇妙的数字，而且不给原理，不给出处，不能实验，又何谈应用到业务中去呢。即使在被各种“直观”，“可视化”解释包围的今天，我们也不能忘记那些看似抽象的定义才是根本…</p>
<h1>附录:CER&amp;EER&amp;NNT</h1>
<p>参考<a href="http://www.bandolier.org.uk/booth/glossary/event.html">bandolier</a>:</p>
<blockquote>
<p>Event rate: The proportion of patients in a group in whom the event is observed.   Thus, if out of 100 patients, the event is observed in 27, the event  rate is 0.27 or 27%.  <strong>Control event rate (CER)</strong> and <strong>experimental event  rate (EER)</strong> are used to refer to this in control and experimental groups  of patients respectively. An <a href="http://www.bandolier.org.uk/booth/glossary/outputs.html">example</a> might help.</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Treatment</strong></th>
<th style="text-align:center">总人数</th>
<th style="text-align:center">疼痛减少50%以上的人数</th>
<th style="text-align:center">疼痛没有减少50%以上的人</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>布洛芬400 mg</strong></td>
<td style="text-align:center"><strong>40</strong></td>
<td style="text-align:center"><strong>22</strong></td>
<td style="text-align:center"><strong>18</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>安慰剂</strong></td>
<td style="text-align:center"><strong>40</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>33</strong></td>
</tr>
</tbody>
</table>
<p><strong>Experimental event rate</strong> (EER, event rate with ibuprofen): <strong>22/40 = 0.55 or 55%</strong></p>
<p><strong>Control event rate</strong>(CER, event rate with placebo): <strong>7/40 = 0.18 or 18%</strong></p>
<p><strong>Absolute risk increase or reduction</strong> (EER-CER): <strong>0.55 - 0.18 = 0.37 or 37%</strong></p>
<p><strong>NNT</strong> (1/(EER-CER)):<strong>1/(0.55 - 0.18) = 2.7</strong></p>
<p>显然，这里的Event也就是我们关注的地方是“<strong>疼痛减少50%以上</strong>”</p>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Pedestrian Detection</title>
    <url>/2017/08/17/Pedestrain-Detection/</url>
    <content><![CDATA[<h4 id="Overview-43">Overview</h4>
<p>使用OpenCV自带的API进行行人检测。</p>
<h4 id="Code-37">Code</h4>
<p>参考<a href="https://github.com/shenxiangzhuang/opencv-samples">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgcodecs.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/ml.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_VIDEO_FILE <span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/MyCV/data/terrace1-c0.avi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDOW_NAME <span class="string">&quot;WINDOW&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reference: https://github.com/Itseez/opencv/blob/master/samples/cpp/train_HOG.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_locations</span><span class="params">(Mat &amp;img, <span class="type">const</span> vector&lt;Rect&gt; &amp;locations, <span class="type">const</span> Scalar &amp;color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!locations.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;Rect&gt;::const_iterator loc = locations.<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;Rect&gt;::const_iterator end = locations.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">for</span> (; loc != end; ++loc) &#123;</span><br><span class="line">            <span class="built_in">rectangle</span>(img, *loc, color, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    Mat mSrc;</span><br><span class="line">    vector&lt;Rect&gt; vDetected;</span><br><span class="line">    HOGDescriptor hog;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> vector&lt;<span class="type">float</span>&gt; detector = HOGDescriptor::<span class="built_in">getDefaultPeopleDetector</span>();</span><br><span class="line">    hog.<span class="built_in">setSVMDetector</span>(detector);</span><br><span class="line"></span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(INPUT_VIDEO_FILE)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        cap &gt;&gt; mSrc;</span><br><span class="line">        hog.<span class="built_in">detectMultiScale</span>(mSrc, vDetected, <span class="number">0</span>, <span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>), <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">32</span>), <span class="number">1.05</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">draw_locations</span>(mSrc, vDetected, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(WINDOW_NAME, mSrc);</span><br><span class="line">        <span class="comment">// 加上ESC退出</span></span><br><span class="line">        <span class="type">char</span> c = <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出效果：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/WINDOW_081702.png" alt=""></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/WINDOW_081703.png" alt=""></p>
<p>总体感觉还是不错的。视频下载<a href="http://cvlab.epfl.ch/data/pom">地址</a>.</p>
<h4 id="。。。">。。。</h4>
<p>话说当初学OpenCV的初衷就是检测行人来着，想着检测食堂和学校主干道的行人，并进行计数，最好能搞出来实时人流量的图（天真orz…）…现在学了一年了，几乎没什么进展，而且发现所要做的或许是属于人群检测，而非简单的行人检测…</p>
<p>总的来说学的都是基本的图像处理操作和原理，用到的机器学习算法也就是K-means, KNN, SVM这些，至于深度学习，神经网络这些还没有去研究，一是想着先打好基础，二来。。。我这I5的小本子也撑不住…</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Print time!</title>
    <url>/2017/02/26/Print-time/</url>
    <content><![CDATA[<h5 id="Introduction">Introduction</h5>
<p>关于Cpp知识点的结合练习。</p>
<h5 id="Overview-44">Overview</h5>
<p>本次练习涉及的知识点</p>
<blockquote>
<p>vector的几种打印方式<br>
将函数作为参数传入其他函数<br>
精确[毫秒及微秒]时间的计量</p>
</blockquote>
<h5 id="Code-38">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 几种打印vector的方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="comment">//        cout&lt;&lt; i;</span></span><br><span class="line">        cout &lt;&lt; v[i]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> itr = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>( itr != v.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; *(itr++) &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pf)</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确时间的计量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">taketime</span><span class="params">(pf f, vector&lt;<span class="type">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> start, end;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> mtime, seconds, useconds;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time: %ld milliseconds\n&quot;</span>, mtime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">        <span class="built_in">f</span>(v);</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    seconds  = end.tv_sec  - start.tv_sec;</span><br><span class="line">    useconds = end.tv_usec - start.tv_usec;</span><br><span class="line"></span><br><span class="line">    mtime = ((seconds) * <span class="number">1000</span> + useconds/<span class="number">1000.0</span>) + <span class="number">0.5</span>;</span><br><span class="line">    cout &lt;&lt;endl&lt;&lt; mtime;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; daysInMonth = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">taketime</span>(printvector1, daysInMonth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Refrence-2">Refrence</h5>
<p><em>Data Structures and AlgorithmAnalysis in C++</em>[p84]</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability and Mathematical Statistics[Books]</title>
    <url>/2018/12/24/Probability-and-Mathematical-Statistics-Books/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="写在前面">写在前面</h3>
<p>因为自己在学习什么知识的时候总喜欢找别人推荐一些书，因为一本好书真的是一个好的开始。这里简单写下这两三年看过的概率论和数理统计的书，也有后面计划看的，一般都是比较经典的教材。</p>
<h3 id="已看">已看</h3>
<h4 id="《概率论基础》，复旦大学，李贤平，第三版">《概率论基础》，复旦大学，李贤平，第三版</h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E6%9D%8E%E8%B4%A4%E5%B9%B3.jpg" width = "300" height = "300"/></center>
<p>这是我们大二上学期时候的教材，也就是说学完高数线代看这本一般是没问题的。而且感觉这本书能把比较复杂的东西讲的比较简单，很适合入门学习。当时只是做了一部分习题，感觉还可以，值得做一下。刚才在搜的时候看到已经有对应的习题解答的书一起卖了，可以一起看。因为一定量的习题对学习新的东西有很大帮助。</p>
<h4 id="《概率论与数理统计》，浙大四版">《概率论与数理统计》，浙大四版</h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E6%B5%99%E5%A4%A7.jpg" width = "300" height = "300"/></center>
<p>这本是在备考概率论（那时只看了概率部分）的时候看的，内容比较少，也比较简单。配合着习题解析，做了大部分的习题，感觉一般吧，题目没什么新意。后面学数理统计的时候翻着看了下，内容一般。总之这本就是挺基础的，可以随便看看…</p>
<h4 id="《数理统计讲义》，复旦大学，郑明">《数理统计讲义》，复旦大学，郑明</h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E9%83%91%E6%98%8E.jpg" width = "300" height = "300"/></center>
<p>大二下数理统计的教材，其实本来老师选的另一本，后来教务好像搞错了，就成了这本…这书比较适合数学基础好些的看，因为我们学的是微积分B，所以当时看这本会及其不适应。书里面的推到几乎是看不懂的，习题几乎没做。上课和练习一般都是跟着老师的PPT走。</p>
<p>不过呢，到了大四开始的时候（那时候已经看了下面将要介绍的一堆书）再看这本已经无压力了，然后突然发现这书真的很赞！很简洁，而且例子也比较有启发性（这些例子和下面的Hogg和casella有些是重复的）。对UMVUE的讲解也是比较深入的，感觉这个很难得。因为这本书的习题没有答案，所以习题后面只是随便看看。不过，就题目本身而言，质量还是很好的。</p>
<h4 id="《数理统计》，厦门大学，程细玉">《数理统计》，厦门大学，程细玉</h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E7%A8%8B%E7%BB%86%E7%8E%89.jpg" width = "300" height = "300"/></center>
<p>这个好像是大二下（或者大三…）看的，图书馆看到封面很漂亮就拿来看了Orz…不过这本书写的真的很不错的，对基本原理讲解的比较透彻，很有启发性，把里面的例子推导一遍帮助很大。没事翻一翻，大概两三个月看完了，习题没有做，不知道具体如何。</p>
<h4 id="《概率论与数理统计教程》，茆诗松，第二版">《概率论与数理统计教程》，茆诗松，第二版</h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E8%8C%86%E8%AF%97%E6%9D%BE.jpg" width = "300" height = "300"/></center>
<p>大三下开始看的（好像是，模糊了…），一位同学推荐的，因为当时学随机过程发现概率论有些忘记了，所以就拿来看了。书确实是很好的，从基础开始讲，条理很清晰，内容（概率论部分）相对李贤平也更丰富一些。数理统计部分在当时看来几乎是讲的最好的了，很细致，很全面。概率论部分的习题（有配套的习题解答书）是全部做了的，而且做了笔记。后面数理统计的习题做了大部分，感觉提升了很多。另外，在习题解答的书上有额外的附加习题，难度在书上中上难度差不多，也是不错的。总之，这书很值得一看，习题最后也全做。</p>
<h4 id="Elementary-Probability-Theory，Kai-Lai-Chung"><em>Elementary Probability Theory，Kai Lai Chung</em></h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E9%92%9F%E5%88%9D%E7%AD%89.jpg" width = "300" height = "300"/></center>
<p>大三时候偶然看到的，就买来看了下，当时感觉比较这书讲的比较好玩…具体内容都和之前看的书没有太大差别，角度上有些不同，可能还没有看透吧，后面再读一下。毕竟概率学界学术教父的书…</p>
<blockquote>
<p>PS：记得很清楚这书有一个很有趣的例子——如何计算明天太阳升起的概率，亮瞎眼233</p>
</blockquote>
<h4 id="Introduction-to-Mathematical-Statistics-Hogg"><em>Introduction to Mathematical Statistics, Hogg</em></h4>
<center>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/Hogg.jpg" width = "300" height = "300"/></center>
<p>大四看的这本，感觉错过了五百万…因为我觉着这本书是我看过的数理统计的书里面（本科阶段）写的最好的了，越早看越好。Hogg这本书把sufficient statistics和complete statistics讲的简直出神入化，给人很大的震撼！后面对一些问题的分析也是之前没有见过的思路，比如对C-R下界的推导，完全是不同于别的任何书，而且过程很简洁。还有后面对LRT的介绍，也很有启发性，真的学到很多。大概一两个星期就看完了，因为时间比较紧张就没有做习题，不过大致看了下，习题的质量应该也是很好的，而且有答案。总之，很推荐看这本。</p>
<h4 id="Statistical-Inference-Casella"><em>Statistical Inference, Casella</em></h4>
<center><img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/casella.jpg" width = "300" height = "300"/></center>
<p>和Casella的恩怨情仇是一个很长的故事，从大二到现在…怎么说呢，这本书无论在广度上还是在深度上都是令人折服的。从概率论出发，一直到后面的点估计，假设检验，区间估计这些，几乎每一章都能刷新认知（真正看已经大四了，还是学到很多）。可以看得出里面每一个例题，甚至每一道课后都是精心布置的，真正帮助理解相关的概念。有些学校是把这本当作研究生教材的，不过本科看也完全可以（有些严格的数学推导可以略过）。这本书的格局是很大的，作者在前言说了，之所以写书的一个原因就是对现在的书不满意…举个例子，Casella对区间估计的定义如下：</p>
<blockquote>
<p><strong>Definition9.1.1</strong><br>
An <em>intervel estimate</em> of a real-valued parameter $\theta$ is any pair of functions, $L(x_{1}, \cdots, x_{n})$ and $U(x_{1}, \cdots, x_{n})$, of a sample that satisfy $L(\mathbf{x}) \le U(\mathbf{x})$ for all $\mathbf{x} \in \mathbf{\chi}$. If $\mathbf{\chi} = \mathbf{x}$ is observed, the inference $L(\mathbf{x}) \le \theta \le U(\mathbf{x})$ is made. The random intervel $[L(\mathbf{X},U(\mathbf{X}]$ is called an <em>intervel estimate</em>.</p>
</blockquote>
<p>如果你拿这个定义去和国内的一些书（比如上面那些）去比较就会发现，其他书都是直接给出<strong>置信区间</strong>的概念，而不是<strong>区间估计</strong>的概念，也即这些书很容易一开始就“诱使”读者一想到区间估计，接着就想到置信水平为$1-\alpha$的置信区间，或者看到根据正态分布和T分布导出的置信区间形式进一步局限自己的思维。这里Casella很不同的一点就是他把估计过程和对估计的评价过程分离——我们几乎可以任意估计，比如对但参数总体，我不管样本如何，就总是把置信区间取成全体实数也是可以的（因为这就是一个区间估计），只不过它的意义不大罢了。也即分离开“是什么”和“怎么样”的问题，这是不容混淆的。</p>
<p>这本书的课后题目有些就是根据稍微早些的论文改编，难度不是特别大，而且大多有详细的答案。有些题目没有解析解会给出数值解，也有的需要模拟的题目会给出R的代码！总之这本书有太多惊艳的地方，可以读很多遍。</p>
<h3 id="待看">待看</h3>
<h4 id="概率论及数理统计，-中山大学，邓集贤"><em>概率论及数理统计， 中山大学，邓集贤</em></h4>
<center><img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/%E4%B8%AD%E5%A4%A7%E9%82%93.jpg" width = "300" height = "300"/></center>
<p>简单看了下，感觉这书写的也还行，主要后面有随机过程的介绍，后面看下再更。</p>
<h4 id="An-Introduction-to-Probability-and-Statistical-Inference-Second-Edition，George-G-Roussas">An Introduction to Probability and Statistical Inference Second Edition，George G. Roussas</h4>
<center><img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/Roussas.jpg" width = "300" height = "300"/></center>
<p>没记错的话这应该是清华的本科教材，之前看过几十页，目测不逊色于Casella。最关键的是这书比较新（虽然新旧并不太要紧…），15年出的，Casella比较早了。</p>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Statistics</tag>
        <tag>Probability</tag>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title>PySpark安装使用</title>
    <url>/2020/02/02/PySpark%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概览-6">概览</h2>
<p>这里不直接安装原生的Spark，因为目前没必要，所以仅仅记录下PySpark的安装和使用过程中遇到的坑。</p>
<h2 id="安装-4">安装</h2>
<p>在Spark的官方的<a href="https://spark.apache.org/downloads.html">安装界面</a>就提到了PySpark的安装方式就是直接运行<code>pip install pyspark</code>。这当然是可以的，但是我们一般不直接这样做，主要是因为Anaconda的依赖问题。在默认的Base环境中混用<code>pip install</code>和<code>conda install</code>很容易把环境搞坏掉，使得后面根本没法升级。</p>
<p>所以养成好的习惯，一般不要去动Base, 需要配置为xx而用的Python环境就搞一个虚拟环境出来，这样就很容易管理。</p>
<p>这里我们就用conda建立一个Python3.7的名字为<code>pyspark</code>的环境<code>conda create --name pyspark python=3.7</code>.之后激活此环境<code>conda activate pyspark</code>。此时直接在终端输入<code>pyspark</code>即可。</p>
<blockquote>
<p>注意，我在运行的时候遇到一个小问题，就是此时打开的之前安装的Spark版本2.3.0，而不是最新的2.4.4.查了下主要问题在一个环境变量<code>SPARK_HOME</code>，我之前指定到了那个2.3.0的版本(通过<code>env | grep spark</code>发现)。我们在<code>/etc/profile</code>将其注释掉之后重启电脑即可。此时激活虚拟环境后，运行<code>pyspark</code>会直接进入<code>pip</code>安装的新的版本。</p>
</blockquote>
<h2 id="默认启动IPython">默认启动IPython</h2>
<p>上面运行<code>pyspark</code>会直接运行python，而我想让他进入IPython，显然后者更为方便一些。修改步骤如下，首先<code>which pyspark</code>定位spark的位置，发现在<code>/home/shensir/anaconda3/envs/pyspark/bin/pyspark</code>之后直接执行<code>gedit /home/shensir/anaconda3/envs/pyspark/bin/pyspark</code>对其进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYSPARK_DRIVER_PYTHON</span><br><span class="line">export PYSPARK_DRIVER_PYTHON_OPTS</span><br></pre></td></tr></table></figure>
<p>定位到上面两行，为第一行的环境变量指定为<code>ipython</code>即可，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYSPARK_DRIVER_PYTHON=&#x27;ipython&#x27;</span><br><span class="line">export PYSPARK_DRIVER_PYTHON_OPTS</span><br></pre></td></tr></table></figure>
<p>之后再次运行<code>pyspark</code>就会直接进入IPython.</p>
<h2 id="连接MySQL数据库">连接MySQL数据库</h2>
<p>在看一个<a href="https://www.osgeo.cn/learnspark/rdd.html">教程</a>的时候，尝试了从MySQL数据库创建RDD，但是报错<code>[java.lang.ClassNotFoundException: com.mysql.jdbc.Driver](https://www.cnblogs.com/spicy/p/9754123.html)</code>,后参考[<a href="https://stackoverflow.com/questions/49011012/cant-connect-to-mysql-database-from-pyspark-getting-jdbc-error">Cant connect to Mysql database from pyspark, getting jdbc error</a>发现是少了驱动文件，看了下数据库是8.0.17版本，所以在<a href="https://downloads.mysql.com/archives/c-j/">MySQL Connector/J (Archived Versions)</a>选择8.0.17和Platform Independent下载<code>mysql-connector-java-8.0.17.tar.gz</code>文件，之后解压，找到<code>mysql-connector-java-8.0.17.jar</code>文件，将其复制到<code>/home/shensir/anaconda3/envs/pyspark/lib/python3.7/site-packages/pyspark/jars</code>文件夹下，重启终端继续即可。</p>
<p>下面贴一下PySpark连接MySQL数据的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"></span><br><span class="line">spark = SparkSession \</span><br><span class="line">	.builder \</span><br><span class="line">    	.appName(<span class="string">&#x27;Python Spark creates RDD&#x27;</span>) \</span><br><span class="line">        .config(<span class="string">&#x27;Spark.some.config.option&#x27;</span>, <span class="string">&#x27;some-value&#x27;</span>) \</span><br><span class="line">        .getOrCreate()</span><br><span class="line"></span><br><span class="line">df = spark.read.<span class="built_in">format</span>(<span class="string">&quot;jdbc&quot;</span>).options(</span><br><span class="line">	url=<span class="string">&quot;jdbc:mysql://localhost:3306/数据库名&quot;</span>,</span><br><span class="line">	driver=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>,</span><br><span class="line">	dbtable = <span class="string">&quot;表名&quot;</span>,</span><br><span class="line">	user=<span class="string">&quot;用户名&quot;</span>,</span><br><span class="line">	password=<span class="string">&quot;密码&quot;</span>).load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.show())</span><br></pre></td></tr></table></figure>
<h2 id="从HDFS读取文件">从HDFS读取文件</h2>
<p>首先要保证服务开启<code>start-dfs.sh</code>，可以<code>jps</code>查看各个节点是否启动成功。同时使用<code>hdfs dfs -ls -R</code>查看已经加入HDFS的文件。我们也可以用命令<code>hdfs dfs -moveFromLocal data/WineData.csv /user/shensir</code>来将本地文件添加到HDFS，之后再次通过<code>hdfs dfs -ls -R</code>查看是否添加成功。</p>
<blockquote>
<p>注，开启服务后我们也可以在浏览器查看HDFS文件目录，我这里是在<code>http://localhost:9870/explorer.html#/user/shensir</code>查看，但是注意在代码中读取的位置依旧是用9000端口。</p>
</blockquote>
<p>之后可以在PySpark中读取:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.context <span class="keyword">import</span> SparkContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> HiveContext</span><br><span class="line"></span><br><span class="line">sc = SparkContext(<span class="string">&#x27;local&#x27;</span>,<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">hc = HiveContext(sc)</span><br><span class="line">data = sc.textFile(<span class="string">&quot;hdfs://localhost:9000/user/shensir/WineData.csv&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data.first())</span><br><span class="line"></span><br><span class="line"><span class="comment"># RDD-&gt;DataFrame</span></span><br><span class="line">header = data.first()</span><br><span class="line">df = data \</span><br><span class="line">    .<span class="built_in">filter</span>(<span class="keyword">lambda</span> row: row != header) \</span><br><span class="line">    .<span class="built_in">map</span>(<span class="keyword">lambda</span> row: [<span class="built_in">float</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> row.split(<span class="string">&#x27;,&#x27;</span>)]) \</span><br><span class="line">    .toDF(header.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(df.show(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>PySpark</tag>
      </tags>
  </entry>
  <entry>
    <title>Python与数据分析</title>
    <url>/2018/03/22/Python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post1.png" alt="爬虫"></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post2.png" alt="操作电子表格"></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post3.png" alt="数据分析"></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post4.png" alt="生活"></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post5.png" alt="生活"></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/post6.png" alt="生活"></p>
<h3 id="关于本文">关于本文</h3>
<p><a href="http://www.broadview.com.cn/book/5010">《Python数据分析入门——从数据获取到可视化》</a>，</p>
<p>本文包括内容简介，写作目的以及目标读者等内容。其实这些内容在前言都有写到，但是为了让大家在入手之前能对本书有个更加详细的了解，这里还是多说几句。</p>
<h3 id="内容简介">内容简介</h3>
<p>全书分为五章，分别是配置集成开发环境和几个重要语法的介绍，数据的获取，数据的存取与清洗，数据的分析及可视化和最后的Python在不同领域的应用。总的来说是一个概览性的结构，力图展示数据分析每个阶段的过程。下面展开浏览下下全书的篇章结构。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/chap1.png" alt=""></p>
<p>在最开始就是介绍了集成开发环境的配置和几个比较重要的Python用法，作为之后继续学习的准备。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/chap2.png" alt=""></p>
<p>第二章首先是简单介绍了网络爬虫的基本原理，之后通过一个小例子来加深对整个流程的理解。在进阶的部分，针对爬取数据时经常遇到的编码问题，模拟登录等问题分别展开叙述。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/chap3.png" alt=""></p>
<p>第三章主要就是数据的存取与简单的清洗，包括对常见的CSV,JSON等文件的存取。同时介绍了数据科学中两个极其重要的第三方库的使用，也就是Numpy和Pandas。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/chap4.png" alt=""></p>
<p>本章是很有趣的一部分，主要是了解机器学习和进行数据可视化。考虑再三还是将手写KNN的部分加了进去，因为它本身并不难，而且可以加深对算法本身的认识并提高应用Python来解决问题的能力，希望大家能从中受益。</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201803/chap5.png" alt=""></p>
<p>最后的这一章介绍了几个相对复杂点的小项目，而且在这些项目中综合了之前几个章节的内容，希望以此来进一步地锻炼大家应用Python解决实际问题的能力。同时这些问题本身都是比较有意思的，可以让我们切实体会到Python简洁强大的魅力。</p>
<h3 id="写作目的">写作目的</h3>
<p>本书的篇幅算是比较短的，目的是想让读者能相对快速地对数据分析的流程有一个比较全面的认识，而不必在每一个部分都占用太多时间。就像在入住数据分析这个世界前先“观光游览”一遍，对将要融入的世界有个全面的认识。这样，在了解全貌之后，可以让大家更方便地找到自己感兴趣的部分，并在之后有针对性地进行更加深入的学习。</p>
<p>同时，本文将网络爬虫放在前面，一来是因为它确实是获取数据的利器；二来就是因为学习爬虫的反馈周期比较短，而且过程比较有趣，读者可以进行较多的练习，这样也可以提高大家使用Python的熟练度。</p>
<p>从篇章结构也可以看到很明显的一点，虽然是按照数据分析的流程来的，但是每一章的联系不是很多。在阅读时，有些内容看不懂可以暂时跳过，并不会对后面有太大的影响。</p>
<h3 id="目标读者">目标读者</h3>
<p>本书是入门数据分析的书，力图做到简单明了。所以读者只需要对Python的基础语法有个大致的了解，能写一些几十行的小程序就可以很好地阅读本书。书中会用到的较为复杂的语法在第一章也都会进行简单的讲解，而且后面用的也不会太多，所以大可不必担心。</p>
<p>在学习Python时遇到很多的朋友，他们几乎来自各个专业：计算机科学，统计学，数学，自动化，甚至心理学，经济学，新闻传播学等等。在说明Python已经渗透到各个领域的同时，也说明Python强大和易学的特点。所以大家不论是什么专业和工作，只要对数据科学感兴趣都可以尝试学习下Python，之后通过本书来了解数据分析，因为从数据中挖掘信息本身就是一件很有趣的事情~</p>
<h3 id="致谢">致谢</h3>
<p>本书现在能够和大家见面，首先要感谢的就是博文视点（电子工业出版社）的支持。感谢石倩，杨嘉媛两位编辑老师给予的帮助。谢满锐老师对本书多次细心的审校也纠正了我的很多错误。也非常开心能够在学习过程中结识刘松学长和其他朋友，从大家身上学习到很多。另外，本书每章的最后都会列出参考文献，都是一些很好的书籍，可以作为大家深入学习的参考书。</p>
<h3 id="共勉">共勉</h3>
<p>最后，希望本书的内容可以对大家的学习和工作有所帮助。希望通过本书，与大家一起学习，进步。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python分析QQ群聊天记录</title>
    <url>/2017/03/02/Python%E5%88%86%E6%9E%90QQ%E7%BE%A4%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h5 id="Overview-45">Overview</h5>
<p>之前，写了<a href="http://www.cnblogs.com/buzhizhitong/p/5701299.html">这篇文章</a>，用python提取全部群成员的发言时间，并简单做了下分析。先补充一下，针对特定单个群成员（这里以  小小白   为例）消息记录的获取。代码比较简单，主要是正则表达式的书写。（附：聊天文件记录的导出请参考上面提到的文章）</p>
<h5 id="Code-39">Code</h5>
<p>这里有两个版本的，前面的比较简单，后面的一个实现了自动化提取做图。</p>
<h6 id="Version1-0">Version1.0</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2016/9/14</span></span><br><span class="line"><span class="comment">#从QQ聊天数据导出特定人发言的日期时间和发言内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小小白   这里代指你要获取数据的对象的昵称</span></span><br><span class="line"><span class="comment"># 方便起见，见数据导出的文件名也明明为此</span></span><br><span class="line">workbook = xlsxwriter.Workbook(<span class="string">&#x27;小小白.xlsx&#x27;</span>)</span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line">worksheet.set_column(<span class="string">&#x27;A:A&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">worksheet.set_column(<span class="string">&#x27;B:B&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">worksheet.set_column(<span class="string">&#x27;C:C&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;高等数学.txt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line">    <span class="comment"># 正则，跨行匹配</span></span><br><span class="line">    pa = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;) (\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;) 小小白\(小小白的QQ号\)\n(.*?)\n$&#x27;</span>,re.DOTALL+re.MULTILINE)</span><br><span class="line">    ma = re.findall(pa,s)</span><br><span class="line">    <span class="comment"># print(len(ma))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ma)):</span><br><span class="line">        <span class="comment"># print(ma[i][0])</span></span><br><span class="line">        date = ma[i][<span class="number">0</span>]</span><br><span class="line">        time = ma[i][<span class="number">1</span>]</span><br><span class="line">        word = ma[i][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        worksheet.write(<span class="built_in">int</span>(i),<span class="number">0</span>,date)</span><br><span class="line">        worksheet.write(<span class="built_in">int</span>(i),<span class="number">1</span>,time)</span><br><span class="line">        worksheet.write(<span class="built_in">int</span>(i),<span class="number">2</span>,word)</span><br><span class="line"></span><br><span class="line">    workbook.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;处理完毕，快去看看文件夹下面新建的.xlsx文件吧&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="Version2-0">Version2.0</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决matplotlib显示中文的问题</span></span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;Microsoft YaHei&quot;</span>]</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取24个时间段-----&gt;periods</span></span><br><span class="line"><span class="comment"># 用于之后时间的分段</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_periods</span>():</span><br><span class="line">    periods = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">24</span>):</span><br><span class="line">        <span class="comment"># 这里的判断用于将类似的‘8’ 转化为 ‘08’ 便于和导出数据匹配</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">            i = <span class="string">&#x27;0&#x27;</span>+<span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="built_in">str</span>(i)</span><br><span class="line">        periods.append(i)</span><br><span class="line">    <span class="keyword">return</span> periods</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">对QQ群而言的时间提取</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 获取聊天文件的“小时”数据</span></span><br><span class="line"><span class="string">def get_times(filename):</span></span><br><span class="line"><span class="string">    with open(filename, encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line"><span class="string">        data = f.read()</span></span><br><span class="line"><span class="string">        # 例如20:50:52，要匹配其中的20</span></span><br><span class="line"><span class="string">        pa = re.compile(r&quot;(\d\d):\d\d:\d\d&quot;)</span></span><br><span class="line"><span class="string">        times = re.findall(pa, data)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return times</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个时间段进行计数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classification</span>(<span class="params">times,period</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">        <span class="keyword">if</span> time == period:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">    period_time.append([period,num])</span><br><span class="line">    <span class="comment"># print(period, &#x27;---&gt;&#x27;, num)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_time</span>(<span class="params">period_time,name</span>):</span><br><span class="line">    time = []</span><br><span class="line">    num  = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> period_time:</span><br><span class="line">        time.append(i[<span class="number">0</span>])</span><br><span class="line">        num.append(i[<span class="number">1</span>])</span><br><span class="line">    time = time[<span class="number">6</span>:<span class="number">24</span>]+time[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">    num = num[<span class="number">6</span>:<span class="number">24</span>]+num[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">    <span class="comment"># print(time,&#x27;\n&#x27;,num)</span></span><br><span class="line">    labels = time</span><br><span class="line">    x = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">24</span>)]</span><br><span class="line">    plt.plot(num, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    num_max = <span class="built_in">max</span>(num)</span><br><span class="line">    plt.xticks(x,labels)</span><br><span class="line">    plt.axis([<span class="number">00</span>, <span class="number">24</span>, <span class="number">0</span>, num_max*(<span class="number">1.2</span>)])</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.title(name)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;发言量&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;时间&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_person_data</span>(<span class="params">filename,name,qqnumber</span>):</span><br><span class="line">    person_data = &#123;<span class="string">&#x27;date&#x27;</span>:[],<span class="string">&#x27;time&#x27;</span>:[],<span class="string">&#x27;word&#x27;</span>:[]&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = f.read()</span><br><span class="line">        <span class="comment"># 正则，跨行匹配</span></span><br><span class="line">        pa = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;) (\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;) &#x27;</span>+name+<span class="string">r&#x27;\(&#x27;</span>+qqnumber+<span class="string">&#x27;\)\n(.*?)\n$&#x27;</span>,re.DOTALL+re.MULTILINE)</span><br><span class="line">        ma = re.findall(pa,s)</span><br><span class="line">        <span class="comment"># print(len(ma))</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ma)):</span><br><span class="line">            <span class="comment"># print(ma[i][0])</span></span><br><span class="line">            date = ma[i][<span class="number">0</span>]</span><br><span class="line">            time = ma[i][<span class="number">1</span>]</span><br><span class="line">            word = ma[i][<span class="number">2</span>]</span><br><span class="line">            person_data[<span class="string">&#x27;date&#x27;</span>].append(date)</span><br><span class="line">            person_data[<span class="string">&#x27;time&#x27;</span>].append(time[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">            person_data[<span class="string">&#x27;word&#x27;</span>].append(word)</span><br><span class="line">    <span class="keyword">return</span> person_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    filename = <span class="built_in">input</span>(<span class="string">&#x27;请输入聊天记录文件名：&#x27;</span>)</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;准备提取个人信息就绪，请输入要提取人的群名片：&#x27;</span>)</span><br><span class="line">    qqnumber = <span class="built_in">input</span>(<span class="string">&#x27;请输入要提取人的QQ号：&#x27;</span>)</span><br><span class="line">    period_time = []</span><br><span class="line">    person_data = get_person_data(filename,name,qqnumber)</span><br><span class="line">    times = person_data[<span class="string">&#x27;time&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    periods = get_periods()</span><br><span class="line">    <span class="keyword">for</span> period <span class="keyword">in</span> periods:</span><br><span class="line">        classification(times,period)</span><br><span class="line">    plot_time(period_time,name)</span><br><span class="line">    <span class="comment"># print(person_data[&#x27;word&#x27;])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://images2015.cnblogs.com/blog/980075/201610/980075-20161018105033451-390495188.png" alt=""></p>
<h5 id="Supplement-4">Supplement</h5>
<blockquote>
<p>关于Windows下，matplotlib中文显示的问题，参考我之前的<a href="http://www.cnblogs.com/buzhizhitong/p/5759304.html">这篇文章</a>。<br>
至于Ubuntu下，还未去处理，之后有时间补充。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现支持向量机(SVM)</title>
    <url>/2017/03/02/Python%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM/</url>
    <content><![CDATA[<p>之前学SVM做的笔记，这里整理下。</p>
<h5 id="Theory-3">Theory</h5>
<p>这里先空下，等之后整理补充上来。</p>
<h5 id="Code-40">Code</h5>
<p>代码大部分来自<a href="https://gist.github.com/mblondel/586753">Github</a>，当中有自己写的一些注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> cvxopt</span><br><span class="line"><span class="keyword">import</span> cvxopt.solvers</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_kernel</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(x1, x2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_kernel</span>(<span class="params">x, y, p=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + np.dot(x, y)) ** p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_kernel</span>(<span class="params">x, y, sigma=<span class="number">5.0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(-linalg.norm(x-y)**<span class="number">2</span> / (<span class="number">2</span> * (sigma ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel=linear_kernel, C=<span class="literal">None</span></span>):</span><br><span class="line">        self.kernel = kernel</span><br><span class="line">        self.C = C</span><br><span class="line">        <span class="keyword">if</span> self.C <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: self.C = <span class="built_in">float</span>(self.C)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        n_samples, n_features = X.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Gram matrix</span></span><br><span class="line">        K = np.zeros((n_samples, n_samples))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_samples):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_samples):</span><br><span class="line">                K[i,j] = self.kernel(X[i], X[j])</span><br><span class="line"></span><br><span class="line">        P = cvxopt.matrix(np.outer(y,y) * K)</span><br><span class="line">        q = cvxopt.matrix(np.ones(n_samples) * -<span class="number">1</span>)</span><br><span class="line">        A = cvxopt.matrix(y, (<span class="number">1</span>,n_samples))</span><br><span class="line">        b = cvxopt.matrix(<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.C <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            G = cvxopt.matrix(np.diag(np.ones(n_samples) * -<span class="number">1</span>))</span><br><span class="line">            h = cvxopt.matrix(np.zeros(n_samples))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp1 = np.diag(np.ones(n_samples) * -<span class="number">1</span>)</span><br><span class="line">            tmp2 = np.identity(n_samples)</span><br><span class="line">            G = cvxopt.matrix(np.vstack((tmp1, tmp2)))</span><br><span class="line">            tmp1 = np.zeros(n_samples)</span><br><span class="line">            tmp2 = np.ones(n_samples) * self.C</span><br><span class="line">            h = cvxopt.matrix(np.hstack((tmp1, tmp2)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># solve QP problem</span></span><br><span class="line">        solution = cvxopt.solvers.qp(P, q, G, h, A, b)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Lagrange multipliers</span></span><br><span class="line">        a = np.ravel(solution[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Support vectors have non zero lagrange multipliers</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这里a&gt;1e-5就将其视为非零</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        sv = a &gt; <span class="number">1e-5</span></span><br><span class="line">        ind = np.arange(<span class="built_in">len</span>(a))[sv]</span><br><span class="line">        self.a = a[sv]</span><br><span class="line">        self.sv = X[sv]</span><br><span class="line">        self.sv_y = y[sv]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d support vectors out of %d points&quot;</span> % (<span class="built_in">len</span>(self.a), n_samples))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Intercept</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        这里相当于对所有的支持向量求得的b取平均值</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.a)):</span><br><span class="line">            self.b += self.sv_y[n]</span><br><span class="line">            self.b -= np.<span class="built_in">sum</span>(self.a * self.sv_y * K[ind[n],sv])</span><br><span class="line">        self.b /= <span class="built_in">len</span>(self.a)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Weight vector</span></span><br><span class="line">        <span class="keyword">if</span> self.kernel == linear_kernel:</span><br><span class="line">            self.w = np.zeros(n_features)</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.a)):</span><br><span class="line">                <span class="comment"># linear_kernel相当于在原空间，故计算w不用映射到feature space</span></span><br><span class="line">                self.w += self.a[n] * self.sv_y[n] * self.sv[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.w = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">project</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># w有值，即kernel function 是 linear_kernel，直接计算即可</span></span><br><span class="line">        <span class="keyword">if</span> self.w <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> np.dot(X, self.w) + self.b</span><br><span class="line">        <span class="comment"># w is None --&gt; 不是linear_kernel,w要重新计算</span></span><br><span class="line">        <span class="comment"># 这里没有去计算新的w（非线性情况不用计算w）,直接用kernel matrix计算预测结果</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y_predict = np.zeros(<span class="built_in">len</span>(X))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X)):</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> a, sv_y, sv <span class="keyword">in</span> <span class="built_in">zip</span>(self.a, self.sv_y, self.sv):</span><br><span class="line">                    s += a * sv_y * self.kernel(X[i], sv)</span><br><span class="line">                y_predict[i] = s</span><br><span class="line">            <span class="keyword">return</span> y_predict + self.b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> np.sign(self.project(X))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_lin_separable_data</span>():</span><br><span class="line">        <span class="comment"># generate training data in the 2-d case</span></span><br><span class="line">        mean1 = np.array([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">        mean2 = np.array([<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">        cov = np.array([[<span class="number">0.8</span>, <span class="number">0.6</span>], [<span class="number">0.6</span>, <span class="number">0.8</span>]])</span><br><span class="line">        X1 = np.random.multivariate_normal(mean1, cov, <span class="number">100</span>)</span><br><span class="line">        y1 = np.ones(<span class="built_in">len</span>(X1))</span><br><span class="line">        X2 = np.random.multivariate_normal(mean2, cov, <span class="number">100</span>)</span><br><span class="line">        y2 = np.ones(<span class="built_in">len</span>(X2)) * -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> X1, y1, X2, y2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_non_lin_separable_data</span>():</span><br><span class="line">        mean1 = [-<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        mean2 = [<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        mean3 = [<span class="number">4</span>, -<span class="number">4</span>]</span><br><span class="line">        mean4 = [-<span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">        cov = [[<span class="number">1.0</span>,<span class="number">0.8</span>], [<span class="number">0.8</span>, <span class="number">1.0</span>]]</span><br><span class="line">        X1 = np.random.multivariate_normal(mean1, cov, <span class="number">50</span>)</span><br><span class="line">        X1 = np.vstack((X1, np.random.multivariate_normal(mean3, cov, <span class="number">50</span>)))</span><br><span class="line">        y1 = np.ones(<span class="built_in">len</span>(X1))</span><br><span class="line">        X2 = np.random.multivariate_normal(mean2, cov, <span class="number">50</span>)</span><br><span class="line">        X2 = np.vstack((X2, np.random.multivariate_normal(mean4, cov, <span class="number">50</span>)))</span><br><span class="line">        y2 = np.ones(<span class="built_in">len</span>(X2)) * -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> X1, y1, X2, y2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_lin_separable_overlap_data</span>():</span><br><span class="line">        <span class="comment"># generate training data in the 2-d case</span></span><br><span class="line">        mean1 = np.array([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">        mean2 = np.array([<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">        cov = np.array([[<span class="number">1.5</span>, <span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">1.5</span>]])</span><br><span class="line">        X1 = np.random.multivariate_normal(mean1, cov, <span class="number">100</span>)</span><br><span class="line">        y1 = np.ones(<span class="built_in">len</span>(X1))</span><br><span class="line">        X2 = np.random.multivariate_normal(mean2, cov, <span class="number">100</span>)</span><br><span class="line">        y2 = np.ones(<span class="built_in">len</span>(X2)) * -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> X1, y1, X2, y2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_train</span>(<span class="params">X1, y1, X2, y2</span>):</span><br><span class="line">        X1_train = X1[:<span class="number">90</span>]</span><br><span class="line">        y1_train = y1[:<span class="number">90</span>]</span><br><span class="line">        X2_train = X2[:<span class="number">90</span>]</span><br><span class="line">        y2_train = y2[:<span class="number">90</span>]</span><br><span class="line">        X_train = np.vstack((X1_train, X2_train))</span><br><span class="line">        y_train = np.hstack((y1_train, y2_train))</span><br><span class="line">        <span class="keyword">return</span> X_train, y_train</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">split_test</span>(<span class="params">X1, y1, X2, y2</span>):</span><br><span class="line">        X1_test = X1[<span class="number">90</span>:]</span><br><span class="line">        y1_test = y1[<span class="number">90</span>:]</span><br><span class="line">        X2_test = X2[<span class="number">90</span>:]</span><br><span class="line">        y2_test = y2[<span class="number">90</span>:]</span><br><span class="line">        X_test = np.vstack((X1_test, X2_test))</span><br><span class="line">        y_test = np.hstack((y1_test, y2_test))</span><br><span class="line">        <span class="keyword">return</span> X_test, y_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅仅在Linears使用此函数作图，即w存在时</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plot_margin</span>(<span class="params">X1_train, X2_train, clf</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, w, b, c=<span class="number">0</span></span>):</span><br><span class="line">            <span class="comment"># given x, return y such that [x,y] in on the line</span></span><br><span class="line">            <span class="comment"># w.x + b = c</span></span><br><span class="line">            <span class="keyword">return</span> (-w[<span class="number">0</span>] * x - b + c) / w[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        pl.plot(X1_train[:,<span class="number">0</span>], X1_train[:,<span class="number">1</span>], <span class="string">&quot;ro&quot;</span>)</span><br><span class="line">        pl.plot(X2_train[:,<span class="number">0</span>], X2_train[:,<span class="number">1</span>], <span class="string">&quot;bo&quot;</span>)</span><br><span class="line">        pl.scatter(clf.sv[:,<span class="number">0</span>], clf.sv[:,<span class="number">1</span>], s=<span class="number">100</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># w.x + b = 0</span></span><br><span class="line">        a0 = -<span class="number">4</span>; a1 = f(a0, clf.w, clf.b)</span><br><span class="line">        b0 = <span class="number">4</span>; b1 = f(b0, clf.w, clf.b)</span><br><span class="line">        pl.plot([a0,b0], [a1,b1], <span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># w.x + b = 1</span></span><br><span class="line">        a0 = -<span class="number">4</span>; a1 = f(a0, clf.w, clf.b, <span class="number">1</span>)</span><br><span class="line">        b0 = <span class="number">4</span>; b1 = f(b0, clf.w, clf.b, <span class="number">1</span>)</span><br><span class="line">        pl.plot([a0,b0], [a1,b1], <span class="string">&quot;k--&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># w.x + b = -1</span></span><br><span class="line">        a0 = -<span class="number">4</span>; a1 = f(a0, clf.w, clf.b, -<span class="number">1</span>)</span><br><span class="line">        b0 = <span class="number">4</span>; b1 = f(b0, clf.w, clf.b, -<span class="number">1</span>)</span><br><span class="line">        pl.plot([a0,b0], [a1,b1], <span class="string">&quot;k--&quot;</span>)</span><br><span class="line"></span><br><span class="line">        pl.axis(<span class="string">&quot;tight&quot;</span>)</span><br><span class="line">        pl.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plot_contour</span>(<span class="params">X1_train, X2_train, clf</span>):</span><br><span class="line">        <span class="comment"># 作training sample数据点的图</span></span><br><span class="line">        pl.plot(X1_train[:,<span class="number">0</span>], X1_train[:,<span class="number">1</span>], <span class="string">&quot;ro&quot;</span>)</span><br><span class="line">        pl.plot(X2_train[:,<span class="number">0</span>], X2_train[:,<span class="number">1</span>], <span class="string">&quot;bo&quot;</span>)</span><br><span class="line">        <span class="comment"># 做support vectors 的图</span></span><br><span class="line">        pl.scatter(clf.sv[:,<span class="number">0</span>], clf.sv[:,<span class="number">1</span>], s=<span class="number">100</span>, c=<span class="string">&quot;g&quot;</span>)</span><br><span class="line"></span><br><span class="line">        X1, X2 = np.meshgrid(np.linspace(-<span class="number">6</span>,<span class="number">6</span>,<span class="number">50</span>), np.linspace(-<span class="number">6</span>,<span class="number">6</span>,<span class="number">50</span>))</span><br><span class="line">        X = np.array([[x1, x2] <span class="keyword">for</span> x1, x2 <span class="keyword">in</span> <span class="built_in">zip</span>(np.ravel(X1), np.ravel(X2))])</span><br><span class="line">        Z = clf.project(X).reshape(X1.shape)</span><br><span class="line">        <span class="comment"># pl.contour做等值线图</span></span><br><span class="line">        pl.contour(X1, X2, Z, [<span class="number">0.0</span>], colors=<span class="string">&#x27;k&#x27;</span>, linewidths=<span class="number">1</span>, origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">        pl.contour(X1, X2, Z + <span class="number">1</span>, [<span class="number">0.0</span>], colors=<span class="string">&#x27;grey&#x27;</span>, linewidths=<span class="number">1</span>, origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">        pl.contour(X1, X2, Z - <span class="number">1</span>, [<span class="number">0.0</span>], colors=<span class="string">&#x27;grey&#x27;</span>, linewidths=<span class="number">1</span>, origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        pl.axis(<span class="string">&quot;tight&quot;</span>)</span><br><span class="line">        pl.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_linear</span>():</span><br><span class="line">        X1, y1, X2, y2 = gen_lin_separable_data()</span><br><span class="line">        X_train, y_train = split_train(X1, y1, X2, y2)</span><br><span class="line">        X_test, y_test = split_test(X1, y1, X2, y2)</span><br><span class="line"></span><br><span class="line">        clf = SVM()</span><br><span class="line">        clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">        y_predict = clf.predict(X_test)</span><br><span class="line">        correct = np.<span class="built_in">sum</span>(y_predict == y_test)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d out of %d predictions correct&quot;</span> % (correct, <span class="built_in">len</span>(y_predict)))</span><br><span class="line"></span><br><span class="line">        plot_margin(X_train[y_train==<span class="number">1</span>], X_train[y_train==-<span class="number">1</span>], clf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_non_linear</span>():</span><br><span class="line">        X1, y1, X2, y2 = gen_non_lin_separable_data()</span><br><span class="line">        X_train, y_train = split_train(X1, y1, X2, y2)</span><br><span class="line">        X_test, y_test = split_test(X1, y1, X2, y2)</span><br><span class="line"></span><br><span class="line">        clf = SVM(gaussian_kernel)</span><br><span class="line">        clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">        y_predict = clf.predict(X_test)</span><br><span class="line">        correct = np.<span class="built_in">sum</span>(y_predict == y_test)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d out of %d predictions correct&quot;</span> % (correct, <span class="built_in">len</span>(y_predict)))</span><br><span class="line"></span><br><span class="line">        plot_contour(X_train[y_train==<span class="number">1</span>], X_train[y_train==-<span class="number">1</span>], clf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_soft</span>():</span><br><span class="line">        X1, y1, X2, y2 = gen_lin_separable_overlap_data()</span><br><span class="line">        X_train, y_train = split_train(X1, y1, X2, y2)</span><br><span class="line">        X_test, y_test = split_test(X1, y1, X2, y2)</span><br><span class="line"></span><br><span class="line">        clf = SVM(C=<span class="number">0.1</span>)</span><br><span class="line">        clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">        y_predict = clf.predict(X_test)</span><br><span class="line">        correct = np.<span class="built_in">sum</span>(y_predict == y_test)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d out of %d predictions correct&quot;</span> % (correct, <span class="built_in">len</span>(y_predict)))</span><br><span class="line"></span><br><span class="line">        plot_contour(X_train[y_train==<span class="number">1</span>], X_train[y_train==-<span class="number">1</span>], clf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_soft()</span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/f2.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Screenshot%20from%202017-03-02%2008-40-03.png" alt=""></p>
<h5 id="Supplement-5">Supplement</h5>
<p>关于用cvxopt求解QP问题的使用，可参考<a href="https://uqer.io/community/share/55c9a55df9f06c91f818c675">优矿</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python抓取微信文章</title>
    <url>/2017/04/04/Python%E6%8A%93%E5%8F%96%E5%BE%AE%E4%BF%A1%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h5 id="概览-7">概览</h5>
<p>涉及selenium获取cookie并用于模拟登录[这方法很强大！]<br>
通过<a href="http://www.gsdata.cn/">清博指数</a>，抓取海大夜洞表白信…<br>
数据存取及简单可视化…</p>
<h5 id="实现代码">实现代码</h5>
<h6 id="Get-lovelinks-py">Get_lovelinks.py</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">selenium模拟登录清博指数后获取表白信列表页，</span></span><br><span class="line"><span class="string">并在列表页提取表白信文章标题及链接，存入csv文件</span></span><br><span class="line"><span class="string">[注意这里不登录获取不到全部的列表页，而登录涉及cookie加密，并未深入研究，直接用selenium获取cookie]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># selenium获取cookie, 并写入文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cookie_from_network</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Get data from selenium...&quot;</span>)</span><br><span class="line">    <span class="comment"># 使用selenium</span></span><br><span class="line">    dcap = <span class="built_in">dict</span>(DesiredCapabilities.PHANTOMJS)</span><br><span class="line">    dcap[<span class="string">&quot;phantomjs.page.settings.userAgent&quot;</span>] = (</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0&quot;</span>)</span><br><span class="line">    driver = webdriver.PhantomJS(<span class="string">&#x27;/home/shensir/phantomjs-2.1.1-linux-x86_64/bin/phantomjs&#x27;</span>,</span><br><span class="line">                                 desired_capabilities=dcap)</span><br><span class="line">    driver.maximize_window()</span><br><span class="line"></span><br><span class="line">    login_url = <span class="string">&#x27;http://www.gsdata.cn/member/login&#x27;</span></span><br><span class="line">    driver.get(url=login_url)</span><br><span class="line">    data = driver.page_source</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div/form/div/p[1]/input&#x27;</span>).send_keys(<span class="string">&#x27;登录手机号码&#x27;</span>)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div/form/div/p[2]/input&#x27;</span>).send_keys(<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">&#x27;/html/body/div[2]/div/form/div/p[4]/input&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">    cookie_list = driver.get_cookies()</span><br><span class="line">    <span class="comment"># print(cookie_list)</span></span><br><span class="line">    cookie_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_list:</span><br><span class="line">        <span class="comment">#写入文件</span></span><br><span class="line">        f = <span class="built_in">open</span>(cookie[<span class="string">&#x27;name&#x27;</span>]+<span class="string">&#x27;.qingbo&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        pickle.dump(cookie, f)</span><br><span class="line">        f.close()</span><br><span class="line">        cookie_dict[cookie[<span class="string">&#x27;name&#x27;</span>]] = cookie[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件获取cookie</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cookie_from_cache</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Get cookie from cache files...&quot;</span>)</span><br><span class="line">    cookie_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> parent, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">&#x27;./&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.qingbo&#x27;</span>):</span><br><span class="line">                <span class="comment"># print(filename)</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    d = pickle.load(f)</span><br><span class="line">                    cookie_dict[d[<span class="string">&#x27;name&#x27;</span>]] = d[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cookie final</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cookie</span>():</span><br><span class="line">    cookie_dict = get_cookie_from_cache()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cookie_dict:</span><br><span class="line">        cookie_dict = get_cookie_from_network()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从单个文章列表页获取表白信url</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_love_urls</span>(<span class="params">url</span>):</span><br><span class="line"></span><br><span class="line">    cookdic = get_cookie()</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0&#x27;</span>&#125;</span><br><span class="line">    timeout = <span class="number">5</span></span><br><span class="line">    r = requests.get(url, headers=headers, cookies=cookdic, timeout=timeout)</span><br><span class="line">    soup = bs(r.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(soup)</span></span><br><span class="line">    articles = soup.find(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;article-ul&#x27;</span>&#125;).find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(len(articles))</span></span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">        title = article.find(<span class="string">&#x27;h4&#x27;</span>).get_text()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;表白&quot;</span> <span class="keyword">in</span> title:</span><br><span class="line">            love_url = article.find(<span class="string">&#x27;h4&#x27;</span>).find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(title, love_url)</span><br><span class="line">            love_titles.append(title)</span><br><span class="line">            love_urls.append(<span class="built_in">str</span>(love_url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># urls为所有文章列表列</span></span><br><span class="line">    urls = [<span class="string">&#x27;http://www.gsdata.cn/query/article?q=hndxyd&amp;search_field=4&amp;post_time=0&amp;sort=-1&amp;read_num=0&#x27;</span> \</span><br><span class="line">            <span class="string">&#x27;&amp;page=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line">    love_titles = []</span><br><span class="line">    love_urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        time.sleep(<span class="number">3</span>)   <span class="comment"># 这里建议sleep大约2-3s， 不然网页会因为访问频繁刷出验证码</span></span><br><span class="line">        get_love_urls(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将表白新url数据存到文件</span></span><br><span class="line">    love_links_file = pd.DataFrame()</span><br><span class="line">    love_links_file[<span class="string">&#x27;titles&#x27;</span>] = love_titles</span><br><span class="line">    love_links_file[<span class="string">&#x27;urls&#x27;</span>] = love_urls</span><br><span class="line">    love_links_file.to_csv(<span class="string">&#x27;love_links.csv&#x27;</span>, index=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="Get-lovedatas-py">Get_lovedatas.py</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">通过之前获取的表白信文章标题及链接文件，爬取表白信详细信息，存入json文件</span></span><br><span class="line"><span class="string">此处不需要登录~</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2016.4.02 -- 2016.6.17 是旧的版式</span></span><br><span class="line"><span class="string">2016.6.21 -- 2017.4.03 是新的版式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于旧版内容较少，这里我们暂时只抓新版内容；</span></span><br><span class="line"><span class="string">以后有时间再补充旧版的抓取。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">文章有些已经被删除，注意设置容错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">尝试使用xpath, 其实不会用，，，这里完全是找规律，欢迎大家提出改进意见</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入表白信标题链接数据[这里转化为字典是为了方便操作，当然，之前再保存时存为json格式会更方便]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_links_data</span>():</span><br><span class="line">    links_data = &#123;&#125;</span><br><span class="line">    data = pd.read_csv(<span class="string">&#x27;love_links.csv&#x27;</span>)</span><br><span class="line">    titles = <span class="built_in">list</span>(data[<span class="string">&#x27;titles&#x27;</span>])</span><br><span class="line">    links = <span class="built_in">list</span>(data[<span class="string">&#x27;urls&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(titles)):</span><br><span class="line">        links_data[titles[i]] = links[i]</span><br><span class="line">    <span class="keyword">return</span> links_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从标题（注意是之前获取的列表页的标题）获取信件数目，用于下面的xpath路径的书写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_num_from_title</span>(<span class="params">title</span>):</span><br><span class="line">    num = re.findall(<span class="string">&#x27;.*?\|(\d+)封&#x27;</span>, title)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># print(num)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_date_from_title</span>(<span class="params">title</span>):</span><br><span class="line">    date = re.findall(<span class="string">&#x27;\\n(.*?)表白&#x27;</span>, title)</span><br><span class="line">    date = <span class="built_in">list</span>(date)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(date)</span><br><span class="line">    <span class="keyword">return</span> date</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">title, url</span>):</span><br><span class="line">    page_data = &#123;&#125;</span><br><span class="line">    page_data[<span class="string">&#x27;title&#x27;</span>] = title</span><br><span class="line">    page_data[<span class="string">&#x27;url&#x27;</span>] = url</span><br><span class="line">    page_data[<span class="string">&#x27;envos&#x27;</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    num = get_num_from_title(title)</span><br><span class="line">    data = requests.get(url)</span><br><span class="line">    selector = etree.HTML(data.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表白信标题</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    不会用xpath, try...and we can find some rules from different part</span></span><br><span class="line"><span class="string">    And we know that the &#x27;/text()&#x27; is to get the text </span></span><br><span class="line"><span class="string">    # /html/body/div/div[2]/div[1]/div[1]/div[2]/section[1]/section[1]/section/section/section[1]/section/section/p/span</span></span><br><span class="line"><span class="string">    # /html/body/div/div[2]/div[1]/div[1]/div[2]/section[2]/section[1]/section/section/section[1]/section/section/p/span</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    envo_titles = []</span><br><span class="line">    envo_title_paths = [<span class="string">&#x27;/html/body/div/div[2]/div[1]/div[1]/div[2]/section[&#123;&#125;]/section[1]/section/section/section[1]/section/section/p/span/text()&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num)]</span><br><span class="line">    <span class="keyword">for</span> envo_title_path <span class="keyword">in</span> envo_title_paths:</span><br><span class="line">        envo_title = selector.xpath(envo_title_path)</span><br><span class="line">        envo_titles.append(<span class="built_in">list</span>(envo_title)[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># print(envo_title)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表白信内容</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # /html/body/div/div[2]/div[1]/div[1]/div[2]/section[1]/section[1]/section/section/section[1]/section/section/section/p[2]/span</span></span><br><span class="line"><span class="string">    # /html/body/div/div[2]/div[1]/div[1]/div[2]/section[2]/section[1]/section/section/section[1]/section/section/section/p[2]/span</span></span><br><span class="line"><span class="string">    # /html/body/div/div[2]/div[1]/div[1]/div[2]/section[3]/section[1]/section/section/section[1]/section/section/section/p[2]/span</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    envo_conts = []</span><br><span class="line">    envo_cont_paths = [<span class="string">&#x27;/html/body/div/div[2]/div[1]/div[1]/div[2]/section[&#123;&#125;]/section[1]/section/section/section[1]/section/section/section/p[2]/span/text()&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num)]</span><br><span class="line">    <span class="keyword">for</span> envo_cont_path <span class="keyword">in</span> envo_cont_paths:</span><br><span class="line">        envo_cont = selector.xpath(envo_cont_path)</span><br><span class="line">        envo_cont = <span class="built_in">list</span>(envo_cont)[<span class="number">0</span>]</span><br><span class="line">        envo_conts.append(envo_cont)</span><br><span class="line">        <span class="comment"># print(envo_cont)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(envo_titles)):</span><br><span class="line">        page_data[<span class="string">&#x27;envos&#x27;</span>][envo_titles[i]] = envo_conts[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    links_data = load_links_data()</span><br><span class="line">    links_title = <span class="built_in">list</span>(links_data.keys())</span><br><span class="line">    links_url = <span class="built_in">list</span>(links_data.values())</span><br><span class="line">    all_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> link_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(links_data)):</span><br><span class="line">        title = links_title[link_num]</span><br><span class="line">        url = links_url[link_num]</span><br><span class="line">        date = get_date_from_title(title)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            page_data = get_data(title, url)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(url)</span><br><span class="line">            page_data = <span class="literal">None</span></span><br><span class="line">        all_data[date] = page_data</span><br><span class="line">        <span class="built_in">print</span>(page_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save as json format</span></span><br><span class="line">    <span class="comment"># all_data = json.dumps(all_data,  ensure_ascii=False)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;all_data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(all_data, f ,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="Data-analysis-py">Data_analysis.py</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">导入json文件进行分析</span></span><br><span class="line"><span class="string">这里仅仅进行简单的探索，大家可以仿照之前的QQ空间数据分析报告那篇文章，</span></span><br><span class="line"><span class="string">调用boson公司的ａｐｉ进行情感分析等</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;all_data.txt&#x27;</span>) <span class="keyword">as</span> data_file:</span><br><span class="line">    data = json.load(data_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line">data = <span class="built_in">dict</span>(data)</span><br><span class="line">details = <span class="built_in">list</span>(data.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并标题至同一列表</span></span><br><span class="line">whos = []</span><br><span class="line">texts = []</span><br><span class="line"><span class="keyword">for</span> detail <span class="keyword">in</span> details:</span><br><span class="line">    <span class="keyword">if</span> detail != <span class="literal">None</span>:</span><br><span class="line">        page_data = detail[<span class="string">&#x27;envos&#x27;</span>]</span><br><span class="line">        who = <span class="built_in">list</span>(page_data.keys())</span><br><span class="line">        text = <span class="built_in">list</span>(page_data.values())</span><br><span class="line">        whos += who</span><br><span class="line">        texts += text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Whos</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总数量： &quot;</span>,  <span class="built_in">len</span>(whos))</span><br><span class="line"><span class="built_in">print</span>(whos)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 年级</span></span><br><span class="line">whos_text = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">str</span>(who) <span class="keyword">for</span> who <span class="keyword">in</span> whos)</span><br><span class="line">rank = re.findall(<span class="string">&#x27;.*?(\d\d).*?&#x27;</span>, whos_text)</span><br><span class="line"></span><br><span class="line">true_rank = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rank)):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(rank[i])&gt;=<span class="number">12</span>) <span class="keyword">and</span> (<span class="built_in">int</span>(rank[i])&lt;=<span class="number">16</span>):</span><br><span class="line">        true_rank.append(rank[i])</span><br><span class="line"></span><br><span class="line">sns.countplot(true_rank)</span><br><span class="line">plt.title(<span class="string">&#x27;Grade&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">## reply</span></span><br><span class="line">reps = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> who <span class="keyword">in</span> whos:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;回复&#x27;</span> <span class="keyword">in</span> who:</span><br><span class="line">        reps += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回信数： &quot;</span>, reps)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回信率： &quot;</span>, reps/<span class="built_in">len</span>(whos))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># What</span></span><br><span class="line"><span class="comment"># print(texts)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分词</span></span><br><span class="line">clear_texts = []</span><br><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> texts:</span><br><span class="line">    sentence = sentence.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    clear_texts += sentence</span><br><span class="line"><span class="comment"># print(clear_texts)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pic_path = <span class="string">&#x27;heart.png&#x27;</span></span><br><span class="line">heart_mask = imread(pic_path)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">wordcloud = WordCloud(background_color=<span class="string">&quot;white&quot;</span>, font_path=<span class="string">&#x27;/home/shensir/Downloads/Fonts/msyh.ttc&#x27;</span>, mask=heart_mask).generate(<span class="built_in">str</span>(clear_texts))</span><br><span class="line">plt.imshow(wordcloud)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/wechat/grade.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/wechat/heart_wc.png" alt=""></p>
<h5 id="补充-2">补充</h5>
<blockquote>
<p>代码写的比较粗糙…不过思路还好比较清晰<br>
这个清博…好像提供API来着…并未深入了解</p>
</blockquote>
<h5 id="参考-6">参考</h5>
<p><a href="http://kekefund.com/2016/01/21/spider-cookie/">网页爬虫之cookie自动获取 </a><br>
<a href="http://datahonor.com/2017/03/02/QQ%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/">QQ空间数据分析报告 </a></p>
<h5 id="废话几句">废话几句</h5>
<p>自学Python快一年了，其中最大的快乐当真来自大家的认同。不断有朋友通过邮件，留言等方式告诉我说，为了学爬虫来的，觉得自己写的浅显易懂些，希望多更新爬虫的文章。有位大佬竟然真的从博客园，追到DATADREAM[之前的站点，不打算更了…], 再追到DATAHONOR[就是本站了…]，莫名感动…对大家的认可，真是发自内心的感激，谢谢你们的鼓励~ 曾听得曹涧秋老师讲到人活着的意义何在，说到底，三个字————被需要！那么我觉着…省略1W字 :-)<br>
不过呢因为目前大部分时间放在cpp和数学，所以很少写爬虫了，十分抱歉~争取有时间尽量写点…<br>
大好年华，一起努力吧！<br>
                                                                                                                               ————2017/4/4  01:40 小小白<br>
-</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python日常积累</title>
    <url>/2017/03/06/Python%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h5 id="1-copy-deepcopy">1.copy &amp; deepcopy</h5>
<p>参考<a href="http://www.cnblogs.com/Richardzhu/p/4723750.html">这里</a><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/copy.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ空间数据分析报告</title>
    <url>/2017/03/02/QQ%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h5 id="概览-8">概览</h5>
<p>之前呢，写了<a href="http://datahonor.com/2017/03/02/Selenium%E7%88%AC%E5%8F%96QQ%E7%A9%BA%E9%97%B4%E8%AF%B4%E8%AF%B4%E4%BF%A1%E6%81%AF/#more">这个爬虫</a>，从QQ邮箱导出所有QQ联系人后，在本地电脑上放养几天，经过几次refuse，还是爬完了所有的好友的说说资料。数据量约60K+， 但是NA值较多。</p>
<h5 id="数据导出">数据导出</h5>
<p>这里呢，简单作下分析。<br>
第一步就是从MySQL中把数据以csv格式导出。</p>
<p>参考<a href="http://www.tech-recipes.com/rx/1475/save-mysql-query-results-into-a-text-or-csv-file/">这里</a>。开始时，尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM QQSpace</span><br><span class="line">INTO OUTFILE &#x27;/home/shen/PycharmProjects/MyPython/MySpider/QQ/data.csv&#x27;</span><br><span class="line">FIELDS TERMINATED BY &#x27;,&#x27;</span><br><span class="line">ENCLOSED BY &#x27;&quot;&#x27;</span><br><span class="line">LINES TERMINATED BY &#x27;\n&#x27;</span><br></pre></td></tr></table></figure>
<p>出现权限问题：</p>
<blockquote>
<p>The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</p>
</blockquote>
<p>参考<a href="http://stackoverflow.com/questions/32737478/how-should-i-tackle-secure-file-priv-in-mysql">这里</a>解决：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ1.png" alt=""><br>
之后先将文件导出到这个文件夹下，再复制到指定文件夹下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /var/lib/mysql-files/data.csv /home/shen/PycharmProjects/MyPython/MySpider/QQ/data.csv</span><br></pre></td></tr></table></figure>
<p>发现文件时锁定的，在给予权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /home/shen/PycharmProjects/MyPython/MySpider/QQ/data.csv</span><br></pre></td></tr></table></figure>
<h5 id="数据分析-2">数据分析</h5>
<p>至此，算是将数据从数据库导出，接下来开始用Python作分析</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;/home/shen/PycharmProjects/MyPython/MySpider/QQ/data.csv&#x27;</span>, error_bad_lines=<span class="literal">False</span>） <span class="comment"># drop bad lines</span></span><br><span class="line">data.columns = [<span class="string">&#x27;Qq&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>, <span class="string">&#x27;Content&#x27;</span>, <span class="string">&#x27;Star&#x27;</span>, <span class="string">&#x27;Comment&#x27;</span>]</span><br><span class="line"><span class="comment"># 预览数据，检查有无编码等问题</span></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"><span class="built_in">print</span>(data.shape)</span><br><span class="line"><span class="built_in">print</span>(data.dtypes)</span><br><span class="line"><span class="comment"># 因当中有过测试性的抓取，所以可能存在重复数据，这里先去重</span></span><br><span class="line">data = data.drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看缺失值</span></span><br><span class="line"><span class="built_in">print</span>(data.isnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ2.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ3.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ4.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ5.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们首先统一分析</span></span><br><span class="line">Date = data[<span class="string">&#x27;Date&#x27;</span>]</span><br><span class="line">Content = data[<span class="string">&#x27;Content&#x27;</span>]</span><br><span class="line">Star = data[<span class="string">&#x27;Star&#x27;</span>]</span><br><span class="line">Comment = data[<span class="string">&#x27;Comment&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>日期的分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Date</span></span><br><span class="line">Date = pd.DataFrame(Date)</span><br><span class="line"><span class="built_in">print</span>(Date.shape[<span class="number">0</span>])</span><br><span class="line">Date.isnull().<span class="built_in">sum</span>()</span><br><span class="line">Date  = Date.dropna()</span><br><span class="line"><span class="comment"># 对日期的处理，定义统一格式的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2016年09月09日</span></span><br><span class="line"><span class="string">2017年1月1日</span></span><br><span class="line"><span class="string">昨天18:03  这种格式一般为最近几天，数量较少，暂时忽略不去处理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datesplit</span>(<span class="params">date</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        year = date.split(<span class="string">&#x27;年&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        month = date.split(<span class="string">&#x27;年&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;月&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">int</span>(month) &lt; <span class="number">10</span>) &amp; (<span class="string">&#x27;0&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> month)):</span><br><span class="line">            month = <span class="string">&#x27;0&#x27;</span> + month</span><br><span class="line"></span><br><span class="line">        day = date.split(<span class="string">&#x27;年&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;月&#x27;</span>)[<span class="number">1</span>].replace(<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">int</span>(day) &lt; <span class="number">10</span>) &amp; (<span class="string">&#x27;0&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> day)):</span><br><span class="line">            day = <span class="string">&#x27;0&#x27;</span> + day</span><br><span class="line">        sdate = <span class="built_in">int</span>(<span class="built_in">int</span>(year)*<span class="number">10000</span>+<span class="built_in">int</span>(month)*<span class="number">100</span>+<span class="built_in">int</span>(day))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># print(date)</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">    <span class="keyword">return</span> [year, month, day, sdate]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date[<span class="string">&#x27;Year&#x27;</span>] = Date[<span class="string">&#x27;Date&#x27;</span>].apply(datesplit).apply(<span class="keyword">lambda</span> x : x[<span class="number">0</span>])</span><br><span class="line">Date[<span class="string">&#x27;Month&#x27;</span>] = Date[<span class="string">&#x27;Date&#x27;</span>].apply(datesplit).apply(<span class="keyword">lambda</span> x : x[<span class="number">1</span>])</span><br><span class="line">Date[<span class="string">&#x27;Day&#x27;</span>] = Date[<span class="string">&#x27;Date&#x27;</span>].apply(datesplit).apply(<span class="keyword">lambda</span> x : x[<span class="number">2</span>])</span><br><span class="line">Date[<span class="string">&#x27;SDate&#x27;</span>] = Date[<span class="string">&#x27;Date&#x27;</span>].apply(datesplit).apply(<span class="keyword">lambda</span> x : x[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">Date = Date.dropna()  <span class="comment"># 去除废弃时间格式的数据</span></span><br><span class="line">Date[<span class="string">&#x27;SDate&#x27;</span>] = Date[<span class="string">&#x27;SDate&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(Date.head())</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ6.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Date[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(Date[<span class="string">&#x27;SDate&#x27;</span>], <span class="built_in">format</span>=<span class="string">&#x27;%Y%m%d&#x27;</span>)  <span class="comment"># 格式化为标准时间格式</span></span><br><span class="line"><span class="keyword">del</span> Date[<span class="string">&#x27;SDate&#x27;</span>] <span class="comment"># 删掉无用列</span></span><br><span class="line"><span class="built_in">print</span>(Date.head())</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ7.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Year,Month, Day</span></span><br><span class="line">sns.countplot(<span class="string">&#x27;Year&#x27;</span>, data=Date)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">sns.countplot(<span class="string">&#x27;Month&#x27;</span>, data=Date)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">sns.countplot(<span class="string">&#x27;Day&#x27;</span>, data=Date)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>从年份看，还是很平均的，因为2017时刚开始，数据本来就是很少的。至于2010前比较少，可能和大部分人喜欢删之前的说说有关.<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ8.png" alt=""></p>
<p>月份上，7，8月比较高，猜测和之前在博客园写的超级课程表的分析时原因类似的，就是，7，8月为暑假，大家对学习关注较少，而游玩的较多，所以经常会发些旅游的动态。或是在家里闲得无聊，发说说也会比较多。</p>
<p>至于3,4,5月份数量较少[闰年二月天数少的影响在此可忽略]，就不太明白了，沉迷学习？ 🙂<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ9.png" alt=""><br>
天数上看，大家还是“风雨无阻”的，31少也是必然的，毕竟1，3，5，7。。。 	<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ10.png" alt=""></p>
<p>看了上面的图感觉都很平均的orz…<br>
这里附上一张超级课程表分析时的一张图:<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ11.png" alt=""><br>
与之比较，我们重新将月份整理为折线图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与超级课程表相比较</span></span><br><span class="line">plt.plot(Date.groupby(<span class="string">&#x27;Month&#x27;</span>).size(), linestyle=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.xlim(xmin=<span class="number">1</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Month&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ12.png" alt=""></p>
<p>貌似有点类似负相关的关系哦…<br>
当我尝试进行年份[根据以上分析选取12-16年数据]比较时，发现了一个问题：没有出现预期的走势一致性.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 各个年份的比较[12-16]</span></span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2012&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2012&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2012&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2013&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2013&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2013&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2014&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2015&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2015&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2015&#x27;</span>) </span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2016&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2016&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2016&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ13.png" alt=""></p>
<p>这张图有些乱，我们分开来做图，先做12-14年的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2012&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2012&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2012&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2013&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2013&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2013&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2014&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ14.png" alt=""><br>
可以看到，12-14年走势基本上是一致的，但是14年出现较大的不同。<br>
再作出14-16的图看下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2014&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2014&#x27;</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2015&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2015&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2015&#x27;</span>) </span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2016&#x27;</span>].groupby(<span class="string">&#x27;Month&#x27;</span>).size()/Date[Date[<span class="string">&#x27;Year&#x27;</span>]== <span class="string">&#x27;2016&#x27;</span>].shape[<span class="number">0</span>], label=<span class="string">&#x27;2016&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ15.png" alt=""><br>
看到变化更大了，15尚且出现较大的峰值，到了16年，竟然变得近似平稳了…16年似乎欠我们个峰值…仔细想下，这可能和微信的崛起有关。查了下<a href="http://mt.sohu.com/20150723/n417406422.shtml">资料</a>，14年春晚使用微信红包后微信开始迅速崛起，并于15年强势和QQ抗衡，并且微信发展速度明显超越QQ。所以16年QQ空间欠我们的峰值，可能跑去了微信朋友圈orz…<br>
继续分析，我们来看下，一年中哪些特别的峰值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一年中的特特殊的日子</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">131</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]==<span class="string">&#x27;2012&#x27;</span>].groupby(<span class="string">&#x27;Date&#x27;</span>).size())</span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">132</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]==<span class="string">&#x27;2013&#x27;</span>].groupby(<span class="string">&#x27;Date&#x27;</span>).size())</span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">133</span>)</span><br><span class="line">plt.plot(Date[Date[<span class="string">&#x27;Year&#x27;</span>]==<span class="string">&#x27;2014&#x27;</span>].groupby(<span class="string">&#x27;Date&#x27;</span>).size())</span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ16.png" alt=""></p>
<p>可以看到，2月初到中旬的情人节，暑假开始7月，开学季9月，国庆节10月都或多或少出现一些峰值[可能是爬虫漏爬的问题，这里不是特别明显]</p>
<p>接下来分析说说的文本内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态内容，文本分析</span></span><br><span class="line">Content = pd.DataFrame(Content.astype(<span class="built_in">str</span>))</span><br><span class="line">Content.columns = [<span class="string">&#x27;content&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说说长度</span></span><br><span class="line">Content[<span class="string">&#x27;length&#x27;</span>] = Content[<span class="string">&#x27;content&#x27;</span>].apply(<span class="built_in">len</span>)</span><br><span class="line"><span class="comment"># 大体观察，看有无异常值</span></span><br><span class="line">plt.plot(Content[<span class="string">&#x27;length&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 发现一个异常值，去除异常值并填充</span></span><br><span class="line">Content[<span class="string">&#x27;length&#x27;</span>][Content[<span class="string">&#x27;length&#x27;</span>] &gt; <span class="number">1000</span>] = Content[<span class="string">&#x27;length&#x27;</span>].mean()</span><br><span class="line"><span class="comment"># 再次观察</span></span><br><span class="line">plt.plot(Content[<span class="string">&#x27;length&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ17.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ18.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上图仅仅是为了观察异常值，这里我们具体观察说说长度</span></span><br><span class="line"><span class="comment"># 取长度在4倍标准差之内的数据</span></span><br><span class="line">ctmean = Content[<span class="string">&#x27;length&#x27;</span>].mean()</span><br><span class="line">ctstd = Content[<span class="string">&#x27;length&#x27;</span>].std()</span><br><span class="line">foursigma = Content[(ctmean-<span class="number">4</span>*ctstd&lt;Content[<span class="string">&#x27;length&#x27;</span>]) &amp; (Content[<span class="string">&#x27;length&#x27;</span>]&lt;ctmean+<span class="number">4</span>*ctstd)]</span><br><span class="line">plt.hist(foursigma[<span class="string">&#x27;length&#x27;</span>])</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Length&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ19.png" alt=""></p>
<p>可以看到，大部分的说说都是不超过50字的…这才是典型的快餐文化嘛:-)</p>
<p>接着我们来做个简单的情感分析，通过调用Boson公司的API</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 之前没考虑到根据QQ号来分类，这里重新获取</span></span><br><span class="line">Content = data[[<span class="string">&#x27;Qq&#x27;</span>, <span class="string">&#x27;Content&#x27;</span>]]</span><br><span class="line">Content = Content.dropna()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Content[<span class="string">&#x27;Qq&#x27;</span>].unique())</span><br><span class="line"><span class="comment"># 发现有些QQ号被误填为其他文字，用相邻[上一个]QQ号填充</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Content[<span class="string">&#x27;Qq&#x27;</span>]).index):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Content[<span class="string">&#x27;Qq&#x27;</span>].loc[Content[<span class="string">&#x27;Qq&#x27;</span>].index[i]] = <span class="built_in">int</span>(Content[<span class="string">&#x27;Qq&#x27;</span>].loc[Content[<span class="string">&#x27;Qq&#x27;</span>].index[i]])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">        Content[<span class="string">&#x27;Qq&#x27;</span>].loc[Content[<span class="string">&#x27;Qq&#x27;</span>].index[i]] = <span class="built_in">int</span>(Content[<span class="string">&#x27;Qq&#x27;</span>].loc[Content[<span class="string">&#x27;Qq&#x27;</span>].index[i-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Content[<span class="string">&#x27;Qq&#x27;</span>].unique())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情感分析</span></span><br><span class="line">emotion = &#123;&#125;</span><br><span class="line">nlp = BosonNLP(<span class="string">&#x27;你的密钥&#x27;</span>)   </span><br><span class="line"></span><br><span class="line">qq_cont = (Content.groupby(<span class="string">&#x27;Qq&#x27;</span>)[<span class="string">&#x27;Content&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(qq_cont)):</span><br><span class="line">    qq = <span class="built_in">list</span>(Content.groupby(<span class="string">&#x27;Qq&#x27;</span>)[<span class="string">&#x27;Content&#x27;</span>])[i][<span class="number">0</span>]</span><br><span class="line">    contents = <span class="built_in">list</span>(<span class="built_in">list</span>(Content.groupby(<span class="string">&#x27;Qq&#x27;</span>)[<span class="string">&#x27;Content&#x27;</span>])[i][<span class="number">1</span>])</span><br><span class="line">    text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        text += content</span><br><span class="line"></span><br><span class="line">    grade = nlp.sentiment(text)[<span class="number">0</span>]</span><br><span class="line">    emotion[<span class="built_in">str</span>(qq)] = grade</span><br><span class="line">    <span class="built_in">print</span>(grade)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正面，负面情绪 </span></span><br><span class="line">positive = []</span><br><span class="line">negative = []</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> emotion.values():</span><br><span class="line">    positive.append(e[<span class="number">0</span>])</span><br><span class="line">    negative.append(e[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>简单的可视化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p1 = plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.hist(positive)</span><br><span class="line">p1.set_title(<span class="string">&#x27;Positive&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p2 = plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.hist(negative)</span><br><span class="line">p2.set_title(<span class="string">&#x27;Negative&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ20.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LogNorm</span><br><span class="line"></span><br><span class="line">plt.hist2d(positive, negative, norm=LogNorm())</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Positive&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Negative&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Emotion&#x27;</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ21.png" alt=""></p>
<p>哈哈，还是开心看到大家都是非常乐观的:-)</p>
<p>继续，我们来提取下关键词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关键词提取</span></span><br><span class="line">WeightWord = &#123;&#125;</span><br><span class="line">KEYWORDS_URL = <span class="string">&#x27;http://api.bosonnlp.com/keywords/analysis&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cont <span class="keyword">in</span> ContentDict.values():</span><br><span class="line">    text = cont</span><br><span class="line">    params = &#123;<span class="string">&#x27;top_k&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    data = json.dumps(text)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;X-Token&#x27;</span>: <span class="string">&#x27;你的密钥&#x27;</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;requesting...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(KEYWORDS_URL, headers=headers, params=params, data=data.encode(<span class="string">&#x27;utf-8&#x27;</span>), timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(resp.json())</span><br><span class="line">        <span class="keyword">for</span> weight, word <span class="keyword">in</span> resp.json():</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> WeightWord.keys():</span><br><span class="line">                WeightWord[word] = weight</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Hit...&#x27;</span>)</span><br><span class="line">                WeightWord[word] += weight</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 关键词排序</span></span><br><span class="line">SortedValue = [v <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">sorted</span>(WeightWord.values())]</span><br><span class="line">ValueWord = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> WeightWord.items():</span><br><span class="line">    ValueWord[<span class="built_in">str</span>(value)] = key</span><br><span class="line"></span><br><span class="line">SortedValue_top100 = SortedValue[-<span class="number">100</span>:][::-<span class="number">1</span>]</span><br><span class="line">SortedWord = [ValueWord[<span class="built_in">str</span>(k)] <span class="keyword">for</span> k <span class="keyword">in</span> SortedValue_top100]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ22.png" alt=""></p>
<p>这是用Boson公司的API做的，我们接下来用结巴分词并用wordcloud做个词云看看吧:-)[参考<a href="https://www.oschina.net/code/snippet_2294527_56155">这里</a>]</p>
<p>我这里用的Ubuntu16.04，没有中文字体，安装字体参考<a href="http://blog.csdn.net/up_com/article/details/51218458">这里</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关键词词云</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</span><br><span class="line"></span><br><span class="line">mylist = <span class="built_in">list</span>(ContentDict.values())   </span><br><span class="line"></span><br><span class="line">word_list = [<span class="string">&quot; &quot;</span>.join(jieba.cut(sentence)) <span class="keyword">for</span> sentence <span class="keyword">in</span> mylist]</span><br><span class="line">new_text = <span class="string">&#x27; &#x27;</span>.join(word_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pic_path = <span class="string">&#x27;/home/shen/CLionProjects/MyCv/QQ.jpg&#x27;</span></span><br><span class="line">mang_mask = imread(pic_path)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line">wordcloud = WordCloud(background_color=<span class="string">&quot;white&quot;</span>, font_path=<span class="string">&#x27;/home/shen/Downloads/font/msyh.ttc&#x27;</span>, mask=mang_mask).generate(new_text)</span><br><span class="line">plt.imshow(wordcloud)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ23.png" alt=""><br>
嗯，这张图用了QQ图标做的mask,还是挺有意思的。</p>
<p>那么，我们接下来分析下说说关注的话题看看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说说文本分类</span></span><br><span class="line">CLASSIFY_URL = <span class="string">&#x27;http://api.bosonnlp.com/classify/analysis&#x27;</span></span><br><span class="line">TextClass = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mylist)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = json.dumps(mylist[i])</span><br><span class="line">        headers = &#123;<span class="string">&#x27;X-Token&#x27;</span>: <span class="string">&#x27;你的密钥&#x27;</span>&#125;</span><br><span class="line">        resp = requests.post(CLASSIFY_URL, headers=headers, data=data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(resp.text[<span class="number">1</span>])</span><br><span class="line">        TextClass.append(<span class="built_in">int</span>(resp.text[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">ClassCount = Counter(TextClass)</span><br><span class="line"><span class="built_in">print</span>(ClassCount)</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ24.png" alt=""><br>
Boson给定的参照表为：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ25.png" alt=""></p>
<p>我们简单做个可视化： ~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dfclass = pd.DataFrame(TextClass)</span><br><span class="line">sns.countplot(<span class="number">0</span>, data=dfclass)</span><br><span class="line">plt.xticks((<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>), (<span class="string">&#x27;Physical&#x27;</span>, <span class="string">&#x27;Education&#x27;</span>, <span class="string">&#x27;Society&#x27;</span>, <span class="string">&#x27;Entertainment&#x27;</span>, <span class="string">&#x27;Domestic&#x27;</span>, <span class="string">&#x27;Technology&#x27;</span>, <span class="string">&#x27;Estate&#x27;</span>), rotation=<span class="number">70</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Class&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ26.png" alt=""></p>
<p>嗯，同学们和大佬们还是学习的比较多:-)<br>
于我的好友来说，确实是关注教育，娱乐，科技多一点的，看来Boson的API还是挺好用的。<br>
数据集里面还有点赞数和评论数，我们先从点赞数分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Star.shape)</span><br><span class="line"><span class="built_in">print</span>(Star.isnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>(48822, )<br>
51</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除缺失值</span></span><br><span class="line">Star = pd.DataFrame(Star.dropna())</span><br><span class="line">Star.columns = Star[<span class="string">&#x27;star&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除Star里面的异常值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Star[<span class="string">&#x27;star&#x27;</span>].index:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Star[<span class="string">&#x27;star&#x27;</span>].loc[i] = <span class="built_in">int</span>(Star[<span class="string">&#x27;star&#x27;</span>].loc[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(Star[<span class="string">&#x27;star&#x27;</span>].loc[i])</span><br><span class="line">        Star[<span class="string">&#x27;star&#x27;</span>].loc[i] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Star.isnull().<span class="built_in">sum</span>())</span><br><span class="line">Star = pd.DataFrame(Star.dropna())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有些赞数是来自转发的，一般较多，我们这里将这种情况去除</span></span><br><span class="line">Star = Star[(Star[<span class="string">&#x27;star&#x27;</span>].apply(<span class="built_in">int</span>) &lt; <span class="number">200</span>)]</span><br><span class="line"><span class="built_in">print</span>(Star.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作图</span></span><br><span class="line">plt.hist(<span class="built_in">list</span>(Star[<span class="string">&#x27;star&#x27;</span>]), bins=<span class="number">20</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Star&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ27.png" alt=""></p>
<p>相同地，接下来是评论数的分析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 评论数分析[与点赞分析基本一致]</span></span><br><span class="line"><span class="built_in">print</span>(Comment.shape)</span><br><span class="line"><span class="built_in">print</span>(Comment.isnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除缺失值</span></span><br><span class="line">Comment = pd.DataFrame(Comment.dropna())</span><br><span class="line">Comment.columns = [<span class="string">&#x27;Comment&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除Comment里面的异常值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Comment[<span class="string">&#x27;Comment&#x27;</span>].index:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Comment[<span class="string">&#x27;Comment&#x27;</span>].loc[i] = <span class="built_in">int</span>(Comment[<span class="string">&#x27;Comment&#x27;</span>].loc[i])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(Comment[<span class="string">&#x27;Comment&#x27;</span>].loc[i])</span><br><span class="line">        Comment[<span class="string">&#x27;Comment&#x27;</span>].loc[i] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Comment.isnull().<span class="built_in">sum</span>())</span><br><span class="line">Comment = pd.DataFrame(Comment.dropna())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有些评论是来自转发的，一般较多，我们这里将这种情况去除</span></span><br><span class="line">Comment = Comment[(Comment[<span class="string">&#x27;Comment&#x27;</span>].apply(<span class="built_in">int</span>) &lt; <span class="number">100</span>)]</span><br><span class="line"><span class="built_in">print</span>(Comment.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作图</span></span><br><span class="line">plt.hist(<span class="built_in">list</span>(Comment[<span class="string">&#x27;Comment&#x27;</span>]), bins=<span class="number">20</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.title(<span class="string">&#x27;Comment&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/QQ28.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue</title>
    <url>/2017/05/11/Queue/</url>
    <content><![CDATA[<h4 id="Overview-46">Overview</h4>
<p>前面学习的栈是后进先出[LIFO]，与之相对的是队列的先进先出[FIFO]。这里我们通过两种方式实现Queue,分别是Array和List。在Array实现的时候要注意，实际上，整个过程都是在一维的数组上操作的，但是，为了在enqueue[插入]和dequeue[弹出]数据的时候有效地利用空间，我们将其看作一个圆环，这样，前面dequeue留下的空间，还可以共之后enqueue使用。</p>
<h4 id="Code-41">Code</h4>
<h5 id="Array实现–genArrayQueue-h">Array实现–genArrayQueue.h</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_GENARRAYQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_GENARRAYQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size=<span class="number">100</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ArrayQueue&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> first, last;</span><br><span class="line">    T storage[size];</span><br><span class="line">    <span class="type">int</span> total_num=<span class="number">0</span>;  <span class="comment">// 用于计数，方便打印</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ArrayQueue</span>()&#123;</span><br><span class="line">        first = last = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first==<span class="number">0</span> &amp;&amp; last==size<span class="number">-1</span> || first == last+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 由于dequeue只是移动首部的位置，并不是真正的删除，所以打印的时候不能直接循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = first; i &lt; total_num+first; i++) &#123;</span><br><span class="line">            std::cout&lt;&lt;storage[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="type">void</span> ArrayQueue&lt;T,size&gt;::<span class="built_in">enqueue</span>(T el) &#123;</span><br><span class="line">    total_num += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isFull</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(last==size<span class="number">-1</span> || last == <span class="number">-1</span>)&#123;</span><br><span class="line">            storage[<span class="number">0</span>] = el;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="number">-1</span>)</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> storage[++last] = el;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;Full queue.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line">T ArrayQueue&lt;T, size&gt;::<span class="built_in">dequeue</span>() &#123;</span><br><span class="line">    total_num -= <span class="number">1</span>;</span><br><span class="line">    T tmp;</span><br><span class="line">    tmp = storage[first];</span><br><span class="line">    <span class="keyword">if</span>(first == last)</span><br><span class="line">        last = first = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first == size<span class="number">-1</span>)</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> first++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_GENARRAYQUEUE_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-cpp-9">main.cpp</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genArrayQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayQueue&lt;<span class="type">int</span>&gt; AQ;</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    AQ.<span class="built_in">dequeue</span>();</span><br><span class="line"></span><br><span class="line">    AQ.<span class="built_in">printQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>3 4</p>
</blockquote>
<h5 id="List实现–genQueue-h">List实现–genQueue.h</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_GENQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_GENQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;T&gt;lst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lst.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T el = lst.<span class="built_in">front</span>();</span><br><span class="line">        lst.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> T&amp; el)</span></span>&#123;</span><br><span class="line">        lst.<span class="built_in">push_back</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printListQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;T&gt;::iterator i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            std::cout&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_GENQUEUE_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="main-cpp-10">main.cpp</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;<span class="type">int</span>&gt; AQ;</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    AQ.<span class="built_in">enqueue</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    AQ.<span class="built_in">dequeue</span>();</span><br><span class="line"></span><br><span class="line">    AQ.<span class="built_in">printListQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>3 4</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>R In Jupyter</title>
    <url>/2017/10/24/R-In-Jupyter/</url>
    <content><![CDATA[<h3 id="Overview-47">Overview</h3>
<p>最近写R，包括作笔记都是习惯在RStudio用RMD写，之后发布到rpubs，然后到博客这里做个简单介绍，附上链接…感觉略麻烦，想着之前发现可以在hexo直接显示Jupyter Notebook，用Python做过测试，感觉还不错。所以想着用Jupyter Notebook来写R。</p>
<blockquote>
<p>ps:现在才知道Jupyter–&gt;Julia+Python+R</p>
</blockquote>
<h3 id="Steps-2">Steps</h3>
<h4 id="安装步骤">安装步骤</h4>
<p>直接参考<a href="https://github.com/IRkernel/IRkernel">Github地址</a>进行安装，在R中运行：</p>
<blockquote>
<p>install.packages(‘devtools’)<br>
devtools::install_github(‘IRkernel/IRkernel’)<br>
# or devtools::install_local(‘IRkernel-master.tar.gz’)<br>
IRkernel::installspec()  # to register the kernel in the current R installation</p>
</blockquote>
<p>之后运行Jupyter Notebook, 在new按钮下就有了创建R脚本的选项。</p>
<h4 id="添加新的库">添加新的库</h4>
<p>通过上面的方式，运行R完全可以，也自带了一些经常用到的库。但是我们可能要添加新的库，这时候也可以通过命令行安装。</p>
<p>在Notebook上查看所有安装的包，然后找到对应的路径。再到终端，以<code>root</code>运行R<code>sudo R</code>（需要权限）,之后运行<code>install.packages(&quot;lib name&quot;, lib=&quot;lib path&quot;)</code>（lib name替换为包名称, lib path替换为之前查看到的路径）即可。</p>
<h3 id="Supplement-6">Supplement</h3>
<p>看到Github上也提供了用Docker来配置的方法。话说一直不清楚Docker怎么玩的…这次打算研究下。</p>
<h4 id="可能遇到的问题">可能遇到的问题</h4>
<ol>
<li>参照<a href="https://irkernel.github.io/installation/">irkernel安装指南</a>“出错”</li>
</ol>
<p>在<strong>Rstudio</strong>执行第一条命令是可以的，但是第二条的时候会报错：</p>
<blockquote>
<p>jupyter-client has to be installed but “jupyter kernelspec --version” exited with code 127</p>
</blockquote>
<p>原因是不能在Rstudio执行，需要在终端直接启动R，然后执行如下命令即可，参考<a href="https://stackoverflow.com/questions/44056164/jupyter-client-has-to-be-installed-but-jupyter-kernelspec-version-exited-wit">stackoverflow</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install.packages(&#x27;devtools&#x27;)</span><br><span class="line"></span><br><span class="line">devtools::install_github(&#x27;IRkernel/IRkernel&#x27;)</span><br><span class="line"></span><br><span class="line">IRkernel::installspec()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>R package installiation</title>
    <url>/2019/01/03/R-package-installiation/</url>
    <content><![CDATA[<p>R久没有遇到装库的问题，今天遇到两个比较有趣的。</p>
<h3 id="只能在R-terminal安装">只能在R terminal安装</h3>
<p>发现有些包在Rstudio装不上（比如今天装的ks就是），在终端打开直接就可以了。后来查到<a href="https://support.rstudio.com/hc/en-us/articles/200554786-Problem-Installing-Packages">Rstudio Support</a>给的建议第一条也是这个，原因不清，暂不追究。</p>
<h3 id="ld-cannot-find-lgfortran">ld: cannot find -lgfortran</h3>
<p>报错如下：<br>
<img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/201812/Screenshot%20from%202019-01-03%2014-44-00.png" alt=""></p>
<p>参考<a href="https://stackoverflow.com/questions/6302209/building-r-package-getting-error-ld-cannot-find-lgfortran">这里</a></p>
<p>终端运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/lib/x86_64-linux-gnu/libgfortran.so.3 /usr/lib/libgfortran.so</span><br><span class="line">sudo ln -s /usr/lib/x86_64-linux-gnu/libquadmath.so.0 /usr/lib/libquadmath.so</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<h3 id="configure-error-Cannot-compile-a-simple-JNI-program">configure: error: Cannot compile a simple JNI program</h3>
<p>在安装<code>RWeka</code>的时候遇到这个错误，具体是其中安装<code>rJava</code>的时候出现的错误。根据<a href="https://stackoverflow.com/questions/42562160/r-cmd-javareconf-not-finding-jni-h/42567372">stackoverflow</a>，终端运行，</p>
<p><code>R CMD javareconf</code></p>
<p>得到报错，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java interpreter : /usr/lib/jvm/default-java/jre/bin/java</span><br><span class="line">Java version     : 1.8.0_191</span><br><span class="line">Java home path   : /usr/lib/jvm/default-java</span><br><span class="line">Java compiler    : not present</span><br><span class="line">Java headers gen.: </span><br><span class="line">Java archive tool: </span><br><span class="line"></span><br><span class="line">trying to compile and link a JNI program </span><br><span class="line">detected JNI cpp flags    : </span><br><span class="line">detected JNI linker flags : -L$(JAVA_HOME)/jre/lib/amd64/server -ljvm</span><br><span class="line">gcc -std=gnu99 -I/usr/share/R/include -DNDEBUG      -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -g  -c conftest.c -o conftest.o</span><br><span class="line">conftest.c:1:10: fatal error: jni.h: No such file or directory</span><br><span class="line"> #include &lt;jni.h&gt;</span><br><span class="line">		  ^~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">/usr/lib/R/etc/Makeconf:159: recipe for target &#x27;conftest.o&#x27; failed</span><br><span class="line">make: *** [conftest.o] Error 1</span><br><span class="line">Unable to compile a JNI program</span><br><span class="line">/usr/lib/R/bin/javareconf: 366: cd: can&#x27;t cd to /home/shensir/Documents/DataMining/Code/DecisionTree/ID3/id3-python/Decision</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JAVA_HOME        : /usr/lib/jvm/default-java</span><br><span class="line">Java library path: </span><br><span class="line">JNI cpp flags    : </span><br><span class="line">JNI linker flags : </span><br><span class="line">Updating Java configuration in /usr/lib/R</span><br><span class="line">Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要还是<code>jni.h</code>的问题。之后又查到<a href="https://superuser.com/questions/1404488/install-r-3-5-2-under-ubuntu-jni-h-no-such-file-or-directory">这里</a>，运行<code>sudo apt install default-jdk</code>解决问题。</p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>ROC-AUC</title>
    <url>/2020/05/02/ROC-AUC/</url>
    <content><![CDATA[<h2 id="始">始</h2>
<blockquote>
<p>“You are writing a book because you are not entirely satisfied with the available texts.”  – George Casella</p>
</blockquote>
<p>因为我实在受不了竟然有人写出ROC-AUC的物理意义这种东西…</p>
<h2 id="When-Where-Who-Why">When&amp;Where&amp;Who&amp;Why</h2>
<p>任何事物，包括一个概念，理论的提出必然有其历史背景，有其原因，也就是所谓的Motivation. 所以要想真正认识ROC和AUC必须追溯其历史，这要从1941年日军偷袭珍珠港说起…</p>
<blockquote>
<p>The ROC curve was first used during <a href="https://en.wikipedia.org/wiki/World_War_II">World War II</a> for the analysis of <a href="https://en.wikipedia.org/wiki/Radar">radar signals</a> before it was employed in <a href="https://en.wikipedia.org/wiki/Signal_detection_theory">signal detection theory</a>.[<a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#cite_note-green66-44">44]</a> Following the <a href="https://en.wikipedia.org/wiki/Attack_on_Pearl_Harbor">attack on Pearl Harbor</a> in 1941, the United States army began new research to increase the prediction of correctly detected Japanese aircraft from their radar signals. For these purposes they <strong>measured the ability</strong> of a radar receiver operator to make these important distinctions, which was called the <strong>Receiver Operating Characteristic.</strong>  --Wikipedia</p>
</blockquote>
<p>也就是说，在珍珠港战役之后，美军迫切地需要侦测技术的提升来更好地检测到日军飞机的入侵，所谓提升必然要有比较的指标，这个指标就是ROC.</p>
<p>在《百面机器学习》的第二章提到了ROC曲线具体的由来。</p>
<blockquote>
<p>ROC曲线最早是运用在军事上的,后来逐渐运用到医学领域,并于20世纪80年代后期被引入机器学习领域。相传在第二次 世界大战期间,雷达兵的任务之一就是死死地盯住雷达显示器,观察是否有敌机来袭。理论上讲,只要有敌机来袭,雷达屏幕上 就会出现相应的信号。但是实际上,如果飞鸟出现在雷达扫描区域时,雷达屏幕上有时也会出现信号。这种情况令雷达兵烦恼不<br>
已,如果过于谨慎,凡是有信号就确定为敌机来袭,显然会增加误报风险;如果过于大胆,凡是信号都认为是飞鸟,又会增加漏报的风险。每个雷达兵都竭尽所能地研究飞鸟信号和飞机信号之间的区别,以便增加预报的准确性。但问题在于,每个雷达兵都 有自己的判别标准,有的雷达兵比较谨慎,容易出现误报;有的雷达兵则比较胆大,容易出现漏报。</p>
<p>为了研究每个雷达兵预报的准确性,雷达兵的管理者汇总了所有雷达兵的预报特点,特别是他们漏报和误报的概率,并将 这些概率画到一个二维坐标系里。这个二维坐标的纵坐标为敏感性(真阳性率),即在所有敌机来袭的事件中,每个雷达兵准确 预报的概率。而横坐标则为1-特异性(假阳性率),表示在所有非敌机来袭信号中,雷达兵预报错误的概率。由于每个雷达兵的<br>
预报标准不同,且得到的敏感性和特异性的组合也不同。将这些雷达兵的预报性能进行汇总后,雷达兵管理员发现他们刚好在一条曲线上,这条曲线就是后来被广泛应用在医疗和机器学习领域的ROC曲线。</p>
</blockquote>
<p>现在我们可以来尝试回答为什么会有ROC曲线的存在了，就是我们需要<strong>一种更加稳健的衡量指标来判断某样东西的好坏</strong>，在探索这个指标的过程诞生了ROC曲线.在后面的分析中，我们可以更加直观地搞明白其为什么是稳健的。</p>
<p>我这里用“某样东西”是因为其不仅仅包含大家熟知的二分类器和上面的雷达探测仪器，它包含更多的东西。</p>
<h2 id="What">What</h2>
<p>说了那么久，那么到底ROC是什么东西呢？简单地讲，是个曲线图。</p>
<blockquote>
<p>A <strong>receiver operating characteristic curve</strong>, or <strong>ROC curve</strong>, is a <a href="https://en.wikipedia.org/wiki/Graph_of_a_function">graphical plot</a> that illustrates the diagnostic ability of a <a href="https://en.wikipedia.org/wiki/Binary_classifier">binary classifier</a> system as its discrimination threshold is varied. --Wikipedia</p>
</blockquote>
<p>Wiki上明确地给出我前面说的“某样东西”是一个&quot;binary classifier sysytem&quot;， 即一个二分类系统(再次强调，请不要局限在ML里面的二分类…一个分辨灯泡好坏的仪器同样是一个二分类系统，这在质量管理中的例子很多).</p>
<p>那么，现在我们知道了ROC曲线是一个图，它衡量一个二分类系统的诊断能力，同时其每一个点是根据一个<code>threshold</code>得到，我们变换这个<code>threshold</code>就得到了一系列的点，连点成线就得到了ROC曲线。</p>
<p>那么现在就剩下一个问题，即如何根据这个<code>threshold</code>来获取ROC曲线上的点。这里需要引入一些定义。</p>
<blockquote>
<p>正类: Positive class,正品，阳性， 用1表示</p>
<p>负类: Negative class,次品，阴性，用0表示</p>
<p>TP, FP, TN, FN: True Positive, False Positive, True Negative, False Negative</p>
<p>TPR: True Postive Rate, Recall, Sensitivity, $$TPR = \frac{TP}{TP+FN}$$</p>
<p>FPR:  False Positive Rate, Fall-out, $FPR=\frac{FP}{FP+TN}$</p>
<p>预测值: Score，二分类系统给样本的打分，实数范围R</p>
<p>阈值: Threshold</p>
</blockquote>
<p>ROC定义横轴为FPR，纵轴为TPR。进而问题转化成如何从<code>Threshold</code> $T$得到对应点的横纵座标，即$(FPR_T， TPR_T)$.从某个集合$S_T$中取不同的阈值$T$，就得到一系列的横纵座标，也就是ROC曲线上的一系列点${(FPR_T, TPR_T) | T \in S_T}$, 也就得到了ROC曲线。</p>
<p>一般来说，二分类系统的直接结果是一个连续的值即<code>Score</code>，而不是0或1的<code>Class</code>，或者说，从更广义的角度来说，这是一个合理的假定。而$TP, FP, FN, TN$等的计算是是直接依赖类别的，而<code>Threshold</code>就是一个沟通预测<code>Score</code>与<code>Class</code>的桥梁。我们通常约定**<code>Score</code>大于<code>Threshold</code>则预测为1，否则预测为0**</p>
<p>虽然说的很麻烦，但是整个流程很简单: 拟定$T$的取值集合$S_T$， 将测试样本进入二分类系统，得出Score（将Score按升序排列），根据每个$T$进而计算$TP, FP, FN, TN$， 最后有 ${(FPR_T, TPR_T) | T \in S_T}$， 连点成线即可。</p>
<p>因为<code>Score</code>的取值范围为$R$, 所以$T$的取值理论上也是$R$, 但是在此问题中，我们可以将其缩小到$[min(Score), max(Score)]$（这里的<code>Score</code>是指根据样本计算出的实际的数列）, 想一想为什么(hint: 考虑$TP, FP, FN, TN$的计算)， 一般均匀地取上几十个点就足够了，当然这也要看具体的样本量。这里其实又衍生出另外一个问题，而这个问题又给出了另外一种在实际中绘制ROC曲线的方法，当然本质上还是上面说的那种，只是实践起来略有差别。</p>
<p>在样本很多的时候，我们可以取一些阈值，好比是10个，然后得到10个点，绘制出ROC曲线；如果我们取20个阈值，显然绘制出的ROC曲线会更加“精细”一些。那么这就是我前面说到的衍生的问题了，我们可以绘制出无限精细的ROC曲线吗？如果不能，我们能够做到的“精细”的极限又在哪里呢？答案是不能无限精细，其精细的极限由样本量控制。那么，为什么呢？看下面这种绘制ROC曲线的方法，你就明白了。</p>
<blockquote>
<p>首先,根据样本标签统计出正负样本的数量,假设正样本数量为P,负样本数量为N;接下来,把横轴的刻度间隔设置为1/N,纵轴的刻度间隔设置为1/P;再根据模型输出的预测概率对样本进行排序(从高到低);依次遍历样本,同时从零点开始绘制ROC曲线,每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线,每遇到一个负样本就沿横轴方向绘制一个刻度间隔的曲线,直到遍历完所有样本,曲线最终停在(1,1)这个点,整个ROC曲线绘制完成。 --《百面机器学习》</p>
</blockquote>
<p><img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/2020/Screenshot%20from%202020-05-02%2014-58-14.png" alt=""></p>
<h2 id="How">How</h2>
<p>在搞清楚ROC是什么之后，我们需要知道它到底怎么来衡量二分类系统的好坏呢？或者说什么样的曲线是说明系统分类的性能比较好？这首先要研究下ROC曲线的一些性质。</p>
<p>首先，其必过(0, 0)与(1, 1)两点： $\forall T \in (-\inf, min(Score))$, 样本全部被预测为1， $FPR=1, TPR=1$, 即过点(1, 1); $\forall T \in (max(Score), \inf)$,样本全部被预测为0， $FPR=0, TPR=0$, 即过点(0, 0).</p>
<blockquote>
<p>所以上面说的$T$的取值范围可以限制在$[min(Score), max(Score)]$的原因就一目了然了~</p>
</blockquote>
<p>其次是我们希望二分类系统的FPR尽可能小的同时TPR尽可能地大，对应到ROC曲线就是曲线尽可能向左上方靠近。一个很好的辅助线就是$y=x$,即连接上述两点的对角线。在ROC Space(详见Wikipedia)中，这条曲线表示二分类系统中衡有FPR=TPR，也就说这种分类系统就是随机给出的预测，毫无任何意义。我们的ROC 曲线一般都是在其上方的。</p>
<p>这里其实还可以问一下，ROC总是在$y=x$的上方吗？我觉着这个问题值得停下来取想一下的。这个问题的答案当然是否定的。因为我们一般遇到的结果效果都比较好，所以不存在这种情况，但是确实是存在这种情况的。举一个极端的例子，设计好一个二分类系统后，我们给定的测试样本全是负样本，那么无论如何得到的ROC曲线一定是X轴上的一条直线，必然是在$y=x$下面的！</p>
<p>然后呢，还有一个问题就是我们仅仅知道<strong>偏左上方比较好</strong>是不够的，定性的方法还是不如定量的方法来的实用。在两个系统的ROC曲线都是偏左上方，并且看起来没什么大的差别时如果比较呢？答案就是AUC(Area under the curve)了，即ROC曲线下的面积(这里没有具体去查AUC引入的历史，不过其引入也算是比较自然的，究其本质，面积即积分，积分即累加)。</p>
<p>先说结论，一般认为AUC大的分类系统更好一些。而且AUC除了定量地表示了偏左上的程度之外还有一个很好的性质，就是其取值范围在0和1之间，可以很方便地进行比较。考虑上面的$y=x$时为随机猜正负，其AUC为0.5， 所以我们的分类系统AUC的底线就是0.5，越高越好。</p>
<h2 id="AUC">AUC</h2>
<p>对AUC的解释有很多，其中有个被问烂的问题就是其所谓的“物理意义”…（真就“为什么JAVA实现中链表长度到8就变红黑树”呗:-)</p>
<p>AUC的概率解释在Wikipedia中有详细的推导.<br>
$$<br>
\begin{equation}\begin{aligned}<br>
&amp;T P R(T): T \rightarrow y(x)\<br>
&amp;F P R(T): T \rightarrow x\<br>
&amp;\mathrm{TPR}(T)=\int_{T}^{\infty} f_{1}(x) d x\<br>
&amp;\operatorname{FPR}(T)=\int_{T}^{\infty} f_{0}(x) d x\<br>
&amp;AUC=\int_{x=0}^{1} \operatorname{TPR}\left(\operatorname{FPR}^{-1}(x)\right) d x=\int_{\infty}^{-\infty} \operatorname{TPR}(T) \operatorname{FPR}^{\prime}(T) d T=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} I\left(T^{\prime}&gt;T\right) f_{1}\left(T^{\prime}\right) f_{0}(T) d T^{\prime} d T=P\left(X_{1}&gt;X_{0}\right)<br>
\end{aligned}\end{equation}<br>
$$<br>
其中$X_1$是正类的的$Score$, $X_2$是负类的$Score$. 此外AUC也是<code>Wilcoxon-Mann-Whitney statistic</code>，公式如下,这里的$f$指二分类系统.<br>
$$<br>
A U C(f)=\frac{\sum_{t_{0} \in \mathcal{D}^{0}} \sum_{t_{1} \in \mathcal{D}^{1}} \mathbf{1}\left[f\left(t_{0}\right)&lt;f\left(t_{1}\right)\right]}{\left|\mathcal{D}^{0}\right| \cdot\left|\mathcal{D}^{1}\right|}<br>
$$<br>
总而言之就是</p>
<blockquote>
<p>When using normalized units, the area under the curve (often referred to<br>
as simply the AUC) is equal to the probability that a classifier will<br>
rank a randomly chosen positive instance higher than a randomly chosen<br>
negative one (assuming ‘positive’ ranks higher than ‘negative’)</p>
</blockquote>
<p>也就是说AUC本质上是一个平均值，对正负样本集做笛卡尔积，然后每对样本中比较正类与负类的$Score$大小，找出那些正类得分大于负类得分的配对，其数量与总的配对数量之比就是AUC的值。</p>
<p>那么，根据上面的计算公式，我们能够理解AUC的稳健之处正是在于其平均了每种配对的情况，这也是在样本类别不均衡时用AUC来衡量模型的原因。</p>
<p>其实还有一个很有趣的问题，就是AUC的代码实现，这个我是没有去查过目前已有的实现的，但是通过上面的解释，我们大概有两种方法去计算，第一就是用<code>Wilcoxon-Mann-Whitney statistic</code>，基于计数去算；第二个是从给出的精细ROC绘制方法入手。那么问题来了，那个更快呢？</p>
<h2 id="末">末</h2>
<p>想知道ROC怎么from scratch来用代码画吗？想了解AUC两种计算方式的benchmarking吗？想…也没有续集了，或许要等下年五一了:-)</p>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Rank, Stem-Leaf in R</title>
    <url>/2017/11/01/Rank-Stem-Leaf-in-R/</url>
    <content><![CDATA[<iframe src="http://nbviewer.jupyter.org/github/shenxiangzhuang/EDA-Course-WIth-R/blob/master/Chap1_rank_stem.ipynb" width="700" height="700"></iframe>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>EDA</tag>
      </tags>
  </entry>
  <entry>
    <title>S&amp;S悖论</title>
    <url>/2018/12/27/S-S%E6%82%96%E8%AE%BA/</url>
    <content><![CDATA[<p>向学校反映了几个问题，主要和图书馆书记反映的。大概是图书馆图书查找问题，图书馆座位与扩建的问题，学生早读和图书馆禁止喧哗的冲突。</p>
<p>首先是图书馆图书的问题，主要是自身的经历。大半年前去外文书库找书，那里的值班老师说还没有排好书让自己去找。少说也几千本书，找了几个小时，到衣服湿透也没找到…（还记得是找Tao神的书来着Orz）。想着等过些时候正式上架排好了再找，然而大半年过去了，今天去借书，还是一样没排好。</p>
<p>先是随便问了位值班老师哪里可以反映问题，说是二楼一个办公室，进去反映了以上问题。老师说她们和那位老师（外文书库管理员）说过很多次，主任也和她讲过多次，然而并没用。我就问谁可以管得了，给了我馆长和书记的电话，然后问了下办公室就在楼上，直接去找书记了（馆长出差）。书记态度很好，谈了好久，反映了上面说的几个问题，具体情况如下。</p>
<ul>
<li>[x] 图书馆图书查找</li>
</ul>
<p>问了书库的名字，回说五楼外文书库，主要问题就是不整理书，讲明是大半年都没有人去整理。以及三楼科技书库也很混乱的问题。书记说其他也有很多同学反映找不到书，主要因为现在图书馆人员比较紧张，上架比较慢，他们会加强管理。</p>
<ul>
<li>[x] 图书馆座位与扩建的问题</li>
</ul>
<p>反映了在临近期末的时候，学弟学妹期末考试和大四考研的人会凑到一起，图书馆座位根本不够，很多人在空的书架上或坐在地上看书复习，图书馆有没有扩建的打算啥的。书记说他们当时已经注意到这个问题，并考虑扩建图书馆问题什么的（说的比较模糊）。然后说，后来发现考研的一走，座位又够了…如果真的扩建了，平时都没人去就不太合适了。然后说会进一步落实这些问题。（感觉扩建是不太可能了…）然后即使扩建，现在大三大四也用不上的。（这种落实肯定不是一两年能搞定的）</p>
<ul>
<li>[x] 学生早读和图书馆禁止喧哗的冲突</li>
</ul>
<p>考研的很多在图书馆，然后一般在附近读书，几个人还好，几百人一起真的有些吵了，尤其考研最后几个月。对此图书馆也在各处张贴了禁止喧哗的规定。书记说这个真的需要学生的自觉。然后我提议说这样一直禁止也没什么效果，而且学生大多也是迫不得已才这样，能不能考虑开通几间早读自修室，这样夏天也不用在外面晒着，冬天也不会都跑去走廊那里。回答说他们没有权限去干涉自修室的问题…然后让我去联系学公办或者相关的部门。</p>
<p>又问了下我如何跟进这些事情的处理进程，回答说看看情况有没有改善，有问题再去反映。然后怕耽搁书记太多时间，谢过后去了办公楼…</p>
<p>找到一楼教务管理（办公室具体名字没记住）那里，发现老师差不多全下班了，只剩下一位老师。问能不能把一教早上一二节少排一些课，然后每天预留出来几个教室作为晨读教室。老师说排课很麻烦，很多冲突什么的，然后说这不是那几个就能说了算的，要协调很多东西。然后…我问有没有谁（意指更高层的领导…坦诚:-)可以处理这个问题，老师说下午再来吧。还有提到一点就是好像他们管不了这个什么，让去对面…（含糊，没搞清楚去哪里）</p>
<p>忙了半天，发现这样“绕”了一圈几乎改变不了什么，不过这和不去“绕”还是要有些不同。所以S&amp;S悖论终归是鲁迅所言之死火。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SAS学习记录</title>
    <url>/2017/09/20/SAS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>这学期开了时间序列的课， 用的SAS（当然是盗版orz…）， 打算系统地学一下。在这里记录一下学习的过程。</p>
<h5 id="2017-9-20">2017/9/20</h5>
<p>其实这学期也开了专门的统计软件课，不过讲的是SPSS那货，大一时候学了下，实在是无聊得很。。。所以也就更没有必要为它做记录了。今天看了下SAS的语法还是比较强大的。主要参考了SAS官方放在<a href="https://www.youtube.com/watch?v=Uj1Pi7BfiL4&amp;index=11&amp;list=PLVBcK_IpFVi_nlx6za9Yht0eyb46hLLrP">YouTube的视频</a>. 另外，发现一本很好的书，干净整洁，<em>The Little SAS Book</em>,接下来主要就是撸这本书了。</p>
<h5 id="2018-2-6">2018/2/6</h5>
<p>嗯…当真受不了SAS的语法，上面的书撸了几十页就看不下去了。不过就目前看，用SAS做时间序列的东西还是挺方便的。先不管了，用到了再去学吧:-)</p>
]]></content>
      <categories>
        <category>SAS</category>
      </categories>
      <tags>
        <tag>SAS</tag>
      </tags>
  </entry>
  <entry>
    <title>SBT使用</title>
    <url>/2020/12/14/SBT%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>Overview</h1>
<p>记录SBT使用情况.</p>
<h1>Tips</h1>
<h2 id="入门指南">入门指南</h2>
<p>目前看了<em>Sbt In Action</em>这本书的前四章，感觉整体讲解的还是比较清晰的(比直接跟着Scala官网走流程好多了)。包括设计理念在内的大部分概念都有涉及，简单的使用来说差不多够用了。</p>
<h2 id="Thin-Jar-and-Fat-Jar">Thin Jar and Fat Jar</h2>
<p>因为Scala运行在JVM上，一个很直接的问题是怎样把Scala程序打包成JAR包直接<code>java -jar xxx.jar</code>执行？这里就涉及两个命令及其对应的包。</p>
<p>终端输入<code>sbt</code>进入sbt环境，如果输入<code>package</code>那么会给出一个Thin Jar, 也就是将源码直接打包，不加入其他运行需要的依赖; 如果加入<code>sbt-assembly</code>插件(后面会介绍如何加入)，输入<code>assembly</code>,那么就会得到一个Fat Jar。 Fat Jar就是我们可以直接运行的Jar包。</p>
<p>关于Fat jar的生成以及<code>sbt-assembly</code>插件的使用参考<a href="https://www.baeldung.com/scala/sbt-fat-jar">Baeldung</a>:</p>
<ol>
<li>在<code>build.sbt</code>同目录下的<code>project</code>文件夹下新建<code>plugins.sbt</code>文件</li>
<li>在<code>plugins.sbt</code>文件中添加<code>addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.15.0&quot;)</code>即可</li>
</ol>
<p>文章另外讲了<code>provided</code>与<code>default deduplicate merge strategy(META-INF)</code>的讲解.</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>SS使用-全局代理</title>
    <url>/2017/08/01/SS%E4%BD%BF%E7%94%A8-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>SS全局代理的设置。测试情况：</p>
<p>设置PAC文件：</p>
<blockquote>
<p>参考<a href="http://www.pandagao.com/2016/05/13/ubuntu-use-shadowsocks-and-pac/">这里</a>，开始运行不成功，因为PIP安装的GenPAC不支持Py3,即使update也不行orz…后来到Github发现正好新添加了Py3的支持，又clone并install重新安装GenPAC才可以(类似的版本问题值得注意！)，成功生成了PAC文件。然后在在系统设置，网络，代理里面选择自动，并指定了PAC的地址。之后启动Shadowsocks并连接。这时候Chrome可以在不使用插件的时候翻出去，但是FireFox还是不行，最后发现把原来的PAN插件禁用才可以。</p>
</blockquote>
<p>设置代理地址：</p>
<blockquote>
<p>在系统设置，网络，代理里面选择人工设置，在Socks Host一栏填入127.0.0.1:1080即可。之后启动Shadowsocks并连接。这时候Chrome可以在不使用插件的时候翻出去，但是FireFox不行,即使禁用了PAN也是不行。</p>
</blockquote>
<p>总之，通过第一种方法我们可以实现浏览器的完全的代理模式，但是终端还是不行。于是就用polipo来搞了。参考<a href="http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/index.html">这里</a>设置成功。</p>
<p>运行结果(盖住了部分ip…)：</p>
<pre><code>shensir@shen:~$ curl ip.gs
Current IP / 当前 IP: 150.255.29.xxx
ISP / 运营商:  ChinaUnicom
City / 城市: Haikou Hainan
Country / 国家: China
Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans 

  /\_/\
=( °w° )=
  )   (  //
 (__ __)//

shensir@shen:~$ hp curl ip.gs
Current IP / 当前 IP: 45.77.19.xxx
ISP / 运营商:  choopa.com
City / 城市: Tokyo Tokyo
Country / 国家: Japan
Please join Telegram group https://t.me/sbfans if you have any issues. / 如有问题，请加入 Telegram 群 https://t.me/sbfans 

  /\_/\
=( °w° )=
  )   (  //
 (__ __)//
</code></pre>
<p>貌似是可以了，可是我加了hp<code>再ping www.google.com</code>还是不行orz…<br>
此外，代码翻墙也是有待解决…先挖个坑，有空再来填吧.</p>
<p>====================================================</p>
<p>2017/8/14 解决部分终端问题</p>
<p>今天在用conda装虚拟环境的时候，不管用不用前面的hp似乎都没什么卵用…就试了试proxychains。安装和设置都十分简单，参考<a href="https://github.com/naseeihity/LearnReact/issues/7">这里</a>。这样设置后虽说还是ping不通Google,但是在使用conda装东西的时候速度可以起飞…嗯，目前是够用了，先这样。</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;2019/4/29 更新 proxychains quit mode&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
参考<a href="https://www.codeproject.com/Tips/634228/How-to-Use-Proxychains-Forwarding-Ports">这里</a>.修改其配置文件即可。</p>
<p>====================================================<br>
2017/9/10 解决Python代码翻墙问题</p>
<p>之前尝试了很多办法，都没办法在Python利用SS翻墙。现在是找到了两种解决方案。第一种就是在运行Python脚本的时候加上前面设置的proxychains。但是总感觉不太方便（Pycharm里面不好用…）于是就有了第二种方法（感谢一位群友相助），是利用requests设置代理IP的方法，其实也很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://localhost:1080&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;https://localhost:1080&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">data = requests.<span class="built_in">get</span>(<span class="string">&quot;https://www.google.com.hk&quot;</span>, proxies=proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.status_code)</span><br><span class="line"><span class="built_in">print</span>(data.text)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有两个关键的地方：</p>
<ul>
<li>[ ] SS设置</li>
</ul>
<blockquote>
<p>Local Server Type 改成Http(s)。。。之前就是用SOCKS，一直不成。。</p>
</blockquote>
<ul>
<li>[ ] Http | SOCKS5</li>
</ul>
<blockquote>
<p>proxy里面， “http”: “<a href="http://localhost:1080">http://localhost:1080</a>” , 后面也对应改成http</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Screen recorder: peek</title>
    <url>/2018/06/21/Screen-recorder-peek/</url>
    <content><![CDATA[<h3 id="Peek">Peek</h3>
<p>了解到一款比较好用的录屏应用：<a href="https://github.com/phw/peek">peek</a>.安装比较简单。不过命令行第一执行有报错，可能是网络的问题，用了<code>proxychains</code>就可以了。</p>
<h3 id="gifski">gifski</h3>
<p>在peek的FAQ里面提到了为了改善图像质量的建议，就是<a href="https://github.com/ImageOptim/gifski">gifski</a>。安装这个前需要装下<a href="https://www.rust-lang.org/en-US/install.html">Rust</a>,之后参考<a href="https://doc.rust-lang.org/book/second-edition/ch01-01-installation.html">这里</a>把环境变量加一下就可以了。</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十一：Segmenting an image with the GrabCut algorithm</title>
    <url>/2017/05/02/Segmenting-an-image-with-the-GrabCut-algorithm/</url>
    <content><![CDATA[<h5 id="Overview-48">Overview</h5>
<p>如上篇所述，所关注的物体有较为独特的颜色时，我们可以通过一个颜色范围过滤出想要的物体。但是有些时候所要抽取的物体并不总是有鲜明的颜色特征。这里，我们介绍另一种根据图片特征进行分类的算法，即为GrabCut.</p>
<h5 id="Code-42">Code</h5>
<p>先看一下实现代码和效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/lake.png&quot;</span>);</span><br><span class="line">    <span class="function">cv::Rect <span class="title">rectangle</span><span class="params">(<span class="number">50</span>,<span class="number">30</span>,<span class="number">240</span>,<span class="number">170</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show the ractangle</span></span><br><span class="line">    cv::Mat imageclone = image.<span class="built_in">clone</span>();</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(imageclone, rectangle, <span class="number">255</span>, <span class="number">2</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image with Ractangle&quot;</span>, imageclone);</span><br><span class="line"></span><br><span class="line">    cv::Mat result;</span><br><span class="line">    cv::Mat bgMOdel, fgModel;</span><br><span class="line">    cv::<span class="built_in">grabCut</span>(image, result, rectangle, bgMOdel, fgModel, <span class="number">5</span>, cv::GC_INIT_WITH_RECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    打印可以看到result是由1，2，3，4组成，即为四种模式</span></span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;result&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;cv::GC_PR_FGD&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">compare</span>(result, cv::GC_PR_FGD, result, cv::CMP_EQ);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">foreground</span><span class="params">(image.size(), CV_8UC3,cv::Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span></span>;</span><br><span class="line">    image.<span class="built_in">copyTo</span>(foreground, result);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;foreground&quot;</span>, foreground);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170502/Selection_002.png" alt=""></p>
<p>简单解释下上面的程序：</p>
<ul>
<li>[ ] <strong>cv::grubCut</strong><br>
先看下文档的参数解释：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170502/Selection_001.png" alt=""></li>
</ul>
<blockquote>
<p>中文解释，参考<a href="http://blog.csdn.net/zouxy09/article/details/8535087">这里</a><br>
这个解释还是挺不错的，但是在mask和rect这里好像和文档有些出入。第一个是mask这里，即使不手工标记，也会有GCD_BGD存在，因为rect之外的部分默认被视为背景，我们上面的实验结果result也是未进行人工标注，其包含0，2，3.</p>
</blockquote>
<ul>
<li>[ ] <strong>models</strong><br>
看文档强调在处理同一张图片时，不要修改两个models,即bgdModel和fgdModel.这是因为运行grubCut之后，里面保存了一些之前迭代的数据，如果得到的结果不理想，我们可以再次利用这两个models继续迭代，省去重复迭代。</li>
</ul>
<blockquote>
<p>This explains the argument of the function where the user can specify<br>
the number of iterations to be applied. The two internal models<br>
maintained by the algorithm are passed as an argument of the function<br>
(and returned). Therefore, it is possible to call the function with the<br>
models of the last run again if one wishes to improve the segmentation<br>
result by performing additional iterations.</p>
</blockquote>
<ul>
<li>[ ] <strong>cv::GC_PR_FGD and cv::GC_FGD</strong><br>
在我们上面的程序，<code>cv::compare(result, cv::GC_PR_FGD, result, cv::CMP_EQ);</code>可以看出，我们提取的是，可能的前景图，并没有提取确定的前景图。我们可以将这一行代码换为<code>result = result&amp;1</code>来达到同时提取的目的。<br>
因为，</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//! class of the pixel in GrabCut algorithm</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GrabCutClasses</span> &#123;</span><br><span class="line">    GC_BGD    = <span class="number">0</span>,  <span class="comment">//!&lt; an obvious background pixels</span></span><br><span class="line">    GC_FGD    = <span class="number">1</span>,  <span class="comment">//!&lt; an obvious foreground (object) pixel</span></span><br><span class="line">    GC_PR_BGD = <span class="number">2</span>,  <span class="comment">//!&lt; a possible background pixel</span></span><br><span class="line">    GC_PR_FGD = <span class="number">3</span>   <span class="comment">//!&lt; a possible foreground pixel</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以，1&amp;1, 1&amp;3 均为1，0&amp;1， 2&amp;1均为0.这里因为没有事先标记GC_FGD，所以同时获取得到的结果和之前是一样的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium爬取QQ空间说说信息</title>
    <url>/2017/03/02/Selenium%E7%88%AC%E5%8F%96QQ%E7%A9%BA%E9%97%B4%E8%AF%B4%E8%AF%B4%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>知乎上看到<a href="https://zhuanlan.zhihu.com/p/25006226">这篇文章</a>，就拿来改进运行下。</p>
<p>可能是因为不太会用Selenium，page_source在这里并不能获取到动态加载后的网页数据，所以只能用自带的一系列的find_element. 但是也是出现无法完全抓取的问题，这里就直接放上源码了，有些乱，凑活看看先…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 屏幕截图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pic</span>(<span class="params">pic_name</span>):</span><br><span class="line">    data = driver.get_screenshot_as_png()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pic_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">savedata</span>(<span class="params">qq, post_data</span>):</span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    <span class="built_in">print</span>(post_data)</span><br><span class="line">    sql = <span class="string">&#x27;INSERT INTO QQSpace(qq, postime, content, star, cmt)VALUES(%s,%s,%s,%s,%s)&#x27;</span></span><br><span class="line">    cursor.execute(sql, (qq, post_data[<span class="number">0</span>], post_data[<span class="number">1</span>], post_data[<span class="number">2</span>], post_data[<span class="number">3</span>]))</span><br><span class="line">    <span class="comment"># 提交事务</span></span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># except:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Save fail...&#x27;)</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdata</span>(<span class="params">qq</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get data...&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        driver.switch_to.frame(<span class="string">&#x27;app_canvas_frame&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    content = driver.find_elements_by_css_selector(<span class="string">&#x27;.content&#x27;</span>)  <span class="comment"># div.bd pre.content</span></span><br><span class="line">    stime = driver.find_elements_by_css_selector(<span class="string">&#x27;.c_tx.c_tx3.goDetail&#x27;</span>)  <span class="comment"># div.info span.c_tx3 a.c_tx.c_tx3.goDetail</span></span><br><span class="line">    ft = driver.find_elements_by_class_name(<span class="string">&#x27;ft&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(content), <span class="built_in">len</span>(stime), <span class="built_in">len</span>(ft))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> con, sti, ft_data <span class="keyword">in</span> <span class="built_in">zip</span>(content, stime, ft):</span><br><span class="line">        <span class="comment"># print(ft_data)</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ft_data = ft_data.text.replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>).split(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;赞&#x27;</span> <span class="keyword">in</span> ft_data[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(ft_data) == <span class="number">3</span>:</span><br><span class="line">                    star = ft_data[<span class="number">1</span>]</span><br><span class="line">                    cmt = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">len</span>(ft_data) == <span class="number">5</span>:</span><br><span class="line">                    star = ft_data[<span class="number">1</span>]</span><br><span class="line">                    cmt = ft_data[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">len</span>(ft_data) == <span class="number">7</span>:</span><br><span class="line">                    star = ft_data[<span class="number">1</span>]</span><br><span class="line">                    cmt = ft_data[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    star = <span class="literal">None</span></span><br><span class="line">                    cmt = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                star = <span class="literal">None</span></span><br><span class="line">                cmt = ft_data[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            star = <span class="literal">None</span></span><br><span class="line">            cmt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        post_data = [sti.text, con.text, star, cmt]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            savedata(qq, post_data)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录QQ space</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_shuoshuo</span>(<span class="params">qq</span>):</span><br><span class="line">    driver.get(<span class="string">&#x27;https://user.qzone.qq.com/&#123;&#125;/311&#x27;</span>.<span class="built_in">format</span>(qq))</span><br><span class="line">    time.sleep(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># get_pic(&#x27;pre_login.png&#x27;)</span></span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;login_div&#x27;</span>)</span><br><span class="line">        a = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;can not find login_div&#x27;</span>)</span><br><span class="line">        a = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;logining...&#x27;</span>)</span><br><span class="line">        driver.switch_to.frame(<span class="string">&#x27;login_frame&#x27;</span>)</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;switcher_plogin&#x27;</span>).click()</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;u&#x27;</span>).clear()  <span class="comment"># 选择用户名框</span></span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;u&#x27;</span>).send_keys(<span class="string">&#x27;QQ号&#x27;</span>)</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;p&#x27;</span>).clear()</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;p&#x27;</span>).send_keys(<span class="string">&#x27;QQ密码&#x27;</span>)</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;login_button&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get_pic(&#x27;aft_input.png&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ok!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        driver.find_element_by_id(<span class="string">&#x27;QM_OwnerInfo_Icon&#x27;</span>)</span><br><span class="line">        b = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;can not find QM...&#x27;</span>)</span><br><span class="line">        b = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">7</span>)</span><br><span class="line">        getdata(qq)</span><br><span class="line">        continue_grap = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> continue_grap == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                driver.find_element_by_link_text(<span class="string">&#x27;下一页&#x27;</span>).click()</span><br><span class="line">                <span class="comment"># print(&#x27;sleeping...&#x27;)</span></span><br><span class="line">                time.sleep(<span class="number">7</span>)</span><br><span class="line">                getdata(qq)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开数据库，之后在具体调用后close</span></span><br><span class="line">    db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;数据库密码&quot;</span>, <span class="string">&quot;SpiderData&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用selenium</span></span><br><span class="line">    dcap = <span class="built_in">dict</span>(DesiredCapabilities.PHANTOMJS)</span><br><span class="line">    dcap[<span class="string">&quot;phantomjs.page.settings.userAgent&quot;</span>] = (</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0&quot;</span>)</span><br><span class="line">    driver = webdriver.PhantomJS(<span class="string">&#x27;/home/shen/Downloads/phantomjs-2.1.1-linux-x86_64/bin/phantomjs&#x27;</span>,</span><br><span class="line">                                 desired_capabilities=dcap)</span><br><span class="line">    driver.maximize_window()</span><br><span class="line"></span><br><span class="line">    get_shuoshuo(<span class="string">&#x27;要抓取的好友QQ号&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    driver.close()</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line">    db.close() </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/QQ/Screenshot-from-2017-01-26-22-56-33.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>Singly Linked Lists</title>
    <url>/2017/04/25/Singly-Linked-Lists/</url>
    <content><![CDATA[<h5 id="初识-2">初识</h5>
<p>单链表的原理比较简单：单链表由一个个的节点组成，每个节点包含其要存储的数据和一个指针，其中指针指向下一个节点，由此串成一个单向的链表。容易算出，在非首部的任意位置n处，单链表的增删改查的复杂度都为<strong>O(n)</strong>.在单链表的开始，即首部的增删改查均为<strong>O(1)</strong>.与Array的复杂度对比具体可参考wiki这张表：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170425/Screenshot%20from%202017-04-25%2000-17-42.png" alt=""></p>
<p>初步的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> info;</span><br><span class="line">    IntNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IntNode</span>()&#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IntNode</span>(<span class="type">int</span> i, IntNode* in = <span class="number">0</span>)&#123;</span><br><span class="line">        info = i;</span><br><span class="line">        next = in;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLinkedLists</span><span class="params">(IntNode* p )</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;info);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    IntNode* p = <span class="keyword">new</span> <span class="built_in">IntNode</span>(<span class="number">10</span>);</span><br><span class="line">    p-&gt;next = <span class="keyword">new</span> <span class="built_in">IntNode</span>(<span class="number">8</span>);</span><br><span class="line">    p-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">IntNode</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printLinkedLists</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>10<br>
8<br>
50</p>
</blockquote>
<h5 id="一般实现">一般实现</h5>
<h6 id="intSLLst-h">intSLLst.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_INTSSLST_H_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_INTSSLST_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> info;</span><br><span class="line">    IntNode* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IntNode</span>(<span class="type">int</span> el, IntNode* ptr = <span class="number">0</span>)&#123;</span><br><span class="line">        info = el; next = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntSLList</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    IntNode *head, *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">IntSLList</span>()&#123;</span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">IntSLList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToTail</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteFromHead</span><span class="params">()</span></span>;  <span class="comment">// delete the head and return its info;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteFromTail</span><span class="params">()</span></span>;  <span class="comment">// delete the tail and return its info;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNodeFromEl</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNodeFromPos</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToLList</span><span class="params">(<span class="type">int</span> el, <span class="type">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInList</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedLists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_INTSSLST_H_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="intSLLst-cpp">intSLLst.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-4-24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intSSLst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">IntSLList::~<span class="built_in">IntSLList</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(IntNode *p; !<span class="built_in">isEmpty</span>();)&#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::addToHead</span><span class="params">(<span class="type">int</span> el)</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> <span class="built_in">IntNode</span>(el, head);</span><br><span class="line">    <span class="keyword">if</span>(tail == <span class="number">0</span>)</span><br><span class="line">        tail = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::addToTail</span><span class="params">(<span class="type">int</span> el)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tail!=<span class="number">0</span>)&#123; <span class="comment">// if list not empty</span></span><br><span class="line">        tail-&gt;next = <span class="keyword">new</span> <span class="built_in">IntNode</span>(el);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> head = tail = <span class="keyword">new</span> <span class="built_in">IntNode</span>(el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IntSLList::deleteFromHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())</span><br><span class="line">        <span class="keyword">throw</span>(<span class="string">&quot;Empty&quot;</span>);  <span class="comment">// 若为空表，从头部删除的话就抛出错误</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> el = head-&gt;info;</span><br><span class="line">    IntNode *tmp = head;</span><br><span class="line">    <span class="keyword">if</span>(head == tail)  <span class="comment">// if only one node in the list</span></span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IntSLList::deleteFromTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> el = tail-&gt;info;</span><br><span class="line">    <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  <span class="comment">// if more than one node in the list</span></span><br><span class="line">        IntNode * tmp;  <span class="comment">// find the predecessor of tail</span></span><br><span class="line">        <span class="keyword">for</span>(tmp=head; tmp-&gt;next!=tail;tmp=tmp-&gt;next);</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">        tail = tmp;</span><br><span class="line">        tail-&gt;next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::deleteNodeFromEl</span><span class="params">(<span class="type">int</span> el)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="number">0</span>)&#123; <span class="comment">// if non-empty list</span></span><br><span class="line">        <span class="keyword">if</span>(head == tail &amp;&amp; el == head-&gt;info)&#123;  <span class="comment">// if only one</span></span><br><span class="line">            <span class="keyword">delete</span> head;                       <span class="comment">// node in the list</span></span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(el == head-&gt;info)&#123; <span class="comment">// if more than one node in the list</span></span><br><span class="line">            IntNode* tmp = head;  <span class="comment">// 原文是head-&gt;next, 应该是错了</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;  <span class="comment">// and old head is deleted</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">// if mpre than onde node in the lsit</span></span><br><span class="line">            IntNode *pred, *tmp;</span><br><span class="line">            <span class="keyword">for</span>(pred = head, tmp = head-&gt;next; tmp!=<span class="number">0</span> &amp;&amp; !(tmp-&gt;info == el);</span><br><span class="line">                    pred = pred-&gt;next, tmp = tmp-&gt;next);  <span class="comment">// and a non-head node is deleted</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tmp != <span class="number">0</span>)&#123;</span><br><span class="line">                pred-&gt;next = tmp-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(tmp == tail)</span><br><span class="line">                    tail = pred;;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::deleteNodeFromPos</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">deleteFromHead</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">deleteFromTail</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        IntNode *tmp=head-&gt;next;</span><br><span class="line">        IntNode *pred = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pos<span class="number">-2</span>; i++, tmp = tmp-&gt;next, pred = pred-&gt;next);</span><br><span class="line"></span><br><span class="line">        pred-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::addToLList</span><span class="params">(<span class="type">int</span> el, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">addToHead</span>(el);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( pos == <span class="number">-1</span> )</span><br><span class="line">        <span class="built_in">addToTail</span>(el);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        IntNode *tmp=head-&gt;next;</span><br><span class="line">        IntNode *pred = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pos<span class="number">-2</span>; i++, tmp = tmp-&gt;next, pred = pred-&gt;next);</span><br><span class="line"></span><br><span class="line">        IntNode* posNode = <span class="keyword">new</span> <span class="built_in">IntNode</span>(el);</span><br><span class="line">        posNode-&gt;next = tmp;</span><br><span class="line">        pred-&gt;next = posNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IntSLList::isInList</span><span class="params">(<span class="type">int</span> el)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    IntNode *tmp;</span><br><span class="line">    <span class="keyword">for</span>(tmp = head; tmp !=<span class="number">0</span> &amp;&amp; (!tmp-&gt;info == el); tmp = tmp-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> tmp != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// print the gly linked lists</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntSLList::printLinkedLists</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IntNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;info);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-11">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intSSLst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linked lists</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IntSLList list;</span><br><span class="line">    list.<span class="built_in">addToHead</span>(<span class="number">50</span>);</span><br><span class="line">    list.<span class="built_in">addToHead</span>(<span class="number">8</span>);</span><br><span class="line">    list.<span class="built_in">addToHead</span>(<span class="number">10</span>);</span><br><span class="line">    list.<span class="built_in">addToHead</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        list.<span class="built_in">deleteFromHead</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">char</span> <span class="type">const</span> * s)&#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;Error: &quot;</span>&lt;&lt;s&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the deleting form head...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the deleting from pos: 2th...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">deleteNodeFromPos</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the adding from pos: 2th...\n&quot;</span>);</span><br><span class="line">    list.<span class="built_in">addToLList</span>(<span class="number">77</span>, <span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">printLinkedLists</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>13<br>
10<br>
8<br>
50<br>
After the deleting form head…<br>
10<br>
8<br>
50<br>
After the deleting from pos: 2th…<br>
10<br>
50<br>
After the adding from pos: 2th…<br>
10<br>
77<br>
50</p>
</blockquote>
<h6 id="new-delete-and-pointers">new, delete and pointers</h6>
<p>在理解上面的deleteFromHead函数时有些懵，模仿着做了个测试，可以帮助理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* Ptr1 = <span class="keyword">new</span> <span class="built_in">int</span>(num1);</span><br><span class="line">    <span class="type">int</span>* Ptr2 = Ptr1; <span class="comment">// Ptr2与Ptr1是指向同一个地址的指针</span></span><br><span class="line">    <span class="type">int</span>* Ptr3 = &amp;num2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *Ptr1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *Ptr2);</span><br><span class="line">    Ptr1 = Ptr3;  <span class="comment">// 这里Ptr2已经为新的指针,和Ptr3指向同一地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> Ptr2;  <span class="comment">// 释放Ptr2指向的内存,因为此时Ptr1已经和Ptr3指向了同一地址,所以不会受影响.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *Ptr1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *Ptr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>
1<br>
2<br>
0</p>
</blockquote>
<h5 id="基于ADT的实现">基于ADT的实现</h5>
<h6 id="ListADT-h">ListADT.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-8-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MDATASTRUCTURE_LISTADT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDATASTRUCTURE_LISTADT_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// List ADT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">class</span> <span class="title class_">List</span>&#123;  <span class="comment">// List ADT</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> = (<span class="type">const</span> List&amp;)&#123;&#125;  <span class="comment">// Protect assignment</span></span><br><span class="line">    <span class="built_in">List</span>(<span class="type">const</span> List&amp;)&#123;&#125;  <span class="comment">// Protect copy constructor</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>()&#123;&#125;  <span class="comment">// Default constructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">List</span>()&#123;&#125;  <span class="comment">// Bae destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear contents from the list, to make it empty</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="built_in">clear</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert an element at the current location</span></span><br><span class="line">    <span class="comment">// item: The element to be inserted</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; item)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append an element at the end of the list</span></span><br><span class="line">    <span class="comment">// item: The element to be appended</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> E&amp; item)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove and return the current element</span></span><br><span class="line">    <span class="comment">// Return: the element that was removed</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> E <span class="title">remove</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the current position to the start of the list</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">moveToStart</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the current position to the end of the list</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">moveToEnd</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move the current position one step left.</span></span><br><span class="line">    <span class="comment">// No change if already at beginning</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move the current position one step right.</span></span><br><span class="line">    <span class="comment">// No change if already at end</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return: the number of elements in the list</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return: the position of the current element</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">currPos</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set current position</span></span><br><span class="line">    <span class="comment">// pos: The position to make current</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">moveToPos</span><span class="params">(<span class="type">int</span> pos)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return: The current element</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> E&amp; <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print List</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MDATASTRUCTURE_LISTADT_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="ListADT-cpp">ListADT.cpp</h6>
<p>这里额外附带了基于数组的顺序表的实现。此外是基于节点类的实现，与上面基于struct的实现略有差别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ListADT.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> defaultSize = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Array based list implementation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alist</span>: <span class="keyword">public</span> List&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxSize;  <span class="comment">// Maximum size of list</span></span><br><span class="line">    <span class="type">int</span> listSize; <span class="comment">// Number of list items now</span></span><br><span class="line">    <span class="type">int</span> curr;  <span class="comment">// Position of current element</span></span><br><span class="line">    E* listArray;  <span class="comment">// Array holding list elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Alist</span>(<span class="type">int</span> size=defaultSize)&#123;<span class="comment">// Constructor</span></span><br><span class="line">        maxSize = size;</span><br><span class="line">        listSize = curr = <span class="number">0</span>;</span><br><span class="line">        listArray = <span class="keyword">new</span> E[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Alist</span>()&#123;<span class="keyword">delete</span> [] listArray;&#125;  <span class="comment">// Destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;  <span class="comment">// Reinitialize the list</span></span><br><span class="line">        <span class="keyword">delete</span> [] listArray; <span class="comment">// Remove the array</span></span><br><span class="line">        listSize = curr = <span class="number">0</span>; <span class="comment">// Reset the size</span></span><br><span class="line">        listArray = <span class="keyword">new</span> E[maxSize];  <span class="comment">// Recreate array</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert &quot;it&quot; at current position</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; it)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(listSize &lt; maxSize &amp;&amp; <span class="string">&quot;List capacity exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=listSize; i &gt; curr; i--)</span><br><span class="line">            listArray[i] = listArray[i<span class="number">-1</span>];  <span class="comment">// shift to make room</span></span><br><span class="line">        listArray[curr] = it;</span><br><span class="line">        listSize++;  <span class="comment">// Increment list size</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> E&amp; it)</span></span>&#123;  <span class="comment">// Append &quot;it&quot;</span></span><br><span class="line">        <span class="built_in">assert</span>(listSize &lt; maxSize &amp;&amp; <span class="string">&quot;List capacity exceeded&quot;</span>);</span><br><span class="line">        listArray[listSize++] = it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove and return the current element</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((curr &gt; <span class="number">0</span>) &amp;&amp; (curr &lt; listSize) &amp;&amp; <span class="string">&quot;No element&quot;</span>);</span><br><span class="line">        E it = listArray[curr];  <span class="comment">// Copy the element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=curr; i&lt;listSize<span class="number">-1</span>; i++)</span><br><span class="line">            listArray[i] = listArray[i+<span class="number">1</span>];  <span class="comment">// shift them down</span></span><br><span class="line">        listSize--;</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToStart</span><span class="params">()</span></span>&#123;curr = <span class="number">0</span>;&#125;  <span class="comment">// Reset position</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToEnd</span><span class="params">()</span></span>&#123;curr = listSize;&#125;  <span class="comment">// Set at end</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prev</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(curr != <span class="number">0</span>) curr--;&#125;  <span class="comment">// Back up</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(curr &lt; listSize) curr++;&#125;  <span class="comment">// Next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return list size</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> listSize;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return current position</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">currPos</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> curr;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set current list position to &quot;pos&quot;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToPos</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((pos&gt;<span class="number">0</span>) &amp;&amp; (pos&lt;listSize) &amp;&amp; <span class="string">&quot;Pos out of range&quot;</span>);</span><br><span class="line">        curr = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> E&amp; <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">// Return current element</span></span><br><span class="line">        <span class="built_in">assert</span>((curr&gt;=<span class="number">0</span>) &amp;&amp; (curr&lt;listSize) &amp;&amp; <span class="string">&quot;No current element&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> listArray[curr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the list</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; listSize; i++)&#123;</span><br><span class="line">            std::cout &lt;&lt; listArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Singly linked list node</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">class</span> <span class="title class_">Link</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    E element;  <span class="comment">// Value for the node</span></span><br><span class="line">    Link* next;  <span class="comment">// Pointer to next node in list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Link</span>(<span class="type">const</span> E&amp; elemval, Link* nextval = <span class="literal">NULL</span>)&#123;</span><br><span class="line">        element = elemval;</span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Link</span>(Link* nextval=<span class="literal">NULL</span>)&#123;next=nextval;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linked list implementation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">class</span> <span class="title class_">LList</span>: <span class="keyword">public</span> List&lt;E&gt;&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Link&lt;E&gt;* head;  <span class="comment">// Pointer to list header</span></span><br><span class="line">    Link&lt;E&gt;* tail;  <span class="comment">// Pointer to last element</span></span><br><span class="line">    Link&lt;E&gt;* curr;  <span class="comment">// Pointer to current element</span></span><br><span class="line">    <span class="type">int</span> cnt;  <span class="comment">// Size of list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  <span class="comment">// Initialization helper method</span></span><br><span class="line">        curr = tail = head = <span class="keyword">new</span> Link&lt;E&gt;;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeall</span><span class="params">()</span></span>&#123;  <span class="comment">// Return link node to free store</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            curr = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LList</span>(<span class="type">int</span> size=defaultSize)&#123;<span class="built_in">init</span>(); &#125;  <span class="comment">// Constructor</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LList</span>()&#123;<span class="built_in">removeall</span>();&#125;  <span class="comment">// Destructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span> <span class="type">const</span></span>&#123;  <span class="comment">// Print list content</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">length</span>()!=<span class="number">0</span> &amp;&amp;<span class="string">&quot;Empty list&quot;</span>);</span><br><span class="line">        Link&lt;E&gt;* temp = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == tail)&#123;</span><br><span class="line">                std::cout &lt;&lt; temp-&gt;element;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; temp-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// temp不删除,最后指向的是tail指向的内存，不能释放.</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">removeall</span>(); <span class="built_in">init</span>(); &#125;  <span class="comment">// Clear List</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert &quot;it&quot; at current position</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; it)</span></span>&#123;</span><br><span class="line">        curr-&gt;next = <span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;(it, curr-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(tail == curr) tail = curr-&gt;next;  <span class="comment">// new tail</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> E&amp; it)</span></span>&#123;  <span class="comment">// Append &quot;it&quot; to list</span></span><br><span class="line">        tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;(it, <span class="literal">NULL</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove and return current element</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(curr-&gt;next != <span class="literal">NULL</span>  &amp;&amp; <span class="string">&quot;No element&quot;</span>);</span><br><span class="line">        E it = curr-&gt;next-&gt;element;  <span class="comment">// Remember value</span></span><br><span class="line">        Link&lt;E&gt;* ltemp = curr-&gt;next;  <span class="comment">// Remember link node</span></span><br><span class="line">        <span class="keyword">if</span>(tail == curr-&gt;next) tail = curr;  <span class="comment">// Reset tail</span></span><br><span class="line">        curr-&gt;next = curr-&gt;next-&gt;next;  <span class="comment">// Remove from list</span></span><br><span class="line">        <span class="keyword">delete</span> ltemp;  <span class="comment">// Reclaim space</span></span><br><span class="line">        cnt--;  <span class="comment">// Decrement the count</span></span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToStart</span><span class="params">()</span></span>&#123;  <span class="comment">// Place curr at list start</span></span><br><span class="line">        curr = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToEnd</span><span class="params">()</span></span>&#123;  <span class="comment">// Place curr at list end</span></span><br><span class="line">        curr = tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move curr one step left; no change if already at front</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prev</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == head) <span class="keyword">return</span>;</span><br><span class="line">        Link&lt;E&gt;* temp = head;</span><br><span class="line">        <span class="comment">// March down list until we find the previous element</span></span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != curr)temp = temp-&gt;next;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move curr one step right; no change if already at end</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == tail) <span class="keyword">return</span>;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the position of the current element</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">currPos</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        Link&lt;E&gt;*temp = head;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; temp!=curr; i++)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move down list to &quot;pos&quot; position</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToPos</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((pos&gt;=<span class="number">0</span>)  &amp;&amp; (pos&lt;=cnt) &amp;&amp; <span class="string">&quot;Position out of range&quot;</span>);</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pos; i++)&#123;curr = curr-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> E&amp; <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(curr-&gt;next != <span class="literal">NULL</span> &amp;&amp;<span class="string">&quot;No value&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> curr-&gt;next-&gt;element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-12">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ListADT.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ListADT.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LList&lt;<span class="type">int</span>&gt;<span class="built_in">L</span>(<span class="number">100</span>);</span><br><span class="line">    L.<span class="built_in">append</span>(<span class="number">3</span>);</span><br><span class="line">    L.<span class="built_in">append</span>(<span class="number">4</span>);</span><br><span class="line">    L.<span class="built_in">append</span>(<span class="number">5</span>);</span><br><span class="line">    L.<span class="built_in">printList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>3 4 5</p>
</blockquote>
<h5 id="参考-7">参考</h5>
<p><em>Data Structures and Algorithms in C++</em></p>
<p><em>Data Structures and Algorithm Analysis in C++</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark On Cloud</title>
    <url>/2020/12/19/Spark-On-Cloud/</url>
    <content><![CDATA[<h1>Overview</h1>
<p>起因是实验需要用到Spark集群，然而目前只有本地Linux搭的一台伪分布式，所以打算用云服务器搭建。好在腾讯和阿里都有相关的服务，所以可以很简单的把集群搭建起来，在测试过之后，感觉腾讯云的服务更好使用。</p>
<h1>腾讯云</h1>
<p>腾讯云的产品是<a href="https://console.cloud.tencent.com/emr">弹性 MapReduce</a>, 开始是选硬件配置，设置私网和子网以及授权的操作，过程计较简单。</p>
<p>此外，Master和各Worker节点的Python均有两个版本的Python, 分别是Python2(默认PySpark启动这个)和Python3。因为要用到的是Python3的环境，而且需要Numpy和Pandas这些库，所以打算<strong>装Anaconda来管理Python环境，并设置为PySpark启动环境</strong>。</p>
<p>步骤如下：</p>
<ol>
<li>首先SSH登录到Master节点(设置弹性公网IP即可登录)</li>
<li>下载Anaconda安装文件到Master节点，可以<code>wget https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh -O ~/anaconda.sh</code>（参考<a href="https://docs.anaconda.com/anaconda/install/silent-mode/">文档</a>）或者本地下载后通过FileZilla等FTP工具上传；同时将<code>anaconda.sh</code>文件上传到HDFS：<code>hdfs dfs -mkdir /user/hadoop/installdata</code>（创建目录）， <code>hdfs dfs -put ~/anaconda.sh /user/hadoop/installdata</code>（上传到HDFS，供子节点使用）</li>
<li>在Master节点和Worker节点分别安装Anaconda。注意，每个节点下默认有两个用户：root和hadoop。我们一般将所有的操作在hadoop用户下执行。通过<code>su hadoop</code>, <code>cd</code>, <code>hdfs dfs -get /user/hadoop/installdata/anaconda.sh</code>将<code>anaconda.sh</code>拉取到本地的<code>/home/hadoop/</code>路径，之后执行<code>bash anaconda.sh</code>根据提示安装即可。安装成功后我们需要的Python就在目录<code>/home/hadoop/anaconda3/bin/python</code>之下。</li>
<li>参考<a href="https://aws.amazon.com/premiumsupport/knowledge-center/emr-pyspark-python-3x/">AWS文档</a>, 在Master节点中，在<code>/usr/local/service/spark/conf/spark-env.sh</code>最后加入<code>export PYSPARK_PYTHON=/home/hadoop/anaconda3/bin/python</code>， 在<code>/usr/local/service/spark/bin/pyspark</code>中将<code>export PYSPARK_DRIVER_PYTHON</code>改为<code>export PYSPARK_DRIVER_PYTHON=/home/hadoop/anaconda3/bin/python</code>即可。(Worker节点不需要额外设置)</li>
<li>这时候在Master直接执行<code>pyspark</code>即可拉起我们Anaconda管理的Python3.</li>
</ol>
<blockquote>
<p>这里通过设置引导的方式来统一搭建的Anaconda环境没有测试成功，有两点需要注意：</p>
<ol>
<li>腾讯云的引导操作必须在<strong>创建集群或者扩容</strong>的时候才会自动执行引导脚本(集群搭建好之后好像没有办法重启执行引导操作； 修改spark和hdfs的配置文件倒是可以重启服务使其改动生效的)</li>
<li>Worker节点没有设置弹性公网IP的话是不能访问外网的，也就是说引导操作里面执行<code>wget</code>的话，只有Master节点可以成功下载文件，Worker节点无法下载。(可以在各个节点的<code>/usr/local/service/scripts/</code>文件夹下看到脚本执行的状态)</li>
</ol>
</blockquote>
<p>此外，腾讯云弹性MapReduce服务明显更容易使用，弹性公网IP，安全组设置以及利用Knox来访问YARN UI，Spark UI等都十分方便，几乎不需要额外设置就能立即使用，基本上没什么延迟。</p>
<h1>阿里云</h1>
<p>阿里云的产品是<a href="https://emr.console.aliyun.com/?spm=5176.12818093.nav-right.81.6ec716d0AGWwMK#/cn-qingdao">E-MapReduce</a>, 开始创建集群的操作和腾讯云基本是一致的，只不过弹性公网IP的绑定不是默认的，需要手动创建并绑定。之后的安全组和授权操作也基本一致。</p>
<p>最后没有用阿里云，原因是文档过于拉胯，页面反应也慢的很(最烦的是隔一会就要重新验证登录状态)。其他的配置也很混乱，尤其是Knox用户的配置，文档写的很模糊，地址怎么也打不开。提工单回复又慢的一匹…最主要的，还比腾讯云贵(摔…)所以就放弃了。</p>
<h1>用服务器自己搭建</h1>
<p>用服务器自己搭建分布式集群。前不久自己用实验室的一台服务器搭建了一个伪分布式集群。整个流程很简单，先安装JAVA, 之后Hadoop, 之后Spark。 最后设置一下PySpark启动用的Python环境，YARN配置下可用于分配的集群资源(内存与逻辑核数)。</p>
<p>因为服务器是绑定了公网IP的，所以全程就是SSH连起来安装的。但是我本地怎么PING都PING不同，当然对应的4040和8088等端口也没办法访问。好在VSCODE的Remote - SSH插件很好用，可以自动做前向代理。所以在VSCODE登录到机器，然后自动前向代理后，就可以在本电脑直接访问对应4040和8088等端口了！</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>PySpark</tag>
      </tags>
  </entry>
  <entry>
    <title>Stacks</title>
    <url>/2017/05/10/Stacks/</url>
    <content><![CDATA[<h4 id="Overview-49">Overview</h4>
<p>继前面单双链表之后，再来学习下Stacks.教材还是参考<em>Data Structure and Algorithms in c++</em>。下面是普通栈的实现和list在栈的应用。最后，实现了书中提到的大数的相加算法。</p>
<h4 id="Code-43">Code</h4>
<h5 id="Stacks">Stacks</h5>
<h6 id="genStack-h">genStack.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_GENSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_GENSTACK_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> capacity=<span class="number">30</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt;pool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>()&#123;</span><br><span class="line">        pool.<span class="built_in">reserve</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        pool.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !pool.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">topEl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            T el = pool.<span class="built_in">back</span>();</span><br><span class="line">            pool.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> el;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; el)</span></span>&#123;</span><br><span class="line">        pool.<span class="built_in">push_back</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印stack</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printstack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">typename</span> std::vector&lt;T&gt;::iterator i = pool.<span class="built_in">end</span>()<span class="number">-1</span>; i != pool.<span class="built_in">begin</span>()<span class="number">-1</span>; i--)&#123;</span><br><span class="line">            std::cout&lt;&lt;*i&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取stack长度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getsize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pool.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_GENSTACK_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-13">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genStack.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt;S;</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    S.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    S.<span class="built_in">printstack</span>();</span><br><span class="line"></span><br><span class="line">    S.<span class="built_in">pop</span>();</span><br><span class="line">    S.<span class="built_in">printstack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Stack:<br>
3<br>
2<br>
1<br>
Stack:<br>
2<br>
1</p>
</blockquote>
<h5 id="List-Stacks">List Stacks</h5>
<h6 id="genListStack-h">genListStack.h</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CPPPROJECTS_GENLISTSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPPPROJECTS_GENLISTSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LLStack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;T&gt;lst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LLStack</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lst.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">topEl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T el = lst.<span class="built_in">back</span>();</span><br><span class="line">        lst.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp;el)</span></span>&#123;</span><br><span class="line">        lst.<span class="built_in">push_back</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLLStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list&lt;T&gt;reverse_lst = lst;</span><br><span class="line">        reverse_lst.<span class="built_in">reverse</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;T&gt;::iterator i = reverse_lst.<span class="built_in">begin</span>(); i != reverse_lst.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            std::cout&lt;&lt;*i&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CPPPROJECTS_GENLISTSTACK_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="main-cpp-14">main.cpp</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genListStack.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    LLStack&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line">    lst.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    lst.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    lst.<span class="built_in">printLLStack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>3<br>
2</p>
</blockquote>
<h5 id="Application1-Big-numbers’-adding">Application1: Big numbers’ adding</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;genListStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushStringToStack</span><span class="params">(Stack&lt;<span class="type">int</span>&gt;&amp;num, string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        num.<span class="built_in">push</span>(<span class="built_in">int</span>(s[i])<span class="number">-48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout&lt;&lt;v[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getNumFromVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v)</span></span>&#123;</span><br><span class="line">    string number_str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        number_str += std::<span class="built_in">to_string</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bigNumPlus</span><span class="params">(string m, string n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 分别将字符串放入数组</span></span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; num1, num2;</span><br><span class="line">    <span class="built_in">pushStringToStack</span>(num1, m);</span><br><span class="line">    <span class="built_in">pushStringToStack</span>(num2, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_len = <span class="built_in">max</span>(num1.<span class="built_in">getsize</span>(), num2.<span class="built_in">getsize</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> next_plus_one = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max_len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1 = num1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x2 = num2.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;x1&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;x2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x12;</span><br><span class="line">        <span class="keyword">if</span>(next_plus_one) x12 = x1 + x2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x12 = x1 + x2;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x12&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否进位</span></span><br><span class="line">        <span class="keyword">if</span>(x12 &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            next_plus_one = <span class="literal">true</span>;</span><br><span class="line">            x12 -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> next_plus_one = <span class="literal">false</span>;  <span class="comment">//重置</span></span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push_back</span>(x12);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">m</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span>, <span class="title">n</span><span class="params">(<span class="string">&quot;12345678910&quot;</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">bigNumPlus</span>(m, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    printvector(result);</span></span><br><span class="line">    string number_str = <span class="built_in">getNumFromVector</span>(result);</span><br><span class="line">    cout&lt;&lt;number_str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>9  0 9<br>
8  1 9<br>
7  9 16<br>
6  8 15<br>
5  7 13<br>
4  6 11<br>
3  5 9<br>
2  4 6<br>
1  3 4<br>
0  2 2<br>
0  1 1<br>
12469135699</p>
</blockquote>
<h5 id="Application2-Reverse-the-string">Application2:Reverse the string</h5>
<p>这里，我们介绍两种应用stack来反转字符串的方法，第一种借助stack（未用自己写的，用的STL）；第二种是通过两个变量来标记字符串的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time-complexity O(n)</span></span><br><span class="line"><span class="comment">// sapce-complexity O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyReverseS</span><span class="params">(<span class="type">char</span> C[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// get length</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(C);</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line">    <span class="comment">// push</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(C[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        C[i] = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time-complexity O(n)</span></span><br><span class="line"><span class="comment">// sapce-complexity O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyReverseS_plus</span><span class="params">(<span class="type">char</span> C[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">strlen</span>(C)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i, j; i&lt;=j; i++, j--)&#123;<span class="comment">// 这里终止条件不能为i!=j,在长度为偶数时会出错</span></span><br><span class="line">        <span class="type">char</span> temp = C[i];</span><br><span class="line">        C[i] = C[j];</span><br><span class="line">        C[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> MyStrting[<span class="number">50</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; MyStrting;</span><br><span class="line">    <span class="built_in">MyReverseS_plus</span>(MyStrting);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Output = &quot;</span>&lt;&lt;MyStrting&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>Enter a string: datahonoe<br>
Output = eonohatad</p>
</blockquote>
<p>同样地，我们也可以使用stack反转一个linked list.</p>
<h5 id="Application3-check-for-balanced-parentheses">Application3: check for balanced parentheses</h5>
<p>我们也可以用stack写一个检查括号是否平衡的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是不是左括号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkclosing</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> c==<span class="string">&#x27;[&#x27;</span> <span class="keyword">or</span> c==<span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是不是右括号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkenclosing</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c==<span class="string">&#x27;)&#x27;</span> <span class="keyword">or</span> c==<span class="string">&#x27;]&#x27;</span> <span class="keyword">or</span> c==<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c1==<span class="string">&#x27;(&#x27;</span> &amp;&amp; c2== <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c1==<span class="string">&#x27;[&#x27;</span> &amp;&amp; c2== <span class="string">&#x27;]&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c1==<span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c2== <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否平衡</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CheckBalance</span><span class="params">(<span class="type">char</span> C[])</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;S;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkclosing</span>(C[i])) &#123;</span><br><span class="line">            S.<span class="built_in">push</span>(C[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">checkenclosing</span>(C[i]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.<span class="built_in">empty</span>() || !<span class="built_in">Match</span>(S.<span class="built_in">top</span>(), C[i])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the string</span></span><br><span class="line">    <span class="type">char</span> Mstring[<span class="number">50</span>];</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; Mstring;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">CheckBalance</span>(Mstring);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>Enter a string: datahonor<br>
1</p>
</blockquote>
<h4 id="Reference-12">Reference</h4>
<p><a href="https://www.youtube.com/watch?v=hNP72JdOIgY&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=17">YouTube</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>The Speed of Numpy</title>
    <url>/2017/03/06/The-Speed-of-Numpy/</url>
    <content><![CDATA[<h5 id="Overview-50">Overview</h5>
<p>实现算法时，越发觉得，Numpy对效率的影响特别大，所以再次学习。<br>
这里主要是进行数组运算速度的对比，对原文代码稍加改进，更直观地看到速度上的差别。</p>
<h5 id="Code-44">Code</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">numpysum</span>(<span class="params">n</span>):</span><br><span class="line">    a = np.arange(n)**<span class="number">2</span></span><br><span class="line">    b = np.arange(n)**<span class="number">3</span></span><br><span class="line">    c  =a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pythonsum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 这里由于源码为Python2的，range的用法可能有变</span></span><br><span class="line">    <span class="comment"># 直接运行报错TypeError: &#x27;range&#x27; object does not support item assignment</span></span><br><span class="line">    <span class="comment"># 故转化为列表</span></span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">    b = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        a[i] = i ** <span class="number">2</span></span><br><span class="line">        b[i] = i ** <span class="number">3</span></span><br><span class="line">        c.append(a[i] + b[i])</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="comment"># prt表示是否打印结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printest</span>(<span class="params">func, size, prt=<span class="literal">True</span></span>):</span><br><span class="line">    start = datetime.now()</span><br><span class="line">    c = func(size)</span><br><span class="line">    delta = datetime.now() - start</span><br><span class="line">    <span class="keyword">if</span> prt==<span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The last 2 elements of the sum &quot;</span>, c[-<span class="number">2</span>:])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Elapsed time in microsecondas &#x27;</span>, delta.microseconds)</span><br><span class="line">    <span class="keyword">return</span> delta.microseconds</span><br><span class="line"><span class="comment"># 用于作n-time图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeplot</span>():</span><br><span class="line">    pts = []</span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">10000</span>, <span class="number">100</span>):</span><br><span class="line">        t_numpy = printest(numpysum, i, prt=<span class="literal">False</span>)</span><br><span class="line">        t_python = printest(pythonsum, i, prt=<span class="literal">False</span>)</span><br><span class="line">        pts.append([t_numpy, t_python])</span><br><span class="line">        x.append(i)</span><br><span class="line">    plt.plot(x, pts)</span><br><span class="line">    plt.legend([<span class="string">&#x27;Numpy&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    size = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Numpysum...&#x27;</span>)</span><br><span class="line">    printest(numpysum, size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Pythonsum...&#x27;</span>)</span><br><span class="line">    printest(pythonsum, size)</span><br><span class="line">    timeplot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>python <a href="http://Speed.py">Speed.py</a> 10000</p>
</blockquote>
<p>输出：</p>
<blockquote></blockquote>
<p>Numpysum…<br>
The last 2 elements of the sum  [999500079996 999800010000]<br>
Elapsed time in microsecondas  1299<br>
Pythonsum…<br>
The last 2 elements of the sum  [999500079996, 999800010000]<br>
Elapsed time in microsecondas  18202</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051902.png" alt=""></p>
<p>可以看到，相比pure python， Numpy在大规模的运算上具有极高的效率。</p>
<h5 id="Supplement-7">Supplement</h5>
<p>关于做图的补充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], l)</span><br><span class="line">plt.legend([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051903.png" alt=""></p>
<h5 id="Reference-13">Reference</h5>
<p><em>NumPy Beginner’s Guide [Second Edition]</em> <em>Page19</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Three Doors &amp; Three Prisoners</title>
    <url>/2017/09/08/Three-Doors-Three-Prisoners/</url>
    <content><![CDATA[<h4 id="Overview-51">Overview</h4>
<p>在看<em>Statistical Inference</em>的时候，看到Three Prisoners的问题时，没看太懂，因为问题的描述略简单。。。于是为wiki查了下，又把之前看到的Three Doors放在一起。</p>
<h4 id="Three-Doors-Problems">Three Doors Problems</h4>
<p>三门问题，又叫Monty Hall problem， 来自一个电视节目，规则如下（具体参见<a href="https://en.wikipedia.org/wiki/Monty_Hall_problem">wiki</a>）：</p>
<blockquote>
<p>Suppose you’re on a game show, and you’re given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what’s behind the doors, opens another door, say No. 3, which has a goat. He then says to you, “Do you want to pick door No. 2?” Is it to your advantage to switch your choice?</p>
</blockquote>
<p>里面有很多解释，简单讲就是：</p>
<blockquote>
<p>按照规则，如果在主持人询问后选择转换，那么最后得到的奖品必然是和初始选择到的奖品是不同的。所以只要是选择转换，那么第一次选中山羊的概率就是最后得到汽车的概率，为2/3；反之，只要选择不动，那么第一次选择得到的奖品就是最后得到的，所以得到汽车的概率为1/3.因此，选择转换，会使得得到汽车的概率提高一倍。</p>
</blockquote>
<h4 id="Three-Prisoners-Problems">Three Prisoners Problems</h4>
<p>问题描述如下，具体参见<a href="https://en.wikipedia.org/wiki/Three_Prisoners_problem">wiki</a>：</p>
<blockquote>
<p>Three prisoners, A, B and C, are in separate cells and sentenced to death. The governor has selected one of them at random to be pardoned. The warden knows which one is pardoned, but is not allowed to tell. Prisoner A begs the warden to let him know the identity of one of the others who is going to be executed. “If B is to be pardoned, give me C’s name. If C is to be pardoned, give me B’s name. And if I’m to be pardoned, flip a coin to decide whether to name B or C.”</p>
</blockquote>
<blockquote>
<p>The warden tells A that B is to be executed. Prisoner A is pleased because he believes that his probability of surviving has gone up from 1/3 to 1/2, as it is now between him and C. Prisoner A secretly tells C the news, who is also pleased, because he reasons that A still has a chance of 1/3 to be the pardoned one, but his chance has gone up to 2/3. What is the correct answer?</p>
</blockquote>
<p>感觉枚举的方法不如用贝叶斯来得简单：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/Screenshot%20from%202017-09-08%2012-25-24.png" alt=""></p>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux</title>
    <url>/2020/01/21/Tmux/</url>
    <content><![CDATA[<h1>Tmux</h1>
<p>分屏工具<a href="https://github.com/tmux/tmux">Tmux</a>使用记录。</p>
<h2 id="安装-5">安装</h2>
<p>首先安装就是直接<code>sudo apt-get install tmux</code>安装的，所以版本比较旧(V2.1),最新版可以直接从Github源码安装。</p>
<h2 id="配置">配置</h2>
<p>直接<a href="https://github.com/gpakosz/.tmux">.tmux</a>,即执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br></pre></td></tr></table></figure>
<p>导入配置，之后设置鼠标开启，同时将<code>Ctrl+b</code>的绑定改为<code>Ctrl+a</code>，然后重启终端。</p>
<blockquote>
<p>注意到一点，就是导入这个配置后，直接重启终端好像不行。要把之前开启的tmux session全部kill掉再重启终端才可以。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04LTS下安装Hadoop&amp;Spark</title>
    <url>/2017/03/08/Ubuntu16-04LTS%E4%B8%8B%E5%AE%89%E8%A3%85Hadoop2-7-3/</url>
    <content><![CDATA[<h3 id="1-安装Hadoop2-7-3">1. 安装Hadoop2.7.3</h3>
<blockquote>
<p>写的比较早，可能已经不可行，仅供参考，3.0以上新版的安装在后面。</p>
</blockquote>
<p>主要就是参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-hadoop-in-stand-alone-mode-on-ubuntu-16-04">digitalocean</a>的这篇教程，写的十分详细，这里不再赘述。要注意的一点就是在<em>Step 3 — Configuring Hadoop’s Java Home</em>这里，按照教程上的方法找到JAVA的路径再设置，两种方法均可以运行Hadoop，但是在后面运行MapReduce时却总是报错：</p>
<blockquote>
<p>/usr/local/hadoop/bin/hadoop: line 166: /usr/bin/java: No such file or directory</p>
</blockquote>
<p>好象是JAVA的路径不对，之前设置的是</p>
<blockquote>
<p>export JAVA_HOME=/usr/</p>
</blockquote>
<p>就重新找到JAVA的安装路径，设置为</p>
<blockquote>
<p>export JAVA_HOME=/usr/jdk-8/jre/</p>
</blockquote>
<p>然后就可以了。<br>
装好了，之后忙完这阵，就先学个入门: - )</p>
<h3 id="2-安装Hadoop3-Spark">2. 安装Hadoop3&amp;Spark</h3>
<p>参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-hadoop-in-stand-alone-mode-on-ubuntu-16-04">digitalocean</a>和<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">官方文档</a>安装即可。</p>
<blockquote>
<p>注意下载hadoop的时候不要下错了…在<a href="https://archive.apache.org/dist/hadoop/common/hadoop-3.0.1/">这里</a>,下载<code>hadoop-3.0.1.tar.gz </code>文件。</p>
</blockquote>
<p>安装和测试过程中遇到的问题及其解决办法。</p>
<h4 id="2-1-Setup-passphraseless-ssh">2.1 Setup passphraseless ssh</h4>
<p>官方文档<code>Setup passphraseless ssh</code>步设置无密码登录<code>localhost</code>出错<a href="https://askubuntu.com/questions/762541/ubuntu-16-04-ssh-sign-and-send-pubkey-signing-failed-agent-refused-operation">ssh: sign_and_send_pubkey: signing failed: agent refused operation</a>，参考对应链接执行<code>ssh-add</code>解决。</p>
<h4 id="2-2-Execution-sbin-start-dfs-sh">2.2 Execution: sbin/start-dfs.sh</h4>
<p>官方文档执行<code>sbin/start-dfs.sh</code>出错，参考[<a href="https://stackoverflow.com/questions/42756555/permission-denied-error-while-running-start-dfs-sh">Permission Denied error while running start-dfs.sh</a>](<a href="https://stackoverflow.com/questions/42756555/permission-denied-error-while-running-start-dfs-sh">https://stackoverflow.com/questions/42756555/permission-denied-error-while-running-start-dfs-sh</a>),执行<code>export PDSH_RCMD_TYPE=ssh</code>解决。</p>
<h4 id="2-3-Execution-bin-hdfs-dfs-mkdir-input">2.3 Execution: bin/hdfs dfs -mkdir input</h4>
<p>官方文档执行<code>bin/hdfs dfs -mkdir input</code>出错。参考<a href="https://stackoverflow.com/questions/40143528/hdfs-dfs-mkdir-no-such-file-or-directory">hdfs dfs -mkdir, No such file or directory</a>,执行<code>hdfs dfs -mkdir -p xxx</code>解决。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu命令积累</title>
    <url>/2017/03/02/Ubuntu%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h5 id="查看CPU及内存">查看CPU及内存</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">或者</span><br><span class="line">sudo apt-get install htop</span><br><span class="line">htop</span><br></pre></td></tr></table></figure>
<h5 id="查看网络">查看网络</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看网卡</span><br><span class="line">​ ifconfig</span><br><span class="line"># 查看网络状况</span><br><span class="line">​ sudo apt-get install slurm</span><br><span class="line">​ slurm -i wlan0    # wlan0是指定的网卡</span><br></pre></td></tr></table></figure>
<h5 id="重启-关闭网络服务">重启&amp;关闭网络服务</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重启</span><br><span class="line">service network-manager restart</span><br><span class="line"></span><br><span class="line"># 关闭</span><br><span class="line">service network-manager stop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发现中大校园网认证在Linux客户端会先停掉network-manager再进行认证。开始还可以正常连接上网，后面连接成功了但是无法上网，重启下network-manager之后再连接可以。</p>
</blockquote>
<h5 id="登录到远程服务器">登录到远程服务器</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -l root 45.77.14.149</span><br></pre></td></tr></table></figure>
<p>指定端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -l root -p 45.77.14.149</span><br></pre></td></tr></table></figure>
<p>退出ssh登录： <code>logout</code></p>
<p>另外，<a href="https://www.cnblogs.com/mexinyan/p/9700252.html">Vultr 修改 Root 密码</a></p>
<h5 id="设置环境变量-2">设置环境变量</h5>
<p>参考<a href="http://www.th7.cn/system/lin/201605/164198.shtml">这里</a></p>
<h6 id="临时设置">临时设置</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=路径:$PATH</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，上面<code>export</code>语句是在终端执行。</p>
</blockquote>
<h6 id="用户环境变量">用户环境变量</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit  ~/.profile</span><br><span class="line">export PATH=路径:$PATH</span><br><span class="line">source .profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面<code>export</code>语句是要加到打开的文件中</p>
</blockquote>
<p>此外也可以修改<code>~/.bashrc</code>文件，和修改<code>~/.profile</code>是一样的，实际上以上~/.profile文件中有这两句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -f &quot;$HOME/.bashrc&quot; ]; then</span><br><span class="line"> . &quot;$HOME/.bashrc&quot;</span><br></pre></td></tr></table></figure>
<p>注意，如果使用<code>zsh</code>可能需要修改<code>~/.zshrc</code>，见下文。</p>
<h6 id="系统-所有用户-环境变量">系统[所有用户]环境变量</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br><span class="line">export PATH=路径:$PATH</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面<code>export</code>语句是要加到打开的文件中</p>
</blockquote>
<p>参考<a href="https://www.jianshu.com/p/12fbfa8c7489">这里</a></p>
<h5 id="bashrc-or-zshrc"><code>~/.bashrc</code> or <code>~/.zshrc</code></h5>
<p>在使用<code>bash</code>（<code>exec bash</code>切换到<code>bash</code>）的时候是修改<code>~/.bashrc</code>文件做一些配置（比如alias等）；在使用<code>zsh</code>（<code>exec zsh</code>切换到<code>zsh</code>）的时候要改<code>~/.zshrc</code>文件.</p>
<p>参考<a href="https://stackoverflow.com/questions/26616003/shopt-command-not-found-in-bashrc-after-shell-updation">stackoverflow</a></p>
<h5 id="查看-特定程序-线程">查看[特定程序]线程</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -eLf|grep python[指定程序]</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Ubuntu/2.png" alt=""><br>
可以看到有三个Python线程在运行。</p>
<p>关于ps -eLf:<a href="http://outprog.github.io/blog/2015/10/15/ubuntu-14-dot-04-shi-yong-cron-shi-xian-ji-hua-ren-wu/">参考这里</a>：</p>
<blockquote>
<p>输出按顺序为：UID PID PPID LWP C NLWP STIME TTY TIME CMD</p>
</blockquote>
<blockquote>
<p>LWP　light weight process ID 可以称其为线程ID。<br>
NLWP 进程中的线程数number of lwps (threads) in the process。</p>
</blockquote>
<h5 id="Ubuntu计划任务之crontab">Ubuntu计划任务之crontab</h5>
<p>参考<a href="http://outprog.github.io/blog/2015/10/15/ubuntu-14-dot-04-shi-yong-cron-shi-xian-ji-hua-ren-wu/">这里</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e </span><br><span class="line">30 7 * * * run-parts /home   #每天7：30运行 /home 目录下的所有脚本</span><br></pre></td></tr></table></figure>
<p>具体到执行Python脚本的话参考<a href="http://blog.csdn.net/ybsun2010/article/details/9972403">这里</a>，就是如下的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/2 * * * * python /home/mytask/hello.py &gt;&gt; /home/mytask/hello.py.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>即，每两分钟执行/home/mytask目录下的hello.py脚本, 并将执行的log写入hello.py.log文件中。</p>
<p>hello.py如下：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Ubuntu/3.png" alt=""></p>
<p>crontab -e 后的添加：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Ubuntu/4.png" alt=""><br>
log文件如下：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Ubuntu/5.png" alt=""></p>
<h5 id="Ubuntu安装中文字体">Ubuntu安装中文字体</h5>
<p>参考<a href="http://blog.csdn.net/up_com/article/details/51218458">这里</a>.<br>
由于我是双系统，直接从win10里面C:/Windows/Fonts/目录下面，将所有字体文件都复制下来到</p>
<blockquote>
<p>/home/shen/Downloads/font</p>
</blockquote>
<p>再用cp命令：</p>
<blockquote>
<p>sudo cp -r /home/shen/Downloads/font /usr/share/fonts/</p>
</blockquote>
<p>最后：</p>
<blockquote>
<p>sudo mkfontscale<br>
sudo mkfontdir<br>
sudo fc-cache -fv</p>
</blockquote>
<h5 id="为浏览器安装安装flash插件">为浏览器安装安装flash插件</h5>
<p>之前手动装过一次，最近提示过期，换了种方法安装，参考<a href="http://www.linuxidc.com/Linux/2016-05/131098.htm">这里</a></p>
<h5 id="标题栏实时显示上下行网速、CPU及内存使用率">标题栏实时显示上下行网速、CPU及内存使用率</h5>
<blockquote>
<p>sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor<br>
sudo apt-get update<br>
sudo apt-get install indicator-sysmonitor</p>
</blockquote>
<p>安装完成后，启动：</p>
<blockquote>
<p>indicator-sysmonitor</p>
</blockquote>
<p>在General设置开机启动，并在Advance设置要显示的参数即可。</p>
<p>参考<a href="http://blog.csdn.net/tecn14/article/details/24489031">这里</a></p>
<h5 id="挽救-boot-清除image">挽救<code>/boot</code>,清除image</h5>
<p>Linux的内核是不断更新的，但是Ubuntu（debian也是）是不会自动清理之前的内核的，所以boot的空间就会慢慢堆满。</p>
<p>可以使用<code>df -h</code>来看下空间的使用情况。</p>
<p>查看已经安装的内核：</p>
<p><code>sudo dpkg --get-selections |grep linux-image</code></p>
<p>查看自己正在使用的内核：</p>
<p><code>uname -a</code></p>
<p>可以将比较早的删除，留下最近的几个，删除命令如下：</p>
<blockquote>
<p>sudo apt-get remove linux-image-4.4.0-57-generic<br>
sudo apt-get remove linux-image-4.4.0-59-generic<br>
sudo apt-get remove linux-image-extra-4.4.0-57-generic<br>
sudo apt-get remove linux-image-extra-4.4.0-59-generic</p>
</blockquote>
<blockquote>
<p>这里执行可能出现错误<code>E: Sub-process /usr/bin/dpkg returned an error code (1) </code>，可参考<a href="http://blog.csdn.net/qiaoji6073/article/details/76140146">这里</a>解决。</p>
</blockquote>
<p>有时候运行完上面的命令，再次查看已经安装的内核，会由原来的<code>install</code>变为<code>deinstall</code>,这时候可以将上面的<code>remove</code>换为<code>purge</code>清理下，如：</p>
<blockquote>
<p>sudo apt-get purge linux-image-4.4.0-57-generic</p>
</blockquote>
<p>参考：</p>
<p><a href="http://www.jb51.net/article/106976.htm">解决Ubuntu 16.04下提示boot分区空间不足的办法</a></p>
<p><a href="http://blog.csdn.net/wxyangid/article/details/53097208">ubuntu16.04 LTS解决/boot空间不足 </a></p>
<p><a href="http://blog.csdn.net/qq_27818541/article/details/72675954">/boot空间不足的解决办法 </a></p>
<h5 id="开机黑屏，光标闪烁">开机黑屏，光标闪烁</h5>
<p>用的Win10+Ubuntu16.04, 在Win上卸载一些软件，删了一些文件后发现再去启动Ubuntu就黑屏了，只有左上角的光标在闪。查了下是引导出了问题，重新回去Win用EasyBcd添加引导就可以了。</p>
<h5 id="防火墙">防火墙</h5>
<p>首先是测试远程主机的端口是否开启：<code>telnet 192.168.1.103 80</code><br>
查看本地的端口开启情况： <code>sudo ufw status</code><br>
打开80端口： <code>sudo ufw allow 80</code><br>
防火墙开启： <code>sudo ufw enable</code><br>
防火墙重启： <code>sudo ufw reload</code></p>
<h5 id="安装rpm文件">安装rpm文件</h5>
<p>参考<a href="https://linuxize.com/post/install-rpm-packages-on-ubuntu/">这里</a>, 方法是利用alien将其转化为deb文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install alien</span><br><span class="line">#将rpm转换位deb，完成后会生成一个同名的xxxx.deb </span><br><span class="line">sudo alien xxxx.rpm</span><br><span class="line">sudo dpkg -i xxxx.deb</span><br></pre></td></tr></table></figure>
<h5 id="修改ubuntu自带截图的默认保存路径">修改ubuntu自带截图的默认保存路径</h5>
<p>1.安装dconf-editor：<br>
<code>sudo apt-get install dconf-tools</code></p>
<p>2.打开系统自带搜索，搜dconf-editor打开</p>
<p>3.按照org-&gt;gnome-&gt;gnome-screenshot-&gt;auto-save-directory，修改value为需要的路径。</p>
<p>参考<a href="https://www.cnblogs.com/zhihaowu/p/8846479.html">这里</a></p>
<h5 id="增加用户">增加用户</h5>
<ol>
<li>终端执行：<code>adduser username</code></li>
<li>执行：<code>usermod -aG sudo username</code>（<a href="https://linuxize.com/post/how-to-create-a-sudo-user-on-ubuntu/#3-add-the-new-user-to-the-sudo-group">Add the new user to the <code>sudo</code> group</a>）</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu搭建SS</title>
    <url>/2017/03/02/Ubuntu%E6%90%AD%E5%BB%BASS/</url>
    <content><![CDATA[<h3 id="旧版">旧版</h3>
<p>S1:注册<a href="https://app.arukas.io/">arukas</a>帐号</p>
<p>S2:创建SS账户，参考<a href="http://www.iqcni.com/other/12.html">这里</a>。</p>
<p>S3：Ubuntu搭建SS客户端的GUI， 参考<a href="http://www.jianshu.com/p/4f6ea97427e9">这里</a>。</p>
<blockquote>
<p>sudo add-apt-repository ppa:hzwhuang/ss-qt5<br>
sudo apt-get update<br>
sudo apt-get install shadowsocks-qt5</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Ubuntu/1.png" alt=""></p>
<h3 id="更新">更新</h3>
<p>用上面的教程搭建的代理好早前就开始变卡了…后来就没再用了，不知道现在如何…</p>
<h4 id="Pan-foxyproxy">Pan --&gt; foxyproxy</h4>
<p>之前一直都是shadowsock5配合火狐的pan插件用，不过更新到新版的火狐后，pan已经不能用了，经推荐换了foxyproxy来用。配置过程比较简单，记得将IP和端口都设置成本地就行了（IP：127.0.0.1， 端口：1080）。而且，发现foxyproxy的pattern比较好用，把百度和本地地址放到Black List，访问百度会变得比较快，禁用本地地址更是方便…之前不论用hexo还是jupyter notebook都是手动把pan关了的orz…现在是方便许多~</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu跳坑记录——环境变量，不存在的</title>
    <url>/2017/08/22/Ubuntu%E8%B7%B3%E5%9D%91%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/</url>
    <content><![CDATA[<p>嗯，本来是一个平静的夜晚，开始搬砖，打开终端，嗯。。说.bashrc文件有问题，但是没什么影响。但是看着难受啊，开始改，开始Google, 发现一条看似平淡的命令[不要试orz…]：</p>
<blockquote>
<p>cp /etc/skel/.bashrc ~/</p>
</blockquote>
<p>运行，可以了，不出错了！开始干活，运行Ipython，挂了，conda挂了，hexo挂了…<br>
之后一阵乱搜，发现基本无解了。因为是覆盖的，不是删除的，根本无从找回原文件。但是这里也认识到一个问题，后来发现同样的问题，有的答案给出的就有先备份文件的命令，但是我第一次遇见的并没有让备份…继续乱搜，运行，发现sudo, ls,基本全部挂了…</p>
<p>嗯，还是学到一点，上面的命令可以恢复默认配置的,所以恢复之后sudo, ls也就能使用了。突然想到，之前Ubuntu无限Login也是环境变量写错了格式，而且后来的情况也是一样的(就是sudo, ls也乱套了)。</p>
<p>到Linux群问了问，基本上没有好的办法。于是开始手动添加环境变量(编辑文件/home/shensir/.bashrc，最后追加)。</p>
<blockquote>
<p>conda  path：加入export PATH=“/home/shensir/anaconda3/bin:$PATH”，参考<a href="https://askubuntu.com/questions/817938/changing-bashrc-file-for-anaconda">这里</a></p>
<p>node, npm: 没有找到原来的路径，直接重新装的（目前未出现冲突问题），参考<a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions">这里</a>。其实也就两条命令，非常方便，一次运行成功。<br>
<code>curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</code><br>
<code>sudo apt-get install -y nodejs</code></p>
</blockquote>
<blockquote>
<p>hexo：在原hexo文件夹的根目录下直接运行安装命令 <code>sudo npm install hexo-cli -g</code>， 和之前提到的迁移是一样的，只安装，不要初始化。</p>
</blockquote>
<p>配置到此，基本上是恢复了一些常用的功能。不知道之后还会不会暴露出新的问题。先更到这里，我先重启看看…无限login就悲剧了。</p>
<p>回更，一切安好…</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/Screenshot%20from%202017-08-22%2023-58-36.png" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十二：Using colors for detection - skin tone detection</title>
    <url>/2017/05/02/Using-colors-for-detection-skin-tone-detection/</url>
    <content><![CDATA[<h5 id="Overview-52">Overview</h5>
<p>关于颜色空间，除了经常用的RGB和之前用于颜色比较的Lab,还有其他很多不同用途的种类。这里我们要检测皮肤，用到的颜色空间是<a href="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">HSV</a>. 原因如下：</p>
<blockquote>
<p>In general, to detect an object using color, you first need to collect a large database of image samples that contain the object captured from different viewing conditions. These will be used to define the parameters of your classifier. You also need to select the color representation that you will use for classification. For skin tone detection, many studies have shown that skin color from the diverse ethnical groups clusters well in the hue/saturation space. For this reason, we will simply use the hue and saturation values to identify the skin tones in the following image.</p>
</blockquote>
<p>显然，在下面的程序里出现的一些阀值也是来自于一些经验数据。</p>
<h5 id="Code-45">Code</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imageInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detectHScolor</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> minHue, <span class="type">double</span> maxHue,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> minSat, <span class="type">double</span> maxSat,</span></span></span><br><span class="line"><span class="params"><span class="function">                   cv::Mat&amp; mask)</span></span>&#123;</span><br><span class="line">    cv::Mat hsv;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, hsv, CV_BGR2HSV);</span><br><span class="line">    std::vector&lt;cv::Mat&gt;channels;</span><br><span class="line">    cv::<span class="built_in">split</span>(hsv, channels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hue masking</span></span><br><span class="line">    cv::Mat mask1;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(channels[<span class="number">0</span>], mask1, maxHue, <span class="number">255</span>,cv::THRESH_BINARY_INV);  <span class="comment">// 0~maxhue</span></span><br><span class="line">    cv::Mat mask2;</span><br><span class="line">    cv::<span class="built_in">threshold</span>(channels[<span class="number">0</span>], mask2, minHue, <span class="number">255</span>, cv::THRESH_BINARY);  <span class="comment">// minhue~180</span></span><br><span class="line"></span><br><span class="line">    cv::Mat hueMask;</span><br><span class="line">    <span class="keyword">if</span>(minHue&lt;maxHue)</span><br><span class="line">        hueMask = mask1 &amp; mask2;  <span class="comment">// minhue~maxhue</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// if interval crossed the zero-degrees axis</span></span><br><span class="line">        hueMask = mask1 | mask2;  <span class="comment">// 上面的注释是书上的，一时搞不懂这个else是什么意思...知道的朋友可留言告知...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saturation masking</span></span><br><span class="line">    <span class="comment">// between minSat and maxSat</span></span><br><span class="line">    cv::Mat satMask;</span><br><span class="line">    cv::<span class="built_in">inRange</span>(channels[<span class="number">1</span>], minSat, maxSat, satMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combined mask</span></span><br><span class="line">    mask = hueMask &amp; satMask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/girl.png&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, image);</span><br><span class="line">    <span class="comment">//detect skin tone</span></span><br><span class="line">    cv::Mat mask;</span><br><span class="line">    <span class="built_in">detectHScolor</span>(image, <span class="number">160</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">166</span>, mask);</span><br><span class="line">    <span class="function">cv::Mat <span class="title">detected</span><span class="params">(image.size(),CV_8UC3,cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    image.<span class="built_in">copyTo</span>(detected,mask);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Detected&quot;</span>, detected);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170502/Selection_004.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十六：Using the mean shift algorithm to find an object</title>
    <url>/2017/05/04/Using-the-mean-shift-algorithm-to-find-an-object/</url>
    <content><![CDATA[<h5 id="Overview-53">Overview</h5>
<p>在上一篇笔记<a href="http://datahonor.com/2017/05/04/Backprojecting-a-histogram-to/">OpenCV系列笔记十五：Backprojecting a histogram to detect specific image content </a>，我们了解了histogram backprojection的原理及用法。这里，我们在backprojection的基础上介绍一种新的算法，即mean shift。他用来在给定的模糊范围，精确定位一个已知histogram[从给定的ROI得到]的物体。来看下参考书的介绍：</p>
<blockquote>
<p>The result of a histogram backprojection is a probability map that expresses the probability that a given piece of image content is found at a specific image location. Suppose we now know the approximate location of an object in an image; the probability map can be used to find the exact location of the object. The most probable location will be the one that maximizes this probability inside a given window. Therefore, if we start from an initial location and iteratively move around in an attempt to increase the local probability measure, it should be possible to find the exact object location. This is what is accomplished by the <strong>mean shift algorithm</strong>.</p>
</blockquote>
<p>在看下文档对mean shift的介绍：</p>
<pre><code>/** @brief Finds an object on a back projection image.

@param probImage Back projection of the object histogram. See calcBackProject for details.
@param window Initial search window.
@param criteria Stop criteria for the iterative search algorithm.
returns
:   Number of iterations CAMSHIFT took to converge.
The function implements the iterative object search algorithm. It takes the input back projection of
an object and the initial position. The mass center in window of the back projection image is
computed and the search window center shifts to the mass center. The procedure is repeated until the
specified number of iterations criteria.maxCount is done or until the window center shifts by less
than criteria.epsilon. The algorithm is used inside CamShift and, unlike CamShift , the search
window size or orientation do not change during the search. You can simply pass the output of
calcBackProject to this function. But better results can be obtained if you pre-filter the back
projection and remove the noise. For example, you can do this by retrieving connected components
with findContours , throwing away contours with small area ( contourArea ), and rendering the
remaining contours with drawContours.

@note
-   A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp
 */
CV_EXPORTS_W int meanShift( InputArray probImage, CV_IN_OUT Rect&amp; window, TermCriteria criteria );
</code></pre>
<p>mean shift算法是根据已经生成的backprojection map，在给定的初始位置开始进行迭代搜索，直到前后centroid差值小于给定的阀值或者达到预先设定的最大迭代次数时停止迭代, 函数返回达到收敛时迭代的次数。</p>
<h5 id="Code-46">Code</h5>
<p>[colorhistogram.h和contentfinder.h在前一篇笔记已经给出]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;colorhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contentfinder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Read reference image</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/baboon01.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">// initial window position</span></span><br><span class="line">    <span class="function">cv::Rect <span class="title">rect</span><span class="params">(<span class="number">110</span>, <span class="number">45</span>, <span class="number">35</span>, <span class="number">45</span>)</span></span>;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, rect, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    <span class="comment">// Baboon&#x27;s face ROI</span></span><br><span class="line">    cv::Mat imageROI = <span class="built_in">image</span>(rect);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Image1&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image1&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the Hue histogram of baboon&#x27;s face</span></span><br><span class="line">    <span class="type">int</span> minSat = <span class="number">65</span>;</span><br><span class="line">    ColorHistogram hc;</span><br><span class="line">    cv::Mat colorhist = hc.<span class="built_in">getHueHistogram</span>(imageROI, minSat);</span><br><span class="line"></span><br><span class="line">    ContentFinder finder;</span><br><span class="line">    finder.<span class="built_in">setHistogram</span>(colorhist);</span><br><span class="line"></span><br><span class="line">    image = cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/baboon02.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to HSV space</span></span><br><span class="line">    cv::Mat hsv;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(image, hsv, CV_BGR2HSV);</span><br><span class="line">    <span class="comment">// Get back-projection of hue histogram</span></span><br><span class="line">    <span class="type">int</span> ch[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    finder.<span class="built_in">setThreshold</span>(<span class="number">-1.0f</span>); <span class="comment">// no thresholding</span></span><br><span class="line">    cv::Mat result = finder.<span class="built_in">find</span>(hsv, <span class="number">0.0f</span>, <span class="number">180.0f</span>, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial window position</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, rect, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    cv::Rect* prect = &amp;rect;</span><br><span class="line">    <span class="comment">// Search object with mean shift</span></span><br><span class="line">    <span class="function">cv::TermCriteria <span class="title">criteria</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            cv::TermCriteria::MAX_ITER | cv::TermCriteria::EPS,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="number">10</span>, <span class="comment">// iterate max 10 times</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="number">1</span>)</span></span>; <span class="comment">// or until the change in centroid position is less than 1px</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;meanshif= &quot;</span>&lt;&lt;cv::<span class="built_in">meanShift</span>(result, *prect, criteria)&lt;&lt;std::endl;</span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image, *prect , cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;image 2&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;image 2&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170504/Selection_050415%3A35%3A28.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Vectorization in R: Why?</title>
    <url>/2018/05/16/Vectorization-in-R-Why/</url>
    <content><![CDATA[<p>在看<em>The Art of R Programming</em>, 看到这里：</p>
<blockquote>
<p>One of the most effective ways to achieve speed in R code is to use oper-<br>
ations that are vectorized, meaning that a function applied to a vector is actu-<br>
ally applied individually to each element.</p>
</blockquote>
<p>对所谓向量化（vectorized）比较好奇，所以看了这篇<a href="http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html">Vectorization in R: Why?</a>,写的很好。</p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim Tips</title>
    <url>/2018/03/08/Vim-Tips/</url>
    <content><![CDATA[<h3 id="Install-Update">Install&amp;Update</h3>
<p><a href="https://github.com/vim/vim">Install</a><br>
<a href="https://www.linuxidc.com/Linux/2016-11/136816.htm">Update</a></p>
<h3 id="Plugins">Plugins</h3>
<p><a href="https://github.com/VundleVim/Vundle.vim#about">Vundle(plugin manager)</a></p>
<p><a href="https://github.com/Valloric/YouCompleteMe#ubuntu-linux-x64">YouCompleteMe</a></p>
<h3 id="Tips-2">Tips</h3>
<h4 id="Keep-your-cursor-centered-vertically-on-the-screen"><a href="http://vim.wikia.com/wiki/Keep_your_cursor_centered_vertically_on_the_screen">Keep your cursor centered vertically on the screen</a></h4>
<blockquote>
<p>zz</p>
</blockquote>
<h4 id="comment-uncomment-lines-in-Vim"><a href="https://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim">comment/uncomment lines in Vim</a></h4>
<p>感觉第二个答案好些，如下<br>
<strong>Comment</strong></p>
<blockquote>
<p>(在要注释的第一行前面)Ctrl+V（进入VISUAL BLOCK模式）<br>
方向键一直下拉到最后一行<br>
Shift+i(进入INSERT模式)，然后输入#（Python的注释）<br>
Esc</p>
</blockquote>
<p><strong>Uncomment</strong></p>
<blockquote>
<p>Put your cursor on the first # character, press CtrlV (or CtrlQ for gVim), and go down until the last commented line and press x, that will delete all the # characters vertically.</p>
</blockquote>
<h4 id="Delete-all"><a href="https://codeyarns.com/2011/04/18/how-to-delete-all-lines-of-file-in-vim/">Delete all</a></h4>
<blockquote>
<p>dG[光标放在第一行]</p>
</blockquote>
<h4 id="Cut-Copy-multi-lines"><a href="https://stackoverflow.com/questions/8980410/cut-and-paste-multiple-lines-in-vim">Cut&amp;Copy multi lines</a></h4>
<blockquote>
<p>V<br>
Select all the lines<br>
d(or y to copy)<br>
p(on somewhere to insert)</p>
</blockquote>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV系列笔记十八：Visual tracking using histograms</title>
    <url>/2017/05/15/Visual-tracking-using-histograms/</url>
    <content><![CDATA[<h4 id="Overview-54">Overview</h4>
<p>在之前，我们介绍了Intergral Image， 还有通过mean shift算法搜索物体。这里，来学习下利用Intergral Image，通过比较histogram来追踪物体。</p>
<p>代码里面比较难理解的就是先将灰度图转化为多通道二进制图的部分。关于这里我也迷惑好久，再次仔细读书，其实书上已经写的比较清楚了：</p>
<blockquote>
<p>The cv::integral function also works for multichannel images. You can take advantage of this fact to compute histograms of image subregions using integral images. You simply need to convert your image into a multichannel image made of binary planes; each of these planes is associated to a bin of your histogram and shows you which pixels have a value that falls into this bin.</p>
</blockquote>
<h4 id="Code-47">Code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;grayhistogram.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;integral.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Open image</span></span><br><span class="line">    cv::Mat image= cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/bike55.bmp&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// define image roi</span></span><br><span class="line">    <span class="type">int</span> xo=<span class="number">97</span>, yo=<span class="number">112</span>;</span><br><span class="line">    <span class="type">int</span> width=<span class="number">25</span>, height=<span class="number">30</span>;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">roi</span><span class="params">(image,cv::Rect(xo,yo,width,height))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute sum</span></span><br><span class="line">    <span class="comment">// returns a Scalar to work with multi-channel images</span></span><br><span class="line">    cv::Scalar sum= cv::<span class="built_in">sum</span>(roi);</span><br><span class="line">    std::cout &lt;&lt; sum[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute integral image</span></span><br><span class="line">    cv::Mat integralImage;</span><br><span class="line">    cv::<span class="built_in">integral</span>(image,integralImage,CV_32S);</span><br><span class="line">    <span class="comment">// get sum over an area using three additions/subtractions</span></span><br><span class="line">    <span class="type">int</span> sumInt= integralImage.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(yo+height,xo+width)</span><br><span class="line">                -integralImage.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(yo+height,xo)</span><br><span class="line">                -integralImage.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(yo,xo+width)</span><br><span class="line">                +integralImage.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(yo,xo);</span><br><span class="line">    std::cout &lt;&lt; sumInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// histogram of 16 bins</span></span><br><span class="line">    Histogram1D h;</span><br><span class="line">    h.<span class="built_in">setNBins</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// compute histogram over image roi</span></span><br><span class="line">    cv::Mat refHistogram= h.<span class="built_in">getHistogram</span>(roi);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Reference Histogram&quot;</span>,h.<span class="built_in">getHistogramImage</span>(roi,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first create 16-plane binary image</span></span><br><span class="line">    cv::Mat planes;</span><br><span class="line">    <span class="built_in">convertToBinaryPlanes</span>(image,planes,<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// then compute integral image</span></span><br><span class="line">    <span class="function">IntegralImage&lt;<span class="type">float</span>,16&gt; <span class="title">intHisto</span><span class="params">(planes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for testing compute a histogram of 16 bins with integral image</span></span><br><span class="line">    cv::Vec&lt;<span class="type">float</span>,<span class="number">16</span>&gt; histogram= <span class="built_in">intHisto</span>(xo,yo,width,height);</span><br><span class="line"><span class="comment">//    std::cout&lt;&lt;&quot; integral image histogram &quot;&lt;&lt; histogram &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    cv::Mat im= h.<span class="built_in">getImageOfHistogram</span>(cv::<span class="built_in">Mat</span>(histogram),<span class="number">16</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;IM&quot;</span>, im);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// search in second image</span></span><br><span class="line">    cv::Mat secondImage= cv::<span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/bike65.bmp&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!secondImage.data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first create 16-plane binary image</span></span><br><span class="line">    <span class="built_in">convertToBinaryPlanes</span>(secondImage,planes,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then compute integral image</span></span><br><span class="line">    <span class="function">IntegralImage&lt;<span class="type">float</span>,16&gt; <span class="title">intHistogram</span><span class="params">(planes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute histogram of 16 bins with integral image (testing)</span></span><br><span class="line">    histogram= <span class="built_in">intHistogram</span>(<span class="number">135</span>,<span class="number">114</span>,width,height);</span><br><span class="line"></span><br><span class="line">    cv::Mat im2= h.<span class="built_in">getImageOfHistogram</span>(cv::<span class="built_in">Mat</span>(histogram),<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance= &quot;</span> &lt;&lt; cv::<span class="built_in">compareHist</span>(refHistogram,histogram, cv::HISTCMP_INTERSECT) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> maxSimilarity=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> xbest, ybest;</span><br><span class="line">    <span class="comment">// loop over a horizontal strip around girl location in initial image</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y=<span class="number">110</span>; y&lt;<span class="number">120</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">0</span>; x&lt;secondImage.cols-width; x++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// compute histogram of 16 bins using integral image</span></span><br><span class="line">            histogram= <span class="built_in">intHistogram</span>(x,y,width,height);</span><br><span class="line">            <span class="comment">// compute distance with reference histogram</span></span><br><span class="line">            <span class="type">double</span> distance= cv::<span class="built_in">compareHist</span>(refHistogram,histogram, cv::HISTCMP_INTERSECT);</span><br><span class="line">            <span class="comment">// find position of most similar histogram</span></span><br><span class="line">            <span class="keyword">if</span> (distance&gt;maxSimilarity) &#123;</span><br><span class="line"></span><br><span class="line">                xbest= x;</span><br><span class="line">                ybest= y;</span><br><span class="line">                maxSimilarity= distance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Distance(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Best solution= (&quot;</span> &lt;&lt; xbest &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ybest &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; maxSimilarity &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw a rectangle around target object</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(image,cv::<span class="built_in">Rect</span>(xo,yo,width,height),<span class="number">0</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Initial Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Initial Image&quot;</span>,image);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;New Image&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;New Image&quot;</span>,secondImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw rectangle at best location</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(secondImage,cv::<span class="built_in">Rect</span>(xbest,ybest,width,height),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// draw rectangle around search area</span></span><br><span class="line">    cv::<span class="built_in">rectangle</span>(secondImage,cv::<span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">110</span>,secondImage.cols,height+<span class="number">10</span>),<span class="number">255</span>);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Object location&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Object location&quot;</span>,secondImage);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170515/Selection_051501.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode使用记录</title>
    <url>/2019/06/21/VsCode%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="Remote-SSH（Visual-Studio-Code-Insiders）">Remote-SSH（Visual Studio Code Insiders）</h4>
<p>开始的时候用总是出错，错误类似<a href="https://github.com/microsoft/vscode/issues/73382">Remote-SSH not working</a>, 之后根据<a href="https://code.visualstudio.com/docs/remote/troubleshooting#_quick-start-ssh-key">这里</a>进行修改，即运行<code>ssh-copy-id your-user-name-on-host@host-fqdn-or-ip-goes-here</code>（host]和ip换成自己的）。之后还是出错，再根据同一个issue下的方法，在<code>settings.json</code>设置<code>&quot;remote.SSH.showLoginTerminal&quot;: true</code></p>
<h4 id="code-runner配置python解释器">code-runner配置python解释器</h4>
<p>设置<code>&quot;code-runner.executorMap&quot;</code>参数为python解释器地址即可。</p>
<blockquote>
<p>ps: 运行默认快捷键 Ctrl+Alt+N</p>
</blockquote>
<h4 id="Python-Linting-and-pep8">Python Linting and pep8</h4>
<p>在打开pep8的时候，在<code>class</code>内部使用<code>annotation</code>会有如下报错：<code>E701: multiple statements on one line (colon)</code>（如<a href="https://stackoverflow.com/questions/49774397/flake-8-multiple-statements-on-one-line-colon-only-for-variable-name-starti">这里</a>），，这时候可以设置<code>python.linting.pep8Args</code>来进行修正，即忽略此错误。在<code>settings.json</code>添加</p>
<p><code>&quot;python.linting.pep8Args&quot;: [&quot;--ignore=E701&quot;]</code>即可。</p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>cin and cin.getline</title>
    <url>/2017/03/06/cin-and-cin-getline/</url>
    <content><![CDATA[<h5 id="Overview-55">Overview</h5>
<p>关于cin与cin.getline在使用时要注意的地方，关键在于&quot;newline&quot;的处理。</p>
<h5 id="Code-48">Code</h5>
<p>我们先来看一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;What year was your house biult?\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        cin&gt;&gt;year;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;What is its streer address?\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> address[<span class="number">80</span>];</span><br><span class="line">        cin.<span class="built_in">getline</span>(address, <span class="number">80</span>);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;Year built: &quot;</span>&lt;&lt;year&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Address: &quot;</span>&lt;&lt;address&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<blockquote>
<p>What year was your house biult?<br>
2017<br>
What is its streer address?<br>
Year built: 2017<br>
Address:<br>
Done!</p>
</blockquote>
<p>可以看到，还没输入地址，就打印并结束了程序。<br>
原因:</p>
<blockquote>
<p>The problem is that when cin reads the year, it leaves the newline generated by the Enter key in the input queue. Then, cin.getline() reads the newline as an empty line and assigns a null string to the address array.</p>
</blockquote>
<p>解决办法：</p>
<blockquote>
<p>The fix is to read and discard the newline before reading the address.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;What year was your house biult?\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用get将作为cin结束的newline清除即可</span></span><br><span class="line">        <span class="comment">//(cin&gt;&gt;year).get();</span></span><br><span class="line">        cin&gt;&gt;year;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;What is its streer address?\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> address[<span class="number">80</span>];</span><br><span class="line">        cin.<span class="built_in">getline</span>(address, <span class="number">80</span>);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;Year built: &quot;</span>&lt;&lt;year&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Address: &quot;</span>&lt;&lt;address&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Done!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>What year was your house biult?<br>
1998<br>
What is its streer address?<br>
earth<br>
Year built: 1998<br>
Address: earth<br>
Done!</p>
</blockquote>
<h5 id="Reference-14">Reference</h5>
<p><em>C++ Primer Plus(5th Edition)</em>   Page147</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc&amp;g++</title>
    <url>/2019/01/03/gcc-g/</url>
    <content><![CDATA[<p>关于gcc的更新，参考<a href="https://gist.github.com/jlblancoc/99521194aba975286c80f93e47966dc5">这里</a></p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>list comprehension in Haskell</title>
    <url>/2018/01/17/list-comprehension-in-Haskell/</url>
    <content><![CDATA[<h4 id="Overview-56">Overview</h4>
<p>以建立简易的图书馆数据库为例，学习Haskell的list comprehension以及其他的关于QuickCheck，pattern match的一些内容。</p>
<h4 id="Code-49">Code</h4>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 图书馆数据库模型</span></span><br><span class="line"><span class="keyword">module</span> Library <span class="keyword">where</span></span><br><span class="line">  <span class="keyword">import</span> Test.QuickCheck</span><br><span class="line">  <span class="keyword">import</span> Data.List</span><br><span class="line"></span><br><span class="line">  <span class="comment">--在对问题建立模型时，首先考虑对象的类型</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Person</span>  = <span class="type">String</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Book</span>     = <span class="type">String</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Database</span> = [(<span class="type">Person</span>, <span class="type">Book</span>)]</span></span><br><span class="line"></span><br><span class="line">  exampleBase :: <span class="type">Database</span></span><br><span class="line">  exampleBase =</span><br><span class="line">	[(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Tintin&quot;</span>), (<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Little Women&quot;</span>),</span><br><span class="line">	 (<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Asterix&quot;</span>), (<span class="string">&quot;Roty&quot;</span>, <span class="string">&quot;Tintin&quot;</span>)]</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 数据库上的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 查询函数(lookup)</span></span><br><span class="line">  <span class="comment">-- 读者-&gt;图书</span></span><br><span class="line">  books      ::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; [<span class="type">Book</span>]</span><br><span class="line">  books dBase findPerson = [book | (person, book) &lt;- dBase, person == findPerson]</span><br><span class="line">  <span class="comment">-- 图书-&gt;读者</span></span><br><span class="line">  borrowers  ::<span class="type">Database</span> -&gt; <span class="type">Book</span> -&gt; [<span class="type">Person</span>]</span><br><span class="line">  borrowers dBase findBook = [person | (person, book) &lt;- dBase, book == findBook]</span><br><span class="line">  <span class="comment">-- 图书是否借出</span></span><br><span class="line">  borrowed   ::<span class="type">Database</span> -&gt; <span class="type">Book</span> -&gt; <span class="type">Bool</span></span><br><span class="line">  borrowed dBase findBook = findBook `elem` [book | (_, book) &lt;- dBase]</span><br><span class="line">  <span class="comment">-- 读者借书数目</span></span><br><span class="line">  numBorrowed::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; <span class="type">Int</span></span><br><span class="line">  numBorrowed dBase findPerson = length (books dBase findPerson)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 更新函数(update)</span></span><br><span class="line">  makeLoan  ::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; <span class="type">Book</span> -&gt;<span class="type">Database</span></span><br><span class="line">  makeLoan dBase findPerson findBook = dBase ++ [(findPerson, findBook)]</span><br><span class="line"></span><br><span class="line">  returnLoan::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; <span class="type">Book</span> -&gt; <span class="type">Database</span></span><br><span class="line">  returnLoan dBase findPerson findBook = [pair | pair &lt;- dBase, pair /= (findPerson, findBook)]</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Show Database</span></span><br><span class="line">  showDatabase::<span class="type">Database</span> -&gt; <span class="type">IO</span>()</span><br><span class="line">  showDatabase dBase =</span><br><span class="line">	putStrLn $ intercalate <span class="string">&quot;\n&quot;</span> [person++<span class="string">&quot;:&quot;</span>++book | (person, book) &lt;- dBase]</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- QuickCheck测试</span></span><br><span class="line">  <span class="comment">-- 如果将书借给读者person,然后查询借给读者person的书，那么book应该在列表中出现</span></span><br><span class="line">  prop_db1::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; <span class="type">Book</span> -&gt; <span class="type">Bool</span></span><br><span class="line">  prop_db1 dBase person book =</span><br><span class="line">	book `elem` loanedAfterLoan <span class="keyword">where</span></span><br><span class="line">	  afterLoan = makeLoan dBase person book</span><br><span class="line">	  loanedAfterLoan = books afterLoan person</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 如果读者将peson借的书book还回，然后查询读者person借阅的图书，那么book不应该在列表中</span></span><br><span class="line">  prop_db2::<span class="type">Database</span> -&gt; <span class="type">Person</span> -&gt; <span class="type">Book</span> -&gt; <span class="type">Bool</span></span><br><span class="line">  prop_db2 dBase person book =</span><br><span class="line">	  book `notElem` loanedAfterReturn <span class="keyword">where</span></span><br><span class="line">	  afterReturn = returnLoan dBase person book</span><br><span class="line">	  loanedAfterReturn = books afterReturn person</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="…-2">…</h4>
<p>学haskell有一段时间了，感觉还是挺不错的。了解了很多新的东西（虽然现在还有很多理解不了）。感觉就elegant来言，haskell是不输Python的。目前了解到的typeclass感觉很强大（比OOP里面的多态继承要更加简洁），看了wiki，它也是首次出现在haskell里面的。其他是之前看到haskell不仅可以test,而且可以proof…test用的QuickCheck，感觉很好用,proof还没有看到。另外感觉haskell群的各位大佬都比较热心，经常是原理+demo的给讲解很基础的东西。慢慢学吧…</p>
]]></content>
      <categories>
        <category>Haskell</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>public, protected and private</title>
    <url>/2017/04/25/public-protected-and-private/</url>
    <content><![CDATA[<p>关于c++类变量的属性：private, protected, private</p>
<h5 id="访问范围">访问范围</h5>
<ul>
<li>[ ] private</li>
</ul>
<blockquote>
<p>只能由该类的函数和其友元函数访问<br>
该类的对象不能访问</p>
</blockquote>
<ul>
<li>[ ] proteected</li>
</ul>
<blockquote>
<p>可以被，该类的函数，子类的函数， 友元函数访问<br>
不能被类的对象访问</p>
</blockquote>
<ul>
<li>[ ] public</li>
</ul>
<blockquote>
<p>可以被该类的函数，子类的函数， 友元函数访问<br>
也可以被类的对象访问</p>
</blockquote>
<h5 id="继承">继承</h5>
<p>子类与父类的关系：</p>
<p><img src="https://i.stack.imgur.com/W6CJ3.jpg" alt=""></p>
<h5 id="参考-8">参考</h5>
<p><a href="http://stackoverflow.com/questions/860339/difference-between-private-public-and-protected-inheritance">stackoverflow</a></p>
<p><a href="http://cnmtjp.blog.51cto.com/204390/36548/"> C++ 类访问控制</a></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef &amp; #define</title>
    <url>/2017/03/25/typedef-define/</url>
    <content><![CDATA[<p>在c++里面，有两种方法为一个数据类型起一个别名，一个是通过预编译器(preprocessor)来替换文本实现，另一个是通过typedef来为类型起别名。<br>
一般情况下，而这均可以实现想要的效果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>* float_pointer;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLOAT_POINTER float*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> fv = <span class="number">1.0</span>;</span><br><span class="line">    float_pointer fp1;</span><br><span class="line">    fp1 = &amp;fv;</span><br><span class="line">    cout&lt;&lt;*fp1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    FLOAT_POINTER FP1;</span><br><span class="line">    FP1 = &amp;fv;</span><br><span class="line">    cout&lt;&lt;*FP1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1<br>
1</p>
</blockquote>
<p>然而，在<strong>同时为多个变量定义类型</strong>时，就会出现差别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>* float_pointer;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLOAT_POINTER float*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> fv = <span class="number">1.0</span>;</span><br><span class="line">    float_pointer fp1, fp2;</span><br><span class="line">    fp1 = &amp;fv;</span><br><span class="line">    fp2 = &amp;fv;</span><br><span class="line">    cout&lt;&lt;*fp1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    FLOAT_POINTER FP1, FP2;</span><br><span class="line">    FP1 = &amp;fv;</span><br><span class="line">    FP2 = &amp;fv;</span><br><span class="line">    cout&lt;&lt;*FP1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码将报错</p>
<blockquote>
<p>main.cpp:18:9: error: cannot convert ‘float*’ to ‘float’ in assignment<br>
FP2 = &amp;fv;<br>
^</p>
</blockquote>
<p>可以看出，FP2的类型为float，而不是期望的float*</p>
<p>这是因为，预编译器仅仅是将FLOAT_POINTER 替换为 float *， 也就是说定义FP1，FP2时，是这样的：</p>
<blockquote>
<p>float * FP1, FP2;</p>
</blockquote>
<p>即仅仅定义FP1为float* ，而FP2为float.</p>
<p>参考：*C++ Primer Plus [5th]*p234</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualenv error</title>
    <url>/2019/01/16/virtualenv-error/</url>
    <content><![CDATA[<p>使用virtualenv创建虚拟环境，遇到错误：</p>
<blockquote>
<p>error while loading shared libraries: libpython3.6m.so.1.0: cannot open shared object file: No such file or directory</p>
</blockquote>
<p>发现很多人都遇到这个问题，最后参考<a href="https://stackoverflow.com/questions/43333207/python-error-while-loading-shared-libraries-libpython3-4m-so-1-0-cannot-open">stackoverflow</a>解决。</p>
<blockquote>
<p>存在个问题，进行下面的操作会使得Ubuntu重启后的GUI挂掉…待解决</p>
</blockquote>
<p>就是添加个环境变量，方法如下：</p>
<blockquote>
<p>sudo gedit  ~/.profile<br>
export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/shensir/anaconda3/lib<br>
source .profile</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Error</tag>
        <tag>virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title>不良小白</title>
    <url>/2020/05/01/%E4%B8%8D%E8%89%AF%E5%B0%8F%E7%99%BD/</url>
    <content><![CDATA[<h2 id="始末">始末</h2>
<p>现在已经是2020年了，不知道现在的人听到六道，煮剑焚酒，唐家三少，天蚕土豆，我吃西红柿这些字眼会想起什么，于我而言，他们充斥了我大半个青春。</p>
<p>现在已经很久不关注了，也不知这些人现在如何，但是在我的中学时代，他们是红极一时的网络写手。一个很偶然的机会，我开始接触网络文学，开始了解这些被标记为都市，玄幻，穿越的文字。这里我不会探讨这些作品在其文字之外的意义，仅仅探讨作品本身，同时也作为记录，为多年以后成为公园里最靓的老头做些准备。</p>
<p>前面提到开始看网络文学是因为偶然的机会，到底多偶然呢？破落小县城的初中，教室的钥匙是由班级的一位同学保管，每天早上去开门。那天恰好那位兄台来的晚，我站的累，就借了班里另一位兄台（文末有这位神人的彩蛋~）的书，垫在地上…然后坐着累，就又站起来，开始看这本书(文末彩蛋+1)…</p>
<h2 id="玄幻">玄幻</h2>
<p>那天站着看的那本书，也是我看的第一本书，一本玄幻小说——《魔兽领主》。</p>
<h3 id="《魔兽领主》">《魔兽领主》</h3>
<p>作者高坡，全书798章，257万字。因为之前没有接触过，这本书当时是看得很过瘾的。基本上就是男主另辟蹊径，然后一步步成长为BOSS的历程。别人都是搞几只比较厉害的魔兽出去刚，男主是搞一堆低级魔兽玩人海战术。</p>
<p>在这之前的作品没有研究过，估计是那种男主出来就各种无敌加成的居多（参考下文），所以这部作品的这个思路还算是比较新奇的一点。作为入坑作品，我还是比较喜欢这一本的:-)</p>
<h3 id="《武动乾坤》，《斗破苍穹》-《大主宰》">《武动乾坤》，《斗破苍穹》, 《大主宰》</h3>
<p>作家天蚕土豆,字数分别是393.13万, 532.75万和496.03万.为什么将三者放到一起呢,因为这三个就是一个模子刻出来的…我是先看的《武动乾坤》,坦白说是有被惊艳到的,天蚕土豆的成名也绝不是偶然. 剧情大概就是少年从小就背负起复仇的使命,然后一路各种机遇,各种比试,一步步地变强,最后完成复仇,睥睨天下.整个过程通过给男主创造奇遇来平滑地开挂, 然后实力得以碾压同龄人,甚至越级挑战高阶大佬.</p>
<p>这种写法对于读者来说,看起来是很爽的,而且各种奇遇带来的实力的提升使得读者可以持续期待男主的下次开战,这种期待在连载中尤为重要.此外,时刻背负的复仇使命,不断累计的实力,使得读者十分期待最后的复仇,直到复仇成功然后完结,给人一种酣畅淋漓的感觉. 我觉着这是一个很好的思路,但是,你一套板子写三本我是没想到的…读过这三本的都能感受到,几乎就是照搬,只不过换一套人名,换一套技能,换一下后宫组成Orz</p>
<p>个人认为就看一本《武动乾坤》打住最好了.天蚕土豆真的江郎才尽了,这几年好像又在写《元尊》,看了三页我就知道还是那一套…无话可说.</p>
<h3 id="《斗罗大陆》-《绝世唐门》">《斗罗大陆》,《绝世唐门》</h3>
<p>作者唐家三少,字数分别为297.16万,507.96万.三少的这两本感觉就好很多了,剧情和体系都还不错,至少不老套,而且第二部也不像天蚕土豆那样照搬,阅读体验还是很好的.具体来说还是第一部好一些,第二部虽不是照搬但是基本没什么新意了.但是总体来说,这部玄幻小说还算是可以的.</p>
<h3 id="《神印王座》">《神印王座》</h3>
<p>作者唐家三少,259.11万字. 这本书的体系设置还是很不错的,前期的剧情也还不错,看到一半觉着在玄幻小说里面也算是不错的了,然而,这书到后面剧情直接崩了,搞成了大型家庭伦理剧…所以这本不要看,太烂了,惨不忍睹Orz</p>
<h3 id="《完美世界》">《完美世界》</h3>
<p>作者辰东，658.65万字。同样是少年的复仇之路，虽然题材依旧，但是这本写的真的不错。我认为是超越了天蚕土豆的《武动乾坤》和唐家三少的《斗罗大陆》的。作为玄幻题材的小说，这本书主打的是精心设计剧情，里面的男主也有一些很恶搞的设定（参考前不久B站热播的盾娘，哈哈），非常有趣。</p>
<p>读这本的时候已经高中了，每天睡午觉之前必看的枕边书，怀念…</p>
<h3 id="《龙族I-II-III-IV-V》">《龙族I, II, III, IV, V》</h3>
<p>作者江南。不同于之前的古代或者异世界为题材的玄幻，龙族是现代社会的玄幻。我之前没有太接触过，所以感觉还是很新奇的。龙族前三部我认为是写的很好的，到了第四部和第五部基本没法看了，惋惜…龙族的要素很多，前几部是值得看一下的，要说缺点就是战斗的描写不够满意吧，其实可以写的更好的。</p>
<h2 id="都市">都市</h2>
<p>不知道为啥，写黑道的小说是分类在都市标签下的。</p>
<h3 id="《坏蛋是怎样炼成的-I-II》">《坏蛋是怎样炼成的 I, II》</h3>
<p>作者六道。有没有注意到，我开篇介绍作者的时候，第一个就是六道。这部小说是我认为迄今为止看到的最好的黑道小说，我也认为它的高度是无法被超越的，原因在于作品中体现的某种真实性。一般来说，黑道小说再怎么写都不会写出三观很正的东西出来，但写一些值得思考的东西还是有机会的，我觉着《坏蛋》做到了，其他小说中鲜有。</p>
<p>首先是小说的设定是下了一定功夫的，青帮和洪门，都是现实中真实存在的…青帮之前的掌舵人是上海的杜月笙，洪门至今仍然活跃。青帮和洪门是从明末清初的天地会而来，一直在持续发展。在之前的抗战中，这两个组织在一定程度上也是起到了很多积极作用的。像中山先生，张謇等都是与其有千丝万缕关系的。后面为此我还专门看了关于中山先生和杜月笙的传记。</p>
<p>其次，小说的剧情是扣的很紧的，或者是写的很合理。靠的是精心设计的剧情来吸引读者，而非卑劣地钓鱼方式。这也是在那个连载时代尤为珍贵的一点。这部小说用一句烂大街的话形容就是“一直被模仿，从未被超越”。</p>
<p>当时看完一二两部就一直关注第三部的更新，然后好几年没等到…最近搜了下，好像又开始更第三部了…没有看，但我感觉应该不会好，第二部的结尾也可以算作完结了的。我想了想为什么更，答案是为什么不更呢…惋惜</p>
<h3 id="《黑道学生I-II-III》">《黑道学生I, II, III》</h3>
<p>作者煮剑焚酒，350万字。只看了前三部，感觉还是很不错的，和坏蛋的风格相差很多，但是也算是有趣。组织名字“替天”起得也很有趣。不过剧情的设置略显简单，体系也不够清晰，算是差强人意吧。后面很多同人续写的，好像都写成玄幻了…</p>
<h3 id="《狱锁狂龙-I-II-III》">《狱锁狂龙 I, II, III》</h3>
<p>作者华新。这是以监狱为起点的黑道小说，风格还是很独特的。小说的剧情也还可以，虽然不是很亮眼，但是也算不落俗套吧。后面好像也有很多同人续写的，水平很烂，惨不忍睹…</p>
<h2 id="网游">网游</h2>
<h3 id="《网游之纵横天下》">《网游之纵横天下》</h3>
<p>作者失落叶，464万字。算是比较传统的网游小说了，游戏里带飞妹子，又加入一些后宫元素…这也体现出当时的读者地位还是很高的，哈哈哈~</p>
<h3 id="《网游之掉级专家》">《网游之掉级专家》</h3>
<p>作者隐逸蝶，在那个年代，网游小说和中世纪的骑士小说一般，雷同现象严重，几乎都是主角光环从始至终笼罩，一路开挂。但是掉级专家真的是一股清流,男主一心想要掉级…所以看起来真的有趣的很.</p>
<h3 id="《全职高手》">《全职高手》</h3>
<p>作者蝴蝶篮，534.97万字。离开网络小说多年后，动漫中看到《全职高手》热播。想必也是因为这个以地下城与勇士为背景的剧情勾起了很多人的回忆…依稀记得DNF开服不久我就去注册DNF帐号，正在苦想昵称，旁边同学说随便起一个，说就叫“小沈”吧，赶紧开…然后就直接给我输名字，噼里啪啦一阵流畅的打字，一个回车，一气呵成…可惜有些瑕疵，以至于我就此在网吧顶着“小婶”的ID大杀四方…</p>
<p>言归正传，我真正看这本小说已经是考研的时候了，每天从图书馆回来累成狗，然后躺下熬夜看。不得不说，写的还可以。细心的我甚至发现了文中出现了概率密度函数和用傅里叶变换计算特征函数的剧情，值得一看~</p>
<h2 id="穿越">穿越</h2>
<h3 id="《极品家丁》">《极品家丁》</h3>
<p>作者禹岩，300万字。三哥的操作属实佩服，这部小说的剧情真的设计的很好，而且富有古风韵味。穿越，特殊的家丁身份，渊博的知识，很好地融合到了一起。</p>
<h2 id="彩蛋">彩蛋</h2>
<p>那位兄弟常年的生活几乎是一样的：一人，一手电，一小说而已。很多人可能没有听过“租书”，这位兄弟就是租书看的。网络小说字数动辄几百万起步，即使是盗版，印刷费也不便宜，买的多了更贵。有需求就有市场，“租书”应运而生，怎么个“租”法？每本每天2毛(还是3毛，记不清了)，不得损坏。所以这位兄弟在有限的开支下，权衡利弊，买了个手电，夜以继日…时代变得真快啊</p>
<p>屁股下垫的那本书应该是盗版的，我查了下，那本书根本没有出版…估计是盗版商自己印刷然后卖的</p>
<h2 id="结语">结语</h2>
<p>其他还有很多…就不写了。另外，这样的话，简历上可不可以写人肉处理过亿级别的数据呢:-)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>乱世与佳人</title>
    <url>/2020/09/13/%E4%B9%B1%E4%B8%96%E4%B8%8E%E4%BD%B3%E4%BA%BA/</url>
    <content><![CDATA[<p>《乱世佳人》、《飘》是原作<em>Gone with the Wind</em>的两个译名，个人而言更喜欢乱世佳人的翻译。这是我高中时代以来，最为喜欢的一本小说。高中午休的时间，我前后一共把整套书看了三遍：第一遍只看到佳人，第二遍看乱世，第三遍看乱世中的佳人。这部史诗一般的小说，对我本人产生了极大的影响，所以此后很多年，我每有一次机会都会向朋友极力推荐这本书。</p>
<p><a href="https://en.wikipedia.org/wiki/Margaret_Mitchell">Margaret Mitchell</a>，一名女作家，一生就写了<em>Gone with the Wind</em>这一本书。这本书毫无疑问地是一部伟大女性的赞歌，书中描写了很多相当伟大的女性，她们坚强，果敢，自始至终的善良；她们自私，势利，为达目的誓不罢休；她们迷惘，挣扎，一往无前；她们和百年后的我们一样有血有肉。</p>
<p>&lt;待续&gt;</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Python基础的学习</title>
    <url>/2018/03/30/%E5%85%B3%E4%BA%8EPython%E5%9F%BA%E7%A1%80%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="前言">前言</h3>
<p>由于写的<a href="http://datahonor.com/2018/03/22/Python%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">书</a>是要求有Python编程基础的，最近不少同学问我学习Python基础的问题，这里说下我个人对学习基础语法的建议，主要是针对没有任何编程基础的同学。</p>
<h3 id="准备">准备</h3>
<h4 id="系统-集成开发环境">系统&amp;集成开发环境</h4>
<p>虽然编程使用Linux要方便些，但是大家平常还都是用Windows多些，所以开始继续使用Windows就行，不必纠结。</p>
<p>关于开发环境，用<a href="https://www.anaconda.com/download/#linux">Anaconda3</a>+<a href="https://www.jetbrains.com/zh/pycharm/specials/pycharm/pycharm.html?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;utm_content=pycharm-pure&amp;utm_term=pycharm&amp;gclid=CPjtiMOpk9oCFYHdvAodTj8ARA&amp;gclsrc=ds&amp;dclid=COjElMSpk9oCFYISvQod8UgPuA">Pycharm（社区版）</a>就足够了，关于安装的步骤也比较简单，书中也有详细介绍。另外，如果大家有习惯用RStudio和MATLAB那种记录中间变量的风格，可以尝试用下Spyder，在安装Anaconda的时候会默认安装Spyder的，直接就可以用。</p>
<blockquote>
<p>在熟练使用这些工具之后，其实可以再使用一些更加方便的工具。比如Pycharm专业版的Science模式，和Spyder，RStudio都是很相似的。还有Anaconda带有的Jupyter Notebook，以及更强大的Jupyter Lab等，都是很方便的工具。这些初学的时候可以先不用太在意，之后用到再研究就可以。</p>
</blockquote>
<h4 id="网课-网上教程">网课&amp;网上教程</h4>
<p>没人指导的话，自己看书可能也有不少看不懂的地方，可以选择先看一些网课和简单精炼的教程，跟着写写代码来学习。</p>
<p>网课：<br>
其实这些网课都是差不多，可以选一个自己喜欢的看。</p>
<p><a href="https://www.coursera.org/courses?languages=en&amp;query=python&amp;userQuery=python">coursera</a></p>
<p><a href="https://www.icourse163.org/course/BIT-268001">中国大学MOOC</a></p>
<p>教程：<br>
<a href="http://res.crossincode.com/">Crossin的编程教室</a>，很基础的教程，基本的知识点也都有了。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰 Python3</a>，公认的好教程，不过可能对零基础的同学来说有些吃力，可以后面再看。</p>
<h4 id="参考书">参考书</h4>
<p>再有就是参考书了，语法比较推荐以下几本：</p>
<p><a href="http://www.ituring.com.cn/book/1863">编程小白的第一本 Python 入门书 </a> （适合零基础）</p>
<p>Learning Python(By Fabrizio Romano) （基础全面）</p>
<p>Python Cookbook(By David Beazley and Brian K. Jones ) (较为深入)</p>
<p>Fluent Python(By Luciano Ramalho) (较为深入)</p>
<h4 id="数据分析-机器学习">数据分析&amp;机器学习</h4>
<p>关于机器学习理论：</p>
<p>书籍：《统计学习方法》（李航）<br>
课程：<a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a></p>
<p>关于Python的比较推荐的就是本书的一些参考书：</p>
<p>[1] Richard <a href="http://Lawson.Web">Lawson.Web</a> Scraping with Python[M]UK: Packt Publishing,2015。</p>
<p>[2] Ryan <a href="http://Mitchell.Web">Mitchell.Web</a> Scraping with Python[M]America: O’Reilly Media,<br>
2015。</p>
<p>[3] Megan Squire.Clean Data[M]UK: Packt Publishing,2015。</p>
<p>[4] Wes McKinney.Python for Data Analysis[M]America: O’Reilly Media, 2013。</p>
<p>[5] Alberto Boschetti,Luca Massaronm.Python Data Science Essential[M].UK:Packt Publishing,2015。</p>
<p>[6] Ivan Idris. Python Data Analysis[M].UK: Packt Publishing,2014。</p>
<p>[7] Ivan Idris. Python Data Analysis Cookbook[M].UK: Packt Publishing,2016。</p>
<p>[8] Samir Madhavan.Mastering Python for Data Science[M].UK: Packt<br>
Publishing,2015。</p>
<p>[9] Wes McKinney, Python for Data Analysis[M].CA: O’Reilly Media,2013</p>
<p>[10] Packt Publishing]Toby Segaran.Programming Collective Intelligence[M]America: Reilly Media,2007。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于教育网邮箱</title>
    <url>/2017/08/10/%E5%85%B3%E4%BA%8E%E6%95%99%E8%82%B2%E7%BD%91%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<p>不久前申请了一个校园邮箱，后来用它申请了PyCharm Professional, Clion在Ubuntu使用。今天又发现Lingo也可以申请，就试了试，也是可以的。嗯。。而且申请的版本是Extended的（所有参数个数不限，没有license的那个demo版一般就30个变量），买的话要近5000$。。。不过前面两个申请后的license都是秒回的，这个我是等了一个下午才收到回复，不知道为啥还…</p>
<h4 id="申请校园邮箱">申请校园邮箱</h4>
<p>先登录到到<a href="http://hd2.hainu.edu.cn/homeN/">海南大学校内门户</a>（这个在海南大学官网主页下面也有登录的链接）。</p>
<blockquote>
<p>ps：校内门户的密码一般都改过的，默认应该是身份证号码</p>
</blockquote>
<p>之后进入右侧的邮件系统，按照提示申请即可。</p>
<h4 id="Lingo17-license申请">Lingo17 license申请</h4>
<p>先到Lingo官网<a href="http://www.lindo.com/index.php?option=com_content&amp;view=article&amp;id=120&amp;Itemid=45">这里</a>下载对应的版本并安装。之后按照下面的提示进行申请。</p>
<blockquote>
<p>As installation completes, the LINGO License Key license dialog box will display (alternatively, you can select File|License from the menu). Select the Demo button and then select the Create User ID File button. This will create a file named userinfo.txt in your main LINGO folder. Send a message to <a href="mailto:sales@lindo.com">sales@lindo.com</a> requesting an educational research license and attach the userifo.txt file to the message. The message should be sent from your educational email address. Once we receive the file we will generate and email you an educational research license key.</p>
</blockquote>
<p>登录到自己的校园邮箱，加上附件userifo.txt发送到sales@lindo.com即可。</p>
<blockquote>
<p>这里我是发送了两次，第一次仅仅是加上了附件，没有所说的message…然后接着又发了一份随便写了一句话算作message，然后加上附件发送就成了，后来申请成功回复的也是后面这一封。（不写任何东西可能会是因为被当作垃圾邮件给拒了，不过也不一定orz）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>再读《寻找无双》</title>
    <url>/2019/06/19/%E5%86%8D%E8%AF%BB%E3%80%8A%E5%AF%BB%E6%89%BE%E6%97%A0%E5%8F%8C%E3%80%8B/</url>
    <content><![CDATA[<p>​    &lt;始&gt;</p>
<p>​    根据书上的记录，我第一次阅读《寻找无双》是在2017.05.10， 17:31， 海大四教，看完是在2017.05.27 21:45，海大三教。毫无疑问的是当时就是把这本书当作色情小说+幽默段子来读——因为除了王小波的杂文和部分短篇，其他都是看不太懂的。时过两年，近日再重读，算是发现了一些有趣的内容，但是仍然没有完全看懂。</p>
<p>​    在谈小说之前，先提下小说的作者，也就是王小波。根据他自己所说（生前的一些访谈视频[1],[2],[3]）和其作品中透露出的信息，他是不喜欢去进行说教的，也不想去特意发声（《沉默的大多数》有些不同，那是他发现“沉默的大多数”之后想要去更明确地说出一些事情），更多的，他想做一个事实的陈述者，或是一个去喊醒做梦之人的人。此外，其理工科的背景使得其文章的思辨力量比较强，虽然很多都是黑色幽默。其父亲王方名[4]为逻辑学教授（成就极高，曾受毛主席接见），而王小波的文章中也多见一些逻辑上的论证。</p>
<p>​    现在正式谈这篇小说。先看序言，先是引用了《变形记》（奥维德）的最后几句：</p>
<blockquote>
<p>吾诗已成。<br>
无论大神的震怒，<br>
还是山崩地裂，<br>
都不能把它化成无形！</p>
</blockquote>
<p>之后写到逻辑学中一个最基本的定理：A等于A，A不等于非A。进而点明：一种关于事实的描述，一种推理，如果是真的，那么无论如何，它永远是真的。而在文中写到，“人执笔写作也有两种目的，一种是告诉别人一些事，另一种是让别人以为你非常甜蜜，非常乖。我个人写作总是前一种情形…”。也就是说这里作者确实是想告诉我们一些事情，具体来说，是关于“智慧的遭遇”。</p>
<p>​    小说中历史和现实是交织在一起的，现实就是王二在现代社会的一些遭遇，历史是在建安年间，王仙客来长安城里寻找其表妹无双，想回去山东老家去完成婚约。整个故事的展开都是有些扑朔迷离的，长安城的居民由于种种原因，要么说不认识无双这个人，要么扯到其他人，最后总是想起来有无双其人。期间长安城的人们对于无双的这件事混淆了很多东西，也搞得王仙客本人有些迷茫，一切都扯不清楚，甚至于梦和回忆——“也许根本就没有真正发生过的事， 只有更深一层的梦和浅一层的梦”。但是在王仙客的坚持之下，他还是大致还原了事情的真相，最终打听到了无双的去向。</p>
<p>先说我从中读出了什么。小说包含的内容许多，作者想要表达的思想也有很多。包括为人处事，社会风气，封建制度对人的束缚等等。这里只谈其中一个方面，那就是——我们是否能够分清楚现实与梦境，我们是否有勇气去寻找那最为真实的一切。</p>
<p>​    “寻找无双”， “无双”是什么？是一个人，也是独一无二的真实的本身——A等于A，A不等于非A，是为无双！</p>
<p>​    小说的主题也从未脱离“寻找”，而寻找的对象从来都是“无双”。即使一开始所有人都说了无双其人并不存在，王仙客也坚持认为确有其人，因为他虽然不知道无双在何处，但是无双是存在的这一点却是他确信的——因为这是事实。后来又因“他脑子里装了一大堆原始形态的代数学、逻辑学、几何学、哲学”，而这些东西对他寻找无双并没有什么帮助，反而轻信了别人的话，去探寻“鱼玄机”其人，以至于分不清其和无双的关系。</p>
<blockquote>
<p>王仙客在宣阳坊，所恃仗的就是自己的智慧。可惜的是，他的智慧解决不了眼前的问题。</p>
</blockquote>
<p>之后所有真实的一切——不论是在王仙客那里还是在长安城的人们那里——都和梦混在了一起。</p>
<blockquote>
<p>这时候他对一起都起了怀疑，觉得是在梦里。但是他又觉得现在好像是醒来了。</p>
</blockquote>
<blockquote>
<p>每件事情的背后都有那么多暧昧不清的地方，这真像在梦里，或者说在现实里一样——谁也不知道梦里和现实哪一边古怪事更多一些。</p>
</blockquote>
<blockquote>
<p>王仙客临终时说，他始终也没搞清楚什么是现实，什么是梦。在他看来，苦苦思索无双去了哪里，就像是现实，因为现实总是具有一种苦涩味。</p>
</blockquote>
<p>而后，作者又借王仙客之口给出了答案：</p>
<blockquote>
<p>梦具有一种荒诞的真实性，而真实有一种真实的荒诞性。除了这种感觉上的差异，他说不出这两者之间有什么区别。</p>
</blockquote>
<p>故事的中心就是作者要表达的东西——真实，什么是真实，有没有勇气去面对真实，如何去找寻。</p>
<blockquote>
<p>是什么就说什么，是一件需要极大勇气的事；但是假定你生来就很乖，后来又当了模范犯人，你会说什么呢？我们经常感到有一些话早就该有人讲出来，但始终不见有人讲。我想，这大概是因为少了一个合适的人去受三绞毙命之刑吧。</p>
</blockquote>
<p>而作者就是想要把这些该讲的话讲出来。这个人为什么是作者？</p>
<blockquote>
<p>像这样的事历史上不记载，只存在于过来人的脑子中，属于个人的收藏品。等到我们都死了，这件事也就不存在了。</p>
</blockquote>
<blockquote>
<p>人活在世界上，就如同站在一个迷宫面前，有很多的线索，很多的岔路，别人东看看，西望望，就都走过去了。但是我们就一定要迷失在里面。这是因为我们渺小的心灵里，容不下一个谜，一点悬而未决的东西。所以我们把一切疑难都放进自己心里，把自己给难死了。</p>
</blockquote>
<p>​    所以，我认为王小波在这篇小说中是在追问——追问自己，也追问别人——关于真实的一切。他也在很大声地喊：</p>
<blockquote>
<p>我不说你就知道，在我们身边有好多人，他们的生活就是编一个故事。不管真的假的，完全编在一起，讲起来娓娓动听，除了这个故事，他再也不知道别的了。这就是说，在他看来，自己总是这一个故事，但是别人看来却不是这样。</p>
</blockquote>
<p>最后记录一些有趣的句子（王小波曾谈过关于文章中黑色幽默的成分，意思大概是，沉重的东西如果不添加一些幽默的东西会让人没法看。说的真好。）</p>
<blockquote>
<p>人在二十五岁时，什么事情都想干，但是往往一事无成。人在二十五岁时，脑子聪明，长得也漂亮，但是有时候总会胡思乱想，缺乏逻辑，并且会相信一些鬼话。</p>
</blockquote>
<blockquote>
<p>信心这个东西，什么时候都像个高楼大厦，但是里面却会长白蚁。</p>
</blockquote>
<blockquote>
<p>看了这种情景，每个人都有个善良的愿望，就是盼天上掉下个大磨盘，把自己剩在磨眼里，把别人都砸死。</p>
</blockquote>
<blockquote>
<p>像这种见到别人了得，就把他拉到自己一边的事，我们现在也干。</p>
</blockquote>
<blockquote>
<p>假如人生活在一种不能抗拒的痛苦中，就会把这种痛苦看作幸福。（弗洛伊德）</p>
</blockquote>
<blockquote>
<p>他站在院子中央看着一地的八卦，先是赞美祖宗的智慧，后是赞美自己会画八卦，后来就把要开4的立方这种事给忘了。</p>
</blockquote>
<blockquote>
<p>何况尘世嚣嚣，我们不管干什么，都是困难重重。</p>
</blockquote>
<p>&lt;完&gt;</p>
<p>参考文献：</p>
<p>[1] <a href="https://www.bilibili.com/video/av20931770?from=search&amp;seid=16425343411453333568">一个不被时代所理解的人——王小波生前采访</a></p>
<p>[2] <a href="https://www.bilibili.com/video/av10719733?from=search&amp;seid=16425343411453333568">王小波唯一视频访谈记录（1997）</a></p>
<p>[3] <a href="https://www.bilibili.com/video/av55993573/?p=2">王小波采访集</a></p>
<p>[4] <a href="https://baike.baidu.com/item/%E7%8E%8B%E6%96%B9%E5%90%8D/7242723">王方名</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树的简单实现</title>
    <url>/2017/03/02/%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Coursera课程machine learning data analysis  week1Decision Trees</p>
<p>Python代码：[最后图片部分有些许改动]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier <span class="keyword">import</span> sklearn.metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Data Engineering and Analysis</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#Load the dataset</span></span><br><span class="line"></span><br><span class="line">AH_data = pd.read_csv(<span class="string">&quot;tree_addhealth.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">data_clean = AH_data.dropna()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些常用的命令，整体上描述数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------desc-------------&#x27;</span>)</span><br><span class="line"><span class="comment"># print(data_clean.info())</span></span><br><span class="line"><span class="comment"># print(data_clean.dtypes)</span></span><br><span class="line"><span class="built_in">print</span>(data_clean.describe())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Modeling and Prediction</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#Split into training and testing sets</span></span><br><span class="line"><span class="comment"># 除去TREG1后的24个字段</span></span><br><span class="line">predictors = data_clean[[<span class="string">&#x27;BIO_SEX&#x27;</span>,<span class="string">&#x27;HISPANIC&#x27;</span>,<span class="string">&#x27;WHITE&#x27;</span>,<span class="string">&#x27;BLACK&#x27;</span>,<span class="string">&#x27;NAMERICAN&#x27;</span>,<span class="string">&#x27;ASIAN&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;ALCEVR1&#x27;</span>,<span class="string">&#x27;ALCPROBS1&#x27;</span>,<span class="string">&#x27;marever1&#x27;</span>,<span class="string">&#x27;cocever1&#x27;</span>,<span class="string">&#x27;inhever1&#x27;</span>,<span class="string">&#x27;cigavail&#x27;</span>,<span class="string">&#x27;DEP1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;ESTEEM1&#x27;</span>,<span class="string">&#x27;VIOL1&#x27;</span>,<span class="string">&#x27;PASSIST&#x27;</span>,<span class="string">&#x27;DEVIANT1&#x27;</span>,<span class="string">&#x27;SCHCONN1&#x27;</span>,<span class="string">&#x27;GPA1&#x27;</span>,<span class="string">&#x27;EXPEL1&#x27;</span>,<span class="string">&#x27;FAMCONCT&#x27;</span>,<span class="string">&#x27;PARACTV&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;PARPRES&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">targets = data_clean.TREG1</span><br><span class="line"><span class="comment"># 拆分为测试集和训练集</span></span><br><span class="line">pred_train, pred_test, tar_train, tar_test  =   train_test_split(predictors, targets, test_size=<span class="number">.4</span>)  <span class="comment"># 测试集占数据集的40%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看拆分结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------shapes------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pred_train.shape)</span><br><span class="line"><span class="built_in">print</span>(pred_test.shape)</span><br><span class="line"><span class="built_in">print</span>(tar_train.shape)</span><br><span class="line"><span class="built_in">print</span>(tar_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Build model on training data</span></span><br><span class="line">classifier=DecisionTreeClassifier()</span><br><span class="line">classifier=classifier.fit(pred_train,tar_train)</span><br><span class="line"></span><br><span class="line">predictions=classifier.predict(pred_test)</span><br><span class="line"></span><br><span class="line">sklearn.metrics.confusion_matrix(tar_test,predictions)</span><br><span class="line">sklearn.metrics.accuracy_score(tar_test, predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Displaying the decision tree</span></span><br><span class="line"><span class="keyword">import</span> pydotplus</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">out = StringIO()</span><br><span class="line">tree.export_graphviz(classifier, out_file=out)</span><br><span class="line">graph=pydotplus.graph_from_dot_data(out.getvalue())</span><br><span class="line">data = graph.create_png()  <span class="comment"># 图片的二进制数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tree.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>遇到的问题：</p>
<blockquote>
<p>InvocationException: GraphViz’s executables not found</p>
</blockquote>
<p>解决：</p>
<blockquote>
<p>pip install graphviz</p>
</blockquote>
<p>这样虽说不报错了，但是图片还是无法显示，于是就做了变动，改为保存图片。<br>
tree.png:</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/tree.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Analysis</tag>
        <tag>ML</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python,Lingo, Octave解线性规划问题(LP)</title>
    <url>/2017/03/22/%E5%88%A9%E7%94%A8Python%E8%A7%A3%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98-LP/</url>
    <content><![CDATA[<h5 id="Overview-57">Overview</h5>
<p>新学期开了运筹学(OR)的课,最近学线性规划问题(LP)。老师建议说是用MATLAB 或者 LINGO，这里再加上Python,三种都试下，进行下比较。[懒的切换到windows系统了。。。用Octave代替Matlab了先。。。]</p>
<h5 id="Python求解-cvxopt">Python求解(cvxopt)</h5>
<p>这里用的库是cvxopt,之前解SVM的QP问题也用过，这里求解LP问题。<br>
这是文档的介绍：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/OR/LP1.png" alt=""></p>
<p>这里，我们主要看下在有无等式约束两种情况下的不同,其实也没差 :-）</p>
<h6 id="无等式约束">无等式约束</h6>
<p>$$ minimize     \quad   -4x_{1}-5x_{2}$$</p>
<p>$$<br>
subject \quad to<br>
\left{\begin{matrix}<br>
2x_{1} &amp; +x_{2} &amp; \leq 3\<br>
x_{1}&amp; +2x_{2} &amp; \leq 3\<br>
x_{1}&amp;,x_{2}&amp;\geq 0<br>
\end{matrix}\right.<br>
$$</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> cvxopt <span class="keyword">import</span> matrix, solvers</span><br><span class="line"></span><br><span class="line">c = matrix([-<span class="number">4.</span>, -<span class="number">5.</span>])</span><br><span class="line">G = matrix([[<span class="number">2.</span>, <span class="number">1.</span>, -<span class="number">1.</span>, <span class="number">0.</span>], [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">0.</span>, -<span class="number">1.</span>]])</span><br><span class="line">h = matrix([<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">sol = solvers.lp(c, G, h)</span><br><span class="line"><span class="built_in">print</span>(sol[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<pre><code>pcost       dcost       gap    pres   dres   k/t
</code></pre>
</blockquote>
<p>0: -8.1000e+00 -1.8300e+01  4e+00  0e+00  8e-01  1e+00<br>
1: -8.8055e+00 -9.4357e+00  2e-01  1e-16  4e-02  3e-02<br>
2: -8.9981e+00 -9.0049e+00  2e-03  3e-16  5e-04  4e-04<br>
3: -9.0000e+00 -9.0000e+00  2e-05  1e-16  5e-06  4e-06<br>
4: -9.0000e+00 -9.0000e+00  2e-07  3e-16  5e-08  4e-08<br>
Optimal solution found.<br>
[ 1.00e+00]<br>
[ 1.00e+00]</p>
<p>Remark：</p>
<blockquote>
<p>这里记得一定要调入numpy,否则会出现如下报错<br>
Intel MKL FATAL ERROR: Cannot load libmkl_avx2.so or libmkl_def.so.<br>
可能是依赖的问题。</p>
</blockquote>
<h6 id="有等式约束">有等式约束</h6>
<p>$$ minimize  \quad  z = -3x_{1}+x_{2}+x{3}$$</p>
<p>$$<br>
subject\quad to<br>
\left{\begin{matrix}<br>
x_{1} &amp;  -2x_{2}&amp; +x_{3} &amp; \leq 11\<br>
-4x_{1} &amp; +x{2} &amp;  +2x{3}&amp; \geq 3\<br>
-2x_{1}&amp;  &amp; +x_{3} &amp; = 1\<br>
x_{1},&amp;x_{2},&amp;x_{3}&amp;\geq 0<br>
\end{matrix}\right.<br>
$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> cvxopt <span class="keyword">import</span> matrix, solvers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">G = matrix([[<span class="number">1.0</span>,<span class="number">4.0</span>,-<span class="number">2.0</span>,-<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>], [-<span class="number">2.0</span>,-<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,-<span class="number">1.0</span>,<span class="number">0.0</span>],[<span class="number">1.0</span>,-<span class="number">2.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,-<span class="number">1.0</span>]])</span><br><span class="line">h = matrix([<span class="number">11.0</span>,-<span class="number">3.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>])</span><br><span class="line"></span><br><span class="line">A = matrix([-<span class="number">2.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>])</span><br><span class="line">A = A.trans()  <span class="comment"># 这里不转置会报错</span></span><br><span class="line">b = matrix([<span class="number">1.0</span>])</span><br><span class="line">c = matrix([-<span class="number">3.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>])</span><br><span class="line"></span><br><span class="line">sol = solvers.lp(c,G,h,A=A,b=b)</span><br><span class="line"><span class="built_in">print</span>(sol[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<pre><code>pcost       dcost       gap    pres   dres   k/t
</code></pre>
</blockquote>
<p>0: -2.1667e+00 -1.1167e+01  3e+01  9e-01  1e+00  1e+00<br>
1: -1.1986e+00 -1.9278e+00  2e+00  7e-02  1e-01  1e-01<br>
2: -1.9895e+00 -2.0163e+00  6e-02  3e-03  4e-03  5e-03<br>
3: -1.9999e+00 -2.0002e+00  6e-04  3e-05  5e-05  5e-05<br>
4: -2.0000e+00 -2.0000e+00  6e-06  3e-07  5e-07  5e-07<br>
5: -2.0000e+00 -2.0000e+00  6e-08  3e-09  5e-09  5e-09<br>
Optimal solution found.<br>
[ 4.00e+00]<br>
[ 1.00e+00]<br>
[ 9.00e+00]</p>
<h5 id="Lingo求解线性规划问题">Lingo求解线性规划问题</h5>
<p>题目还是上面的有等式约束的那道题[用lingo处理等式约束方便的多，有无等式约束几乎是一样的]</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIn=-3*x1+x2+x3;</span><br><span class="line"></span><br><span class="line">x1&gt;=0;</span><br><span class="line">x2&gt;=0;</span><br><span class="line">x3&gt;=0;</span><br><span class="line"></span><br><span class="line">x1-2*x2+x3 &lt;= 11;</span><br><span class="line">-4*x1+x2+2*x3&gt;=3;</span><br><span class="line">-2*x1+x3=1;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/OR/Lp2.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Python/OR/LP3.png" alt=""></p>
<h5 id="利用Octave解决LP问题">利用Octave解决LP问题</h5>
<blockquote>
<p>注意，在MatLab中，使用的函数是linprog, 这在Octave换成了glpk函数。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">c = [-3 1 1]&#x27;;</span><br><span class="line"></span><br><span class="line">A = [1 -2 1;</span><br><span class="line">-4 1 2;</span><br><span class="line">-2 0 1];</span><br><span class="line"></span><br><span class="line">b = [11 3 1];</span><br><span class="line">lb = [0 0 0];</span><br><span class="line">ub = [];</span><br><span class="line"></span><br><span class="line">ctype = &quot;ULS&quot;;</span><br><span class="line">vartype = &quot;CCC&quot;;</span><br><span class="line">s = 1;</span><br><span class="line">param.msglev = 1;</span><br><span class="line">param.itlim = 100;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[xopt, fmin, status, extra] = glpk (c, A, b, lb, ub, ctype, vartype, s, param)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>xopt =</p>
</blockquote>
<p>4<br>
1<br>
9</p>
<blockquote>
<p>fmin = -2<br>
status = 0<br>
extra =</p>
</blockquote>
<blockquote>
<p>scalar structure containing the fields:</p>
</blockquote>
<blockquote>
<p>lambda =</p>
</blockquote>
<blockquote>
<pre><code>-0.33333
</code></pre>
</blockquote>
<pre><code>   0.33333
   0.66667
</code></pre>
<blockquote>
<p>redcosts =</p>
</blockquote>
<blockquote>
<pre><code>  0
</code></pre>
</blockquote>
<pre><code>   0
   0
</code></pre>
<blockquote>
<p>time = 0<br>
status =  5</p>
</blockquote>
<p>好啦，都完美运行咯，再见单纯形法，再见大M法：-）</p>
<h5 id="Refrence-3">Refrence</h5>
<p><a href="http://cvxopt.org/">cvxopt</a><br>
<a href="https://www.gnu.org/software/octave/doc/v4.0.0/Linear-Programming.html">glpk</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OR</tag>
      </tags>
  </entry>
  <entry>
    <title>原始感知机模型</title>
    <url>/2017/03/03/%E5%8E%9F%E5%A7%8B%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>李航老师《统计学习方法》第二章笔记。<br>
关于原始感知机学习算法的简单实现[ Python ]。<br>
之后有<a href="http://datahonor.com/2017/03/03/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F/#more">感知机的对偶形式</a>的实现。</p>
<h5 id="算法原理">算法原理</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/1.png" alt=""></p>
<h5 id="算法实现">算法实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S1--&gt;随机生成训练集并标注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train matrix</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_data</span>():</span><br><span class="line"></span><br><span class="line">    M1 = np.random.random((<span class="number">100</span>, <span class="number">2</span>))</span><br><span class="line">    M11 = np.column_stack((M1, np.ones(<span class="number">100</span>)))</span><br><span class="line"></span><br><span class="line">    M2 = np.random.random((<span class="number">100</span>, <span class="number">2</span>)) - <span class="number">0.7</span></span><br><span class="line">    M22 = np.column_stack((M2, np.ones(<span class="number">100</span>) * (-<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    MA = np.vstack((M11, M22))</span><br><span class="line"></span><br><span class="line">    plt.plot(M1[:, <span class="number">0</span>], M1[:, <span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">    plt.plot(M2[:, <span class="number">0</span>], M2[:, <span class="number">1</span>], <span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">    min_x = np.<span class="built_in">min</span>(M2)</span><br><span class="line">    max_x = np.<span class="built_in">max</span>(M1)</span><br><span class="line">    <span class="comment"># 此处返回 x 是为了之后作图方便</span></span><br><span class="line">    x = np.linspace(min_x, max_x, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MA, x</span><br><span class="line"></span><br><span class="line"><span class="comment"># S2--&gt;原始感知机模型的训练及做图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 感知机模型:f(x) = sign(w*x+b)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">w, b, xi, yi</span>):</span><br><span class="line">    num = yi * (np.dot(w, xi) + b)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练training data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">MA, w, b</span>):</span><br><span class="line">    <span class="comment"># M 存储每次处理后依旧处于误分类的原始数据</span></span><br><span class="line">    M = []</span><br><span class="line">    <span class="keyword">for</span> sample <span class="keyword">in</span> MA:</span><br><span class="line">        xi = sample[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">        yi = sample[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果为误分类，更新w, b</span></span><br><span class="line">        <span class="comment"># n 为学习率</span></span><br><span class="line">        <span class="keyword">if</span> func(w, b, xi, yi) &lt;= <span class="number">0</span>:</span><br><span class="line">            w += n * yi * xi</span><br><span class="line">            b += n * yi</span><br><span class="line">            M.append(sample)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(M) &gt; <span class="number">0</span>:</span><br><span class="line">        train(M, w, b)</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作出分类线的图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_classify</span>(<span class="params">w, b, x, rate0</span>):</span><br><span class="line">    y = (w[<span class="number">0</span>] * x + b) / ((-<span class="number">1</span>) * w[<span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">&#x27;Accuracy = &#x27;</span> + <span class="built_in">str</span>(rate0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S3--&gt;随机生成测试集，并测试模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成testing data 并作图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_data</span>():</span><br><span class="line">    M = np.random.random((<span class="number">50</span>, <span class="number">2</span>))</span><br><span class="line">    plt.plot(M[:, <span class="number">0</span>], M[:, <span class="number">1</span>], <span class="string">&#x27;*y&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对传入的testing data 的单个样本进行分类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">w, b, test_i</span>):</span><br><span class="line">    <span class="keyword">if</span> np.sign(np.dot(w, test_i) + b) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据，返回正确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">w, b, test_data</span>):</span><br><span class="line">    right_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> test_i <span class="keyword">in</span> test_data:</span><br><span class="line">        classx = classify(w, b, test_i)</span><br><span class="line">        <span class="keyword">if</span> classx == <span class="number">1</span>:</span><br><span class="line">            right_count += <span class="number">1</span></span><br><span class="line">    rate = right_count / <span class="built_in">len</span>(test_data)</span><br><span class="line">    <span class="keyword">return</span> rate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_n_rate</span>(<span class="params">rate_l</span>):</span><br><span class="line">    <span class="comment"># plot n-rate</span></span><br><span class="line">    n_l = <span class="built_in">sorted</span>([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> rate_l.keys()])</span><br><span class="line">    y = [<span class="built_in">float</span>(rate_l[n_l[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n_l))]</span><br><span class="line">    <span class="built_in">print</span>(n_l, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    plt.plot(n_l, y, <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;n-accuracy&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    MA, x = get_train_data()</span><br><span class="line">    test_data = get_test_data()</span><br><span class="line">    <span class="comment"># 定义初始的w,b</span></span><br><span class="line">    w = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化最优的正确率</span></span><br><span class="line">    rate0 = <span class="number">0</span></span><br><span class="line">    <span class="comment"># rate_l 记录学习率的更新</span></span><br><span class="line">    rate_l = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环不同的学习率n,寻求最优的学习率，即最终的rate0</span></span><br><span class="line">    <span class="comment"># w0,b0为对应的最优参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0.01</span>, <span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        n = i</span><br><span class="line">        w, b = train(MA, w, b)</span><br><span class="line">        <span class="comment"># print(w,b)</span></span><br><span class="line">        rate = test(w, b, test_data)</span><br><span class="line">        <span class="keyword">if</span> rate &gt;= rate0:</span><br><span class="line">            rate_l[n] = rate</span><br><span class="line">            rate0 = rate</span><br><span class="line">            w0 = w</span><br><span class="line">            b0 = b</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Until now, the best result of the accuracy on test data is &#x27;</span> + <span class="built_in">str</span>(rate))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;with w=&#x27;</span> + <span class="built_in">str</span>(w0) + <span class="string">&#x27; b=&#x27;</span> + <span class="built_in">str</span>(b0))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在选定最优的学习率后，作图</span></span><br><span class="line">    plot_classify(w0, b0, x, rate0)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作出学习率——准确率的图</span></span><br><span class="line">    plot_n_rate(rate_l)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/2.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/3.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/4.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Analysis</tag>
        <tag>ML</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>我的大学</title>
    <url>/2019/05/20/%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<center>始</center>
<center>某日清晨，我的大学</center>
<p>四年前，我来到小岛，来到海大。</p>
<p>若把城西小校门看作六点钟方向，出租车司机是把我放在大概六点半方向，并指明校门方向。而我先走到了十一点的位置，没找到校门，问路，折返，又走到两点钟方向，问路，折返，然后找到校门，至此完成我大学的“入场仪式”。</p>
<p>那时候的我绝没有想到，之后的几年我依旧会这样在真正的目的地旁边绕来绕去…</p>
<p>我从高考的阴影走出来，满怀信心地开启大学生活。我有很多想做的事，但是逐渐发现大学生活并非我想象中的那般美好。我在想自己真正想要的大学生活是什么样的，没想通，当时认为大概是自由吧。</p>
<p>后来渐渐了解到真实的社会，真实的一切。我觉着很多事不对，想做些什么，但是发现自己什么都做不到，我开始想是不是自己做错了什么。但我没觉得自己做错什么，所以我一度认为“错的不是我，是这个世界”。</p>
<p>我觉着这世界太残酷，太喧嚣，太容易让人迷失了…</p>
<center>某日深夜，我的大学</center>
<p>自毕业这段日子以来，我就在思考一个问题——在我的大学，我所得到的到底是什么？</p>
<p>开始我是这样想的，首先是一个刚刚步入校门的我（当然是完成“入场仪式”之后），不妨记为$I_{input}$。这时候的我，经历了高考的失利以及之后的重新面对；拥有对大学的美好憧憬，渴望着那未知的一切；有着清晰的自我意识。之后四年，也就是现在的我，不妨记为$I_{output}$。如今的我，经历了考研的折磨（于我而言，这点毫无疑问，无论如今结果如何）以及之后无尽的疲惫；似乎有些看轻未来的一切（一切，没错）；自我意识自然也是更为清晰。</p>
<p>那么我的大学约等于$I_{output} - I_{input}$，是否能够称之为成长呢？或许是，毕竟又经历那么多事情，思考了那么多问题，人之所谓阅历总是有所提升的。又或许不是，毕竟我一直认为的就是这样——机械的劳动以及所谓的苦难与奋斗无关，可以确定的一点就是它抹杀了很多东西，无可修复，镜子碎了就是碎了。所以我又很难称之为成长。</p>
<p>所以我又想到，说清楚某个东西是什么，比如$I_{output} - I_{input}$，其实是很难的事情。那么，先退一步看下其表现出来的属性，根据其属性来判断其本身也是勉强可行的。那么，我的大学是好些还是坏些？值得余生去追思还是就此任其四处流散直至寥寥数语？</p>
<p>我还是陷入了困难，我没有答案。但总是想总是会有一些可以用文字表达出来的：</p>
<blockquote>
<p>虽然前两年还是比较瘦，但是现在已经稍微胖点了；虽然自己觉着变得黑很多了，其实只是比以前黑了一点；眼镜又加了100度；考了研继续读书；做了自己想做的事，读书，编程，游戏，动漫等；做了自己不想做的事，比前者多太多了；在每个当下都去尝试做了很多“当下的我不可能去做的事”，全是悲喜交集；明确了人生的终极目的是改变世界，明确了自己基本不可能改变世界，明确了自己还是要去改变世界，明确了自己想要的世界是“真实的世界”（而非“景观的世界”），明确了在这个世界去找寻真实的人是多么困难的一件事情（概率论上说，或许就是概率为0的事件）。</p>
</blockquote>
<p>所以现在对于$I_{output} - I_{input}$，这个约等于我的大学的东西，我的认识是什么呢？大概是这样的：</p>
<table>
<thead>
<tr>
<th>？</th>
<th>！</th>
</tr>
</thead>
<tbody>
<tr>
<td>`</td>
<td>我曾听闻王国覆灭，终归无闻。</td>
</tr>
<tr>
<td>(</td>
<td>一直学习，一直寻觅。</td>
</tr>
<tr>
<td>^</td>
<td>灾难始终慢我一步</td>
</tr>
<tr>
<td>)</td>
<td>过往成了我今日的梦魇。</td>
</tr>
<tr>
<td>]</td>
<td>他们的意志根本承受不了我眼中的所见。</td>
</tr>
<tr>
<td>[</td>
<td>每个人注定都要重复历史，这也是我的来路。</td>
</tr>
<tr>
<td>-</td>
<td>我犹记得这泪珠滑落的时刻。</td>
</tr>
<tr>
<td>*</td>
<td>如果我根本懒得在乎，这一切都会变得非常容易。</td>
</tr>
<tr>
<td>+</td>
<td>我还记得曾经肩头上只扛着一个世界而已</td>
</tr>
<tr>
<td>&amp;</td>
<td>我希望自己的悲剧能够不再重演！</td>
</tr>
<tr>
<td>#</td>
<td>眼望四野，心无苟且。</td>
</tr>
<tr>
<td>@</td>
<td>也许会失败，但我不会放弃。</td>
</tr>
<tr>
<td>/</td>
<td>哪怕一次也好，我想要的一夜安眠。</td>
</tr>
</tbody>
</table>
<center>某日上午，我的大学</center>
<p>​    四年后的我驻足在那个又破又小的校门边上，细心打量那个四年前的自己：他瘦瘦的，看起来比较疲惫。拉着个行李箱，背着一个包，一个人走着。眼神中充满青春的气息，他还是很期待未来四年的生活的，想象着未来将会有什么冒险…此时之我多想跨越时空走到彼时之我的身边，告诉他说，其实四年之后你将依旧孤独，依旧幼稚，但却在不断老去；告诉他，请务必变得坚强。</p>
<center>末</center>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的梦</title>
    <url>/2018/07/07/%E5%A5%87%E6%80%AA%E7%9A%84%E6%A2%A6/</url>
    <content><![CDATA[<div style="align: center"> <img src="http://blog-1252464519.costj.myqcloud.com/180707/mmexport1530890137221.jpg"/>
</div>
<p>他伸手把月亮关掉，只剩下自己和满天的星星。<br>
　有些渴了，抬头，割下一小块星空，星光璀璨，成色依旧不错。熟练地切块，榨汁，接了一杯。喝一口，凉凉的，还不错。看着这璀璨的一切，他很开心，又开始细细品味这种开心。不一会儿，开心的深处，涌出一股心酸——总是如此——这星光跨越多少年才到了这里？这漫天的星星又是为谁闪耀？为谁陨落？<br>
　他又伸手关掉所有星星，只剩下他和一片黑暗。<br>
　有些冷清，还是把星星打开吧！又是漫天的银白，不过整个儿是忽明忽暗的，他的眼睛快睁不开了。<br>
　“又是Dionysus那家伙，上次还没找他算账呢！今天不能再让他得逞了，不能睡过去，绝不。”<br>
　划拉着步子，来到一汪清水旁，深吸一口气，把沉甸甸的脑袋浸在一片冰凉之中。有些清醒了。皮肤受冷，血肉收缩，身体上凝结出几个小冰块。一共八个，正方体，玲珑剔透。里面有字！写的什么？拼起来——“我习于冷，志于成冰。”不一会儿，冰块化成了水，再一看，水也消失了。<br>
　“什么也没了？”　“刚才都在的。”<br>
　“真有字？”　“真有！”<br>
　“我不信，你怎么证明？”　“刚才都还在的！”<br>
　“现在呢？”　“也还在。”<br>
　“哪里呢，我没看见。”　“只是你看不见。”<br>
　“呀，确实是这样！”　“一直都是的。”<br>
　“你说的不错。”　“那当然。”<br>
　击掌！哗啦……溅了一身的水，水中的倒影也变得模糊，继而不见——他闭上双眼，睡了，在满天的星星下，一汪清水旁。<br>
　“你醒了，感觉好些没？”<br>
　他眨了眨眼睛，一笑。<br>
　“好多了，只是做了一个奇怪的梦。”<br>
　起身穿了衣服，叠好被子，拉开窗帘，阳光一下闯进屋里来，耀眼的很。他有些感慨，还是梦里好些——至少可以睡在卧室的床上，而且再也不会着了Dionysus那家伙的道！这样看，还得感谢他了？<br>
　“不能谢他！”　“为何不可？”<br>
　“就是他把你弄到这里来的，可别忘了。”　“你看，这里有床和卧室，多好。”<br>
　“你出门看过的，这里还有其他很多东西。”　“这倒是。”<br>
　“都很奇怪不是吗？”　“是的，都很奇怪。”<br>
　“明白就好！”　“嗯，谢谢你。”<br>
　击掌！哗啦…镜子碎了一地。收拾了下碎片，他又躺在床上，闭眼。<br>
　一汪清水旁，他醒了。满天的星星一闪一闪，好看极了。<br>
　“要是Dionysus在就好了。”</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>学习目标分类</title>
    <url>/2017/05/18/%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="Overview-58">Overview</h4>
<p>还是<em>OpenCV By Example</em>， 承接上文的目标分割和检测，这里用SVM进行了分类的学习。由于从PACKT下载的代码是基于QT的，而我。。开始编译OpenCV没有选QT支持，重新编译也一致出错，就暂时没去用QT的按钮那些功能，也就没QT进行编译了。。扯多了，回到正题。代码应该是有一些bug的，折腾了一下午才调试好…</p>
<p>原理还是比较简单的，处理的流程也较为清晰。对图片主要是进行了中值滤波，去除光纹，和灰度二值化提取轮廓的操作。抽取螺丝环，螺母，螺丝钉的面积和长宽比这两个特征进行训练，测试误差在2%以下，看书上的截图，原作的误差在7%左右…可能和OpenCV的改进有关吧。</p>
<h4 id="Code-50">Code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/ml.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::ml;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些全局变量</span></span><br><span class="line">Mat light_pattern;</span><br><span class="line">Ptr&lt;SVM&gt; svm;</span><br><span class="line"><span class="function">Scalar <span class="title">green</span><span class="params">(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)</span>, <span class="title">blue</span> <span class="params">(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span>, <span class="title">red</span> <span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光纹去除</span></span><br><span class="line"><span class="function">Mat <span class="title">removeLight</span><span class="params">(Mat img, Mat pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat aux;</span><br><span class="line">    <span class="comment">// Require change our image to 32 float for division</span></span><br><span class="line">    Mat img32, pattern32;</span><br><span class="line">    img.<span class="built_in">convertTo</span>(img32, CV_32F);</span><br><span class="line">    pattern.<span class="built_in">convertTo</span>(pattern32, CV_32F);</span><br><span class="line">    <span class="comment">// Divide the imabe by the pattern</span></span><br><span class="line">    aux= <span class="number">255</span>*(<span class="number">1</span>-(img32/pattern32));</span><br><span class="line">    <span class="comment">// Convert 8 bits format</span></span><br><span class="line">    aux.<span class="built_in">convertTo</span>(aux, CV_8U);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特征抽取，这里抽取面积及宽高比</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">float</span>&gt; &gt; <span class="built_in">ExtractFeatures</span>(Mat img, vector&lt;<span class="type">int</span>&gt;*left=<span class="literal">NULL</span>, vector&lt;<span class="type">int</span>&gt;*top=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    count_num +=1;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">float</span>&gt;&gt; output;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">    Mat input = img.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;Vec4i&gt;hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(input, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);</span><br><span class="line">    <span class="comment">// 检查被检测到的物体个数</span></span><br><span class="line">    <span class="keyword">if</span>(contours.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;contours.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        Mat mask = Mat::<span class="built_in">zeros</span>(img.rows, img.cols, CV_8UC1);</span><br><span class="line">        <span class="built_in">drawContours</span>(mask, contours, i, <span class="built_in">Scalar</span>(<span class="number">1</span>), FILLED, LINE_8, hierarchy, <span class="number">1</span>);</span><br><span class="line">        Scalar area_s = <span class="built_in">sum</span>(mask);</span><br><span class="line">        <span class="type">float</span> area = area_s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(area&gt;<span class="number">500</span>)&#123;<span class="comment">// 如果area大于面积最小阀值</span></span><br><span class="line">            RotatedRect r = <span class="built_in">minAreaRect</span>(contours[i]);</span><br><span class="line">            <span class="type">float</span> width = r.size.width;</span><br><span class="line">            <span class="type">float</span> height = r.size.height;</span><br><span class="line">            <span class="type">float</span> ar = (width&lt;height)?height/width:width/height;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储特征数据</span></span><br><span class="line">            vector&lt;<span class="type">float</span>&gt; row;</span><br><span class="line">            row.<span class="built_in">push_back</span>(area);</span><br><span class="line">            row.<span class="built_in">push_back</span>(ar);</span><br><span class="line">            output.<span class="built_in">push_back</span>(row);</span><br><span class="line">            <span class="comment">// 用于添加文字时候的定位</span></span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                left-&gt;<span class="built_in">push_back</span>(<span class="built_in">int</span>(r.center.x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                top-&gt;<span class="built_in">push_back</span>(<span class="built_in">int</span>(r.center.y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 显示特征抽取的结果</span></span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;Extract Features&quot;</span>, mask*<span class="number">255</span>);</span><br><span class="line">            <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片预处理</span></span><br><span class="line"><span class="function">Mat <span class="title">preprocessImage</span><span class="params">(Mat input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 灰度化</span></span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">channels</span>()!=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cvtColor</span>(input, input, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    Mat result;</span><br><span class="line">    <span class="comment">// Remove noise</span></span><br><span class="line">    Mat img_noise;</span><br><span class="line">    <span class="built_in">medianBlur</span>(input, img_noise, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//Apply the light pattern</span></span><br><span class="line">    Mat img_no_light;</span><br><span class="line">    img_noise.<span class="built_in">copyTo</span>(img_no_light);</span><br><span class="line">    <span class="comment">// 去除光纹</span></span><br><span class="line">    img_no_light= <span class="built_in">removeLight</span>(img_noise, light_pattern);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binarize image for segment</span></span><br><span class="line">    <span class="built_in">threshold</span>(img_no_light, result, <span class="number">30</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件批量读取图片，并进行特征抽取</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readFolderAndExtractFeatures</span><span class="params">(string folder, <span class="type">int</span> label, <span class="type">int</span> num_for_test,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    vector&lt;<span class="type">float</span>&gt;&amp;trainingData, vector&lt;<span class="type">int</span>&gt;&amp;responeseData,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    vector&lt;<span class="type">float</span>&gt;&amp;testData, vector&lt;<span class="type">float</span>&gt;&amp;testResponsesData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">images</span><span class="params">(folder)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(images.<span class="built_in">open</span>(folder) == <span class="literal">false</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Can not open the folder images&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat frame;</span><br><span class="line">    <span class="type">int</span> img_index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(images.<span class="built_in">read</span>(frame))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理图像</span></span><br><span class="line">        images&gt;&gt;frame;  <span class="comment">//  书上参考代码没有这句，貌似bug...</span></span><br><span class="line">        <span class="keyword">if</span>(!frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预处理</span></span><br><span class="line">            Mat pre = <span class="built_in">preprocessImage</span>(frame);</span><br><span class="line">            <span class="comment">// 提取特征</span></span><br><span class="line">            vector&lt;vector&lt;<span class="type">float</span>&gt;&gt; features = <span class="built_in">ExtractFeatures</span>(pre);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;features.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(img_index &gt;= num_for_test)&#123;</span><br><span class="line">                    trainingData.<span class="built_in">push_back</span>(features[i][<span class="number">0</span>]);</span><br><span class="line">                    trainingData.<span class="built_in">push_back</span>(features[i][<span class="number">1</span>]);</span><br><span class="line">                    responeseData.<span class="built_in">push_back</span>(label);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    testData.<span class="built_in">push_back</span>(features[i][<span class="number">0</span>]);</span><br><span class="line">                    testData.<span class="built_in">push_back</span>(features[i][<span class="number">1</span>]);</span><br><span class="line">                    testResponsesData.<span class="built_in">push_back</span>(<span class="built_in">float</span>(label));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            img_index ++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 做图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">plotTrainData</span><span class="params">(Mat trainData, Mat labels, <span class="type">float</span> *error=<span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> area_max, ar_max, area_min, ar_min;</span><br><span class="line">    area_max= ar_max= <span class="number">0</span>;</span><br><span class="line">    area_min= ar_min= <span class="number">99999999</span>;</span><br><span class="line">    <span class="comment">// Get the min and max of each feature for normalize plot image</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; trainData.rows; i++)&#123;</span><br><span class="line">        <span class="type">float</span> area= trainData.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,<span class="number">0</span>);</span><br><span class="line">        <span class="type">float</span> ar= trainData.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(area &gt; area_max)</span><br><span class="line">            area_max= area;</span><br><span class="line">        <span class="keyword">if</span>( ar &gt; ar_max )</span><br><span class="line">            ar_max= ar;</span><br><span class="line">        <span class="keyword">if</span>(area &lt; area_min)</span><br><span class="line">            area_min= area;</span><br><span class="line">        <span class="keyword">if</span>(ar &lt; ar_min)</span><br><span class="line">            ar_min= ar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Image for plot</span></span><br><span class="line">    Mat plot= Mat::<span class="built_in">zeros</span>(<span class="number">512</span>,<span class="number">512</span>,CV_8UC3);</span><br><span class="line">    <span class="comment">// Plot each of two features in a 2D graph using an image</span></span><br><span class="line">    <span class="comment">// where x is area and y is aspect ratio</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; trainData.rows; i++)&#123;</span><br><span class="line">        <span class="comment">// Set the X y pos for each data</span></span><br><span class="line">        <span class="type">float</span> area= trainData.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,<span class="number">0</span>);</span><br><span class="line">        <span class="type">float</span> ar= trainData.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x= (<span class="type">int</span>)(<span class="number">512.0f</span>*((area-area_min)/(area_max-area_min)));</span><br><span class="line">        <span class="type">int</span> y= (<span class="type">int</span>)(<span class="number">512.0f</span>*((ar-ar_min)/(ar_max-ar_min)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get label</span></span><br><span class="line">        <span class="type">int</span> label= labels.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i);</span><br><span class="line">        <span class="comment">// Set color depend of label</span></span><br><span class="line">        Scalar color;</span><br><span class="line">        <span class="keyword">if</span>(label==<span class="number">0</span>)</span><br><span class="line">            color= green; <span class="comment">// NUT</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(label==<span class="number">1</span>)</span><br><span class="line">            color= blue; <span class="comment">// ring</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(label==<span class="number">2</span>)</span><br><span class="line">            color= red; <span class="comment">// SCREW</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">circle</span>( plot,  <span class="built_in">Point</span>(x, y), <span class="number">3</span>,  color, <span class="number">-1</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(error!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; *error &lt;&lt; <span class="string">&quot;%&quot;</span>;</span><br><span class="line">        <span class="built_in">putText</span>(plot, ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>(), <span class="built_in">Point</span>(<span class="number">20</span>,<span class="number">512</span><span class="number">-40</span>), FONT_HERSHEY_SIMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;plot&quot;</span>, plot);</span><br><span class="line"><span class="comment">//    waitKey(0);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 训练并测试误差</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trainAndTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">float</span>&gt; trainingData;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; responsesData;</span><br><span class="line">    vector&lt;<span class="type">float</span>&gt; testData;</span><br><span class="line">    vector&lt;<span class="type">float</span>&gt; testResponsesData;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_for_test = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取螺母图像</span></span><br><span class="line">    <span class="built_in">readFolderAndExtractFeatures</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/&quot;</span></span><br><span class="line">                                         <span class="string">&quot;B04283_06_code/data/nut/tuerca_%04d.pgm&quot;</span>, <span class="number">0</span>,</span><br><span class="line">                                 num_for_test, trainingData, responsesData, testData, testResponsesData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取螺丝圈图像</span></span><br><span class="line">    <span class="built_in">readFolderAndExtractFeatures</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/&quot;</span></span><br><span class="line">                                         <span class="string">&quot;B04283_06_code/data/ring/arandela_%04d.pgm&quot;</span>, <span class="number">1</span>,</span><br><span class="line">                                 num_for_test, trainingData, responsesData, testData, testResponsesData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并处理螺丝</span></span><br><span class="line">    <span class="built_in">readFolderAndExtractFeatures</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/&quot;</span></span><br><span class="line">                                         <span class="string">&quot;9781785280948_Code/B04283_06_code/data/screw/tornillo_%04d.pgm&quot;</span>, <span class="number">2</span>,</span><br><span class="line">                                 num_for_test, trainingData, responsesData, testData, testResponsesData);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Num of train samples: &quot;</span>&lt;&lt;responsesData.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Num of test samples: &quot;</span>&lt;&lt;testResponsesData.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="comment">// Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">trainingDataMat</span><span class="params">(trainingData.size()/<span class="number">2</span> ,<span class="number">2</span>, CV_32FC1, &amp;trainingData[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">responses</span><span class="params">(responsesData.size(), <span class="number">1</span>, CV_32SC1, &amp;responsesData[<span class="number">0</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">testDataMat</span><span class="params">(testData.size()/<span class="number">2</span>, <span class="number">2</span>, CV_32FC1, &amp;testData[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">testRespones</span><span class="params">(testResponsesData.size(), <span class="number">1</span>, CV_32FC1, &amp;testResponsesData[<span class="number">0</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    svm = SVM::<span class="built_in">create</span>();</span><br><span class="line">    svm-&gt;<span class="built_in">setType</span>(SVM::C_SVC);</span><br><span class="line">    svm-&gt;<span class="built_in">setKernel</span>(SVM::CHI2);</span><br><span class="line">    svm-&gt;<span class="built_in">setTermCriteria</span>(<span class="built_in">TermCriteria</span>(TermCriteria::MAX_ITER, <span class="number">100</span>, <span class="number">1e-6</span>));</span><br><span class="line"></span><br><span class="line">    svm-&gt;<span class="built_in">train</span>(trainingDataMat, ROW_SAMPLE, responses);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(testResponsesData.<span class="built_in">size</span>() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Evaluation&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;============&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// test the ML model</span></span><br><span class="line">        Mat testPredict;</span><br><span class="line">        svm-&gt;<span class="built_in">predict</span>(testDataMat, testPredict);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Prediction Done&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// error handle</span></span><br><span class="line">        Mat errorMat = testPredict != testRespones;</span><br><span class="line">        <span class="type">float</span> error = <span class="number">100.0f</span> * <span class="built_in">countNonZero</span>(errorMat) / testResponsesData.<span class="built_in">size</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: &quot;</span>&lt;&lt;error&lt;&lt;<span class="string">&quot;%&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//plot data</span></span><br><span class="line">        <span class="built_in">plotTrainData</span>(trainingDataMat, responses, &amp;error);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">plotTrainData</span>(trainingDataMat, responses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load image to process</span></span><br><span class="line">    Mat img= <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/B04283_06_code/data/test.pgm&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span>(img.data==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error loading image &quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load image to process</span></span><br><span class="line">    light_pattern= <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/light.pgm&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(light_pattern.data==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// Calculate light pattern</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: Not light patter loaded&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">medianBlur</span>(light_pattern, light_pattern, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">trainAndTest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Preprocess image</span></span><br><span class="line">    Mat pre= <span class="built_in">preprocessImage</span>(img);</span><br><span class="line">    <span class="comment">////End preprocess</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract features</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos_top, pos_left;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">float</span>&gt; &gt; features= <span class="built_in">ExtractFeatures</span>(pre, &amp;pos_left, &amp;pos_top);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Num objects extracted features &quot;</span> &lt;&lt; features.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Mat img_output= img.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="built_in">cvtColor</span>(img_output, img_output, COLOR_GRAY2BGR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; features.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data Area AR: &quot;</span> &lt;&lt; features[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; features[i][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mat <span class="title">trainingDataMat</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, CV_32FC1, &amp;features[i][<span class="number">0</span>])</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Features to predict: &quot;</span> &lt;&lt; trainingDataMat &lt;&lt; endl;</span><br><span class="line">        <span class="type">float</span> result= svm-&gt;<span class="built_in">predict</span>(trainingDataMat);</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stringstream ss;</span><br><span class="line">        Scalar color;</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;</span><br><span class="line">            color= green; <span class="comment">// NUT</span></span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;NUT&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">1</span>)&#123;</span><br><span class="line">            color= blue; <span class="comment">// RING</span></span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;RING&quot;</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">2</span>)&#123;</span><br><span class="line">            color= red; <span class="comment">// SCREW</span></span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;SCREW&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">putText</span>(img_output,</span><br><span class="line">                ss.<span class="built_in">str</span>(),</span><br><span class="line">                <span class="built_in">Point2d</span>(pos_left[i], pos_top[i]),</span><br><span class="line">                FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                <span class="number">0.4</span>,</span><br><span class="line">                color);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//vector&lt;int&gt; results= evaluate(features);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show images</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Binary image&quot;</span>, pre);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, img_output);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处的测试结果还是不错的，5个部件全部识别成功了。</p>
</blockquote>
<p>输出：</p>
<pre><code>Num of train samples: 146
Num of test samples: 67
Evaluation
============
Prediction Done
Error: 1.49254%
Num objects extracted features 5
Data Area AR: 2084 1.54013
Features to predict: [2084, 1.54013]
2
Data Area AR: 1171 1.12195
Features to predict: [1171, 1.1219512]
0
Data Area AR: 1045 1.97279
Features to predict: [1045, 1.9727893]
0
Data Area AR: 1486 1.12069
Features to predict: [1486, 1.1206896]
2
Data Area AR: 1620 1
Features to predict: [1620, 1]
1
</code></pre>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051804.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>实时视频中面具覆盖的实现</title>
    <url>/2017/05/18/%E5%AE%9E%E6%97%B6%E8%A7%86%E9%A2%91%E4%B8%AD%E9%9D%A2%E5%85%B7%E8%A6%86%E7%9B%96%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="Overview-59">Overview</h4>
<p><em>OpenCV By Example</em>第七章中的一个例子，识别算法是直接加载的给定的级联文件（书中的代码给提供了一份，OpenCV官方应该也能找的到）。检测到人脸之后就是面具的覆盖，这个过程类似之前的<a href="http://datahonor.com/2017/04/28/OpenCV%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9AROI/">logo添加</a>,就是logo(此处是facemask)和背景(此处是人脸ROI)的对称的操作，之后将两者直接合并即可。</p>
<h4 id="Code-51">Code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string faceCascadeName = <span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/books/CV/2-ing/9781785280948_Code/B04283_07_code/code/cascadeFiles/haarcascade_frontalface_alt.xml&quot;</span>;</span><br><span class="line">    CascadeClassifier faceCascade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !faceCascade.<span class="built_in">load</span>(faceCascadeName) )</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error loading cascade file. Exiting!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat faceMask = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/mask2.jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !faceMask.data )</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error loading mask image. Exiting!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current frame</span></span><br><span class="line">    Mat frame, frameGray;</span><br><span class="line">    Mat frameROI, faceMaskSmall;</span><br><span class="line">    Mat grayMaskSmall, grayMaskSmallThresh, grayMaskSmallThreshInv;</span><br><span class="line">    Mat maskedFace, maskedFrame;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the capture object</span></span><br><span class="line">    <span class="comment">// 0 -&gt; input arg that specifies it should take the input from the webcam</span></span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you cannot open the webcam, stop the execution!</span></span><br><span class="line">    <span class="keyword">if</span>( !cap.<span class="built_in">isOpened</span>() )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create GUI windows</span></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Frame&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scaling factor to resize the input frames from the webcam</span></span><br><span class="line">    <span class="type">float</span> scalingFactor = <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;Rect&gt; faces;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate until the user presses the Esc key</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Capture the current frame</span></span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resize the frame</span></span><br><span class="line">        <span class="built_in">resize</span>(frame, frame, <span class="built_in">Size</span>(), scalingFactor, scalingFactor, INTER_AREA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert to grayscale</span></span><br><span class="line">        <span class="built_in">cvtColor</span>(frame, frameGray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Equalize the histogram</span></span><br><span class="line">        <span class="built_in">equalizeHist</span>(frameGray, frameGray);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Detect faces</span></span><br><span class="line">        faceCascade.<span class="built_in">detectMultiScale</span>(frameGray, faces, <span class="number">1.1</span>, <span class="number">2</span>, <span class="number">0</span>|CV_HAAR_SCALE_IMAGE, <span class="built_in">Size</span>(<span class="number">30</span>, <span class="number">30</span>) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw green rectangle around the face</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Rect <span class="title">faceRect</span><span class="params">(faces[i].x, faces[i].y, faces[i].width, faces[i].height)</span></span>;</span><br><span class="line">            <span class="built_in">rectangle</span>(frame, faceRect, <span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Custom parameters to make the mask fit your face. You may have to play around with them to make sure it works.</span></span><br><span class="line">            <span class="type">int</span> x = faces[i].x - <span class="built_in">int</span>(<span class="number">0.1</span>*faces[i].width);</span><br><span class="line">            <span class="type">int</span> y = faces[i].y - <span class="built_in">int</span>(<span class="number">0.0</span>*faces[i].height);</span><br><span class="line">            <span class="type">int</span> w = <span class="built_in">int</span>(<span class="number">1.3</span> * faces[i].width);</span><br><span class="line">            <span class="type">int</span> h = <span class="built_in">int</span>(<span class="number">1.3</span> * faces[i].height);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Extract region of interest (ROI) covering your face</span></span><br><span class="line">            frameROI = <span class="built_in">frame</span>(<span class="built_in">Rect</span>(x,y,w,h));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Resize the face mask image based on the dimensions of the above ROI</span></span><br><span class="line">            <span class="built_in">resize</span>(faceMask, faceMaskSmall, <span class="built_in">Size</span>(w,h));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Convert the above image to grayscale</span></span><br><span class="line">            <span class="comment">// 灰度化</span></span><br><span class="line">            <span class="built_in">cvtColor</span>(faceMaskSmall, grayMaskSmall, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Threshold the above image to isolate the pixels associated only with the face mask</span></span><br><span class="line">            <span class="comment">// 二值化，grayMaskSmallThresh在面具主体为白，其余为黑色</span></span><br><span class="line">            <span class="built_in">threshold</span>(grayMaskSmall, grayMaskSmallThresh, <span class="number">230</span>, <span class="number">255</span>, CV_THRESH_BINARY_INV);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create mask by inverting the above image (because we don&#x27;t want the background to affect the overlay)</span></span><br><span class="line">            <span class="comment">// grayMaskSmallThreshInv在面具主体为黑色，其余为白色</span></span><br><span class="line">            <span class="built_in">bitwise_not</span>(grayMaskSmallThresh, grayMaskSmallThreshInv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use bitwise &quot;AND&quot; operator to extract precise boundary of face mask</span></span><br><span class="line">            <span class="comment">// 扣取面具主体，周围为黑色</span></span><br><span class="line">            <span class="built_in">bitwise_and</span>(faceMaskSmall, faceMaskSmall, maskedFace, grayMaskSmallThresh);</span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;maskedFace&quot;</span>, maskedFace);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use bitwise &quot;AND&quot; operator to overlay face mask</span></span><br><span class="line">            <span class="comment">// 挖去ROI中的脸部图像，变为黑色，其余保持不变</span></span><br><span class="line">            <span class="built_in">bitwise_and</span>(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv);</span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;maskedFrame&quot;</span>, maskedFrame);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the above masked images and place it in the original frame ROI to create the final image</span></span><br><span class="line">            <span class="comment">// 面具部分覆盖脸部主体，其余部分合成后保持不变</span></span><br><span class="line">            <span class="built_in">add</span>(maskedFace, maskedFrame, <span class="built_in">frame</span>(<span class="built_in">Rect</span>(x,y,w,h)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show the current frame</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Frame&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the keyboard input and check if it&#x27;s &#x27;Esc&#x27;</span></span><br><span class="line">        <span class="comment">// 27 -&gt; ASCII value of &#x27;Esc&#x27; key</span></span><br><span class="line">        ch = <span class="built_in">waitKey</span>( <span class="number">30</span> );</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="number">27</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the video capture object</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all windows</span></span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051805.png" alt=""></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假小记</title>
    <url>/2018/03/03/%E5%AF%92%E5%81%87%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>四十天的寒假马上就要过去了，原计划是要读四本书：《堂吉诃德》，<em>Data Structure Using C</em>, <em>Linear Algebra Done Right</em>和<em>Programming In Haskell</em>。</p>
<p><em>Data Structure Using C</em></p>
<blockquote>
<p>各种数据结构都讲的比较详细，后面的搜索和排序算法也写的挺好的。不过书上的代码有时候会有Bug…前面几章的习题基本过了一遍，后面没太有时间了，就把书上的代码都跑了一遍。笔记用Zim做的，放在<a href="https://github.com/shenxiangzhuang/DataStructureUsingC">Github</a></p>
</blockquote>
<p><em>Linear Algebra Done Right</em></p>
<blockquote>
<p>一直听说这书比较好，所以拿来看下，大约花了二十多天才看完。书从Vector Space（而不是从行列式…）开始构建整个Linear Algebra的框架，全新的视角，收益良多。大部分证明可以看懂，不过自己写还是不太行…</p>
</blockquote>
<p><em>Programming In Haskell</em></p>
<blockquote>
<p>这本放到最后看的，没有时间了，所以返校前只看到了Chap8。本来想赶着看完，不过感觉看得太急没什么好处…就暂时搁置了。之后估计也没太多时间学Haskell了，差不多要等考研之后了。</p>
</blockquote>
<p>《堂吉诃德》</p>
<blockquote>
<p>虽然是讽刺骑士的小说，但是书上有很多值得深思的故事（尤其是那些和主人公无太大关系，很明显插入的故事）。另外，在这本书找到了很多答案——生活的答案。骑士！骑士！</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>小小白搬砖记——2017</title>
    <url>/2017/12/30/%E5%B0%8F%E5%B0%8F%E7%99%BD%E6%90%AC%E7%A0%96%E8%AE%B0%E2%80%94%E2%80%942017/</url>
    <content><![CDATA[<h4 id="Overview-60">Overview</h4>
<p>小小白是在群里用的昵称，嗯，与肤色无关。2017年依旧很快，这里记录下今年搬砖的情况。</p>
<h4 id="数学">数学</h4>
<p><strong>数分</strong>。16年下半年（大二上）开始学的，一学期看了大概六章，基本看不懂，课后题也做不出…台大的公开课配合着看也是力不从心。后17年上半年（大二下）在万门上看公开课，依然跟不上，遂止。目前打算大四下用华东师范大学那本系统学了。</p>
<p><strong>微积分</strong>。看的是 <em>Calculus With Analytic Geometry</em>,暑假提前来学校大概一个月，除了曲面积分那里看得比较快，其他内容是撸完了的，习题未作，打算重读的时候做下。</p>
<p><strong>线性代数</strong>。看了点<em>Practical Linear Algebra</em>，当闲书看的，目前不打算去深入学。</p>
<p><strong>数理统计</strong>。开非参的课，开始有点懵，查数理统计资料。看的厦大程细玉的《数理统计》，写的很好。目前还剩两章多一点没看完，考完试打算先撸完这本。同时看了<em>Statistical Inference</em>的前三章，一开始是没有做题的，后发现往后看不懂…于是开始刷课后题，大概一个小时搞清楚一道题，尚可。受益匪浅，打算18年看完。</p>
<p><strong>概率论</strong>。<em>Statistical Inference</em>前几章也是概率论的内容，基本上是很充分了。不过偶然拿到了清华教概率论的教材和Reference Books。所以又买了本<em>Elementary Probability Theory</em>来看，只看了第一章，难度尚可，打算寒假撸完。</p>
<h4 id="编程">编程</h4>
<p><strong>Cpp</strong>。上半年还是玩的CV，看了不少书，感觉<em>OpenCV 3 Computer Vision Application Programming Cookbook - Third Edition</em>算是很好的入门书，也在博客上整理了这本书的笔记。另外<em>OpenCv By Example</em>也还可以，以例子为主导，挺好玩的。最后，总算达到预想的检测行人的目标，虽然用的是已经被业界摒弃的Hog+SVM…由于多种原因，大三课多，老爷机跑不动NN，DL理论未学等，暂时放下CV。买了本<em>Discovering Modern C++</em>,感觉难度还行，不过目前Cpp玩的不熟悉（CV用到的Cpp的东西比较少…)，打算慢慢看这本。</p>
<p><strong>C</strong>。打算正式开始系统学习C，从数据结构入手，用的<em>Data Structure Using C</em>。只看了一百多页，寒假撸完。</p>
<p><strong>Python</strong>。写了几个爬虫，并进行了简单的数据分析。看了几本可视化的书，基本都是PACKT的。大致看了一遍《统计学习方法》，Python实现了前几章的几个简单的算法。<em>Machine Learning In Action</em>看到了SVM那里，前几章都写的很精彩。</p>
<p><strong>Octave/Matlab</strong>。在Coursera撸完了Andrew Ng的ML课程，用的Octave做作业。话说这个课程还是挺好的，最后成绩也还行，没钱买证书2333。</p>
<p><strong>R</strong>。为了做作业，撸了几章<em>R in Action</em>…其他非参数统计，EDA，统计预测和决策的作业也都是用R来做的…嗯，写作业方便的很呢。</p>
<p><strong>Haskell</strong>。接触没多久，很吸引人的一门语言，当然也难的很…知道用它可以证明定理的时候，瞬间给跪orz…</p>
<h4 id="文史">文史</h4>
<p>今年还是重读了一些书的。《穆斯林的葬礼》、《热爱生命》、《旷世的忧伤》。<br>
新看的书也很多不错的。王小波全集（其中最喜欢《寻找无双》、《爱你就像爱生命》），《第二十二条军规》(好看!)、《海狼》、《数学之美》。看了点《史记》，三皇五帝也是萌的不行啊:-)</p>
<h4 id="杂记">杂记</h4>
<p>立志锻炼，以求跑半马，然而最多只跑到12KM，开学之后就很少去跑步了…跟同学学游泳，去了一次大致弄懂了流程，然后一直学了快2个小时几乎没休息，游泳肩了,后，溜了溜了…<br>
做了两件别人看来似乎不可能的事。有一件，自认无望，然后基本成了。另一件，自认很稳，然而差得远…<br>
2018你好，很高兴认识你~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>当我们谈论吃饭时我们在谈什么:-)</title>
    <url>/2021/02/28/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%AE%BA%E5%90%83%E9%A5%AD%E6%97%B6%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1>概览</h1>
<p>如题,仅仅是出于好奇而已. 大致分为两个部分,校园卡数据爬取与数据分析.完整项目见<a href="https://github.com/shenxiangzhuang/Sysu-Card">Github</a>, 请合理使用!</p>
<h2 id="数据爬取">数据爬取</h2>
<p>首先是内网才能够登录,总站是:<a href="http://card.sysu.edu.cn">http://card.sysu.edu.cn</a></p>
<p>总的来说比较简单,大致分为两步:表单提交登录; 获取数据.</p>
<h3 id="表单提交登录">表单提交登录</h3>
<p>这里表单的形式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#123;&#x27;sno&#x27;: sno,</span><br><span class="line">&#x27;pwd&#x27;: npwd,</span><br><span class="line">&#x27;ValiCode&#x27;: verify_code,</span><br><span class="line">&#x27;remember&#x27;: &#x27;0&#x27;,</span><br><span class="line">&#x27;uclass&#x27;: &#x27;1&#x27;,</span><br><span class="line">&#x27;json&#x27;: &quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抓包可以看到<code>sno</code>就是自己的学号;<code>pwd</code>是密码,但是是<strong>加密后的密码</strong>; <code>ValiCode</code>是验证码,这里就是简单的<strong>数字验证码</strong>;其他几个字段默认不变即可.</p>
<p>数字验证码直接找到接口down下来然后显示,手动输入即可. 至于密码的加密方式…这个接触的不多,大概就知道base64和md5这些,然后我就在登录后的首页Ctrl+U, Ctrl+F, base64…Ok, 还真的就写在源码里面, lucky:-)</p>
<p>所以手动收入验证码,把密码用base64加密传入即可构建完整表单.</p>
<h3 id="获取数据">获取数据</h3>
<p>获取数据同样需要提交数据查看的表单,抓包看到的格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataPayload = &#123;</span><br><span class="line">&quot;sdate&quot;: &quot;2019-01-01&quot;,</span><br><span class="line">&quot;edate&quot;: &quot;2021-01-05&quot;,</span><br><span class="line">&quot;account&quot;: account,</span><br><span class="line">&quot;page&quot;: &quot;1&quot;,</span><br><span class="line">&quot;rows&quot;: &quot;15&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是起止日期,第几页,以及每页的行数.这里的account抓包看到是一个数字,和学号身份证号看着不太相关,所以就去前面的请求去找,于是发现了名为<code>GetCardInfoByAccountNoParm</code>的请求…lucky:-) 所以先请求(也是POST)这个地址获取到自己账户的<code>account</code>,之后传入表达请求即可.</p>
<blockquote>
<p>注意代码里为了减少请求次数,在表单中调大了每页显示的数据条数.这也是比较常用的一种方式.只需要先查出来总的数据条数,之后做个总页数计算即可.</p>
</blockquote>
<h2 id="数据简单分析">数据简单分析</h2>
<p>学五真的不好吃,但是它太近了Orz</p>
<p><img src="https://i.loli.net/2021/03/01/EdwqRn3j9TOPG8g.jpg" alt="交易类型与地点"></p>
<p>这空白的半年就很魔幻233</p>
<p><img src="https://i.loli.net/2021/03/01/CxNKyYEz4enTqpr.jpg" alt="就餐日期-金额"></p>
<p>早餐现状:-)</p>
<p><img src="https://i.loli.net/2021/03/01/Y21IL9xphT6WirE.jpg" alt="就餐时间-金额"></p>
<p>每餐10~15块的样子</p>
<p><img src="https://i.loli.net/2021/03/01/Bo1fVLmAtgKqiY3.jpg" alt="每餐金额"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机学习算法的对偶形式</title>
    <url>/2017/03/03/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<p>李航老师《统计学习方法》第二章笔记。<br>
关于感知机学习算法对偶形式的简单实现[ Python ]。<br>
之前有<a href="http://datahonor.com/2017/03/03/%E5%8E%9F%E5%A7%8B%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%A8%A1%E5%9E%8B/#more">原始感知机学习算法</a>的实现。</p>
<h5 id="算法原理-2">算法原理</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/21.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/22.png" alt=""></p>
<h5 id="算法实现-2">算法实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S1--&gt;随机生成训练集并标注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train matrix</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_data</span>():</span><br><span class="line">    M1 = np.random.random((<span class="number">100</span>, <span class="number">2</span>))</span><br><span class="line">    M11 = np.column_stack((M1, np.ones(<span class="number">100</span>)))</span><br><span class="line"></span><br><span class="line">    M2 = np.random.random((<span class="number">100</span>, <span class="number">2</span>)) - <span class="number">0.7</span></span><br><span class="line">    M22 = np.column_stack((M2, np.ones(<span class="number">100</span>) * (-<span class="number">1</span>)))</span><br><span class="line">    <span class="comment"># 合并两类，并将位置索引加到最后</span></span><br><span class="line">    MA = np.vstack((M11, M22))</span><br><span class="line">    MA = np.column_stack((MA, <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">200</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作图操作</span></span><br><span class="line">    plt.plot(M1[:, <span class="number">0</span>], M1[:, <span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">    plt.plot(M2[:, <span class="number">0</span>], M2[:, <span class="number">1</span>], <span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">    <span class="comment"># 为了美观，根据数据点限制之后分类线的范围</span></span><br><span class="line">    min_x = np.<span class="built_in">min</span>(M2)</span><br><span class="line">    max_x = np.<span class="built_in">max</span>(M1)</span><br><span class="line">    <span class="comment"># 分隔x,方便作图</span></span><br><span class="line">    x = np.linspace(min_x, max_x, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 此处返回 x 是为了之后作图方便</span></span><br><span class="line">    <span class="keyword">return</span> MA, x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S2--&gt;GRAM计算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gram</span>(<span class="params">MA</span>):</span><br><span class="line">    GRAM = np.empty(shape=(<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(MA)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(MA)):</span><br><span class="line">            GRAM[i, j] = np.dot(MA[i,][:<span class="number">2</span>], MA[j,][:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> GRAM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S3--&gt;训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">alpha, b, xi, yi, yN, index, GRAM</span>):</span><br><span class="line">    pa1 = alpha * yN</span><br><span class="line">    pa2 = GRAM[:, index]</span><br><span class="line">    num = yi * (np.dot(pa1, pa2) + b)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练training data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">MA, alpha, b, GRAM, yN</span>):</span><br><span class="line">    <span class="comment"># M 存储每次处理后依旧处于误分类的原始数据</span></span><br><span class="line">    M = []</span><br><span class="line">    <span class="keyword">for</span> sample <span class="keyword">in</span> MA:</span><br><span class="line">        xi = sample[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">        yi = sample[-<span class="number">2</span>]</span><br><span class="line">        index = <span class="built_in">int</span>(sample[-<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 如果为误分类，改变alpha,b</span></span><br><span class="line">        <span class="comment"># n 为学习率</span></span><br><span class="line">        <span class="keyword">if</span> func(alpha, b, xi, yi, yN, index, GRAM) &lt;= <span class="number">0</span>:</span><br><span class="line">            alpha[index] += n</span><br><span class="line">            b += n * yi</span><br><span class="line">            M.append(sample)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(M) &gt; <span class="number">0</span>:</span><br><span class="line">        train(M, alpha, b, GRAM, yN)</span><br><span class="line">    <span class="keyword">return</span> alpha, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作出分类线的图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_classify</span>(<span class="params">w, b, x, rate0</span>):</span><br><span class="line">    y = (w[<span class="number">0</span>] * x + b) / ((-<span class="number">1</span>) * w[<span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.title(<span class="string">&#x27;Accuracy = &#x27;</span> + <span class="built_in">str</span>(rate0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S4--&gt;生成测试集并测试模型准确性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成testing data 并作图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_data</span>():</span><br><span class="line">    M = np.random.random((<span class="number">50</span>, <span class="number">2</span>))</span><br><span class="line">    plt.plot(M[:, <span class="number">0</span>], M[:, <span class="number">1</span>], <span class="string">&#x27;*y&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对传入的testing data 的单个样本进行分类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">w, b, test_i</span>):</span><br><span class="line">    <span class="keyword">if</span> np.sign(np.dot(w, test_i) + b) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据，返回正确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">w, b, test_data</span>):</span><br><span class="line">    right_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> test_i <span class="keyword">in</span> test_data:</span><br><span class="line">        classx = classify(w, b, test_i)</span><br><span class="line">        <span class="keyword">if</span> classx == <span class="number">1</span>:</span><br><span class="line">            right_count += <span class="number">1</span></span><br><span class="line">    rate = right_count / <span class="built_in">len</span>(test_data)</span><br><span class="line">    <span class="keyword">return</span> rate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作出学习率——准确率的图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_n_rate</span>(<span class="params">rate_l</span>):</span><br><span class="line">    <span class="comment"># plot n-rate</span></span><br><span class="line">    n_l = <span class="built_in">sorted</span>([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> rate_l.keys()])</span><br><span class="line">    y = [<span class="built_in">float</span>(rate_l[n_l[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n_l))]</span><br><span class="line">    <span class="built_in">print</span>(n_l, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    plt.plot(n_l, y, <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;n-accuracy&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    MA, x = get_train_data()</span><br><span class="line">    test_data = get_test_data()</span><br><span class="line">    GRAM = get_gram(MA)</span><br><span class="line">    yN = MA[:, <span class="number">2</span>]</span><br><span class="line">    xN = MA[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 定义初始值</span></span><br><span class="line">    alpha = [<span class="number">0</span>] * <span class="number">200</span></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 初始化最优的正确率</span></span><br><span class="line">    rate0 = <span class="number">0</span></span><br><span class="line">    rate_l = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#    print(alpha,b)</span></span><br><span class="line">    <span class="comment">#    循环不同的学习率n,寻求最优的学习率，即最终的rate0</span></span><br><span class="line">    <span class="comment">#    w0,b0为对应的最优参数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0.01</span>, <span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        n = i</span><br><span class="line">        alpha, b = train(MA, alpha, b, GRAM, yN)</span><br><span class="line">        alphap = np.column_stack((alpha * yN, alpha * yN))</span><br><span class="line">        w = <span class="built_in">sum</span>(alphap * xN)</span><br><span class="line">        rate = test(w, b, test_data)</span><br><span class="line">        <span class="comment"># print(w,b)</span></span><br><span class="line">        rate = test(w, b, test_data)</span><br><span class="line">        <span class="keyword">if</span> rate &gt; rate0:</span><br><span class="line">            rate_l[n] = rate</span><br><span class="line">            rate0 = rate</span><br><span class="line">            w0 = w</span><br><span class="line">            b0 = b</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Until now, the best result of the accuracy on test data is &#x27;</span> + <span class="built_in">str</span>(rate))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;with w=&#x27;</span> + <span class="built_in">str</span>(w0) + <span class="string">&#x27; b=&#x27;</span> + <span class="built_in">str</span>(b0))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------------------&#x27;</span>)</span><br><span class="line">            <span class="comment">#     在选定最优的学习率后，作图</span></span><br><span class="line">    plot_classify(w0, b0, x, rate0)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作出学习率——准确率的图</span></span><br><span class="line">    plot_n_rate(rate_l)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/23.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/24.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch2/25.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Analysis</tag>
        <tag>ML</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>我这个人呢</title>
    <url>/2017/07/09/%E6%88%91%E8%BF%99%E4%B8%AA%E4%BA%BA%E5%91%A2/</url>
    <content><![CDATA[<p>这几天比较闲，就来这里随便写点东西，好在知道小站的人不多，就当作一份笔记吧。</p>
<p>记得马克思他老人家说过，人是社会关系的总和。仔细想来，这是经得起推敲的。假设是个好词，我们假设将一个人从小放在孤岛之上生活，那么必然——说实在的——他不能被叫做是人了，因为他将不具有现代意义上人的一些基本能力，比如语言。而我们，作为一个人，固然是一个独立的个体，但是我们之所以成为现在的自己，完全和我们见到的人，遇到的事情，所处的环境有关。而对我们每个人影响最大的还是我们遇到的人——除自己以外其他的个体——他们组成了我们，我们是他们，他们也是我们。</p>
<p>就我自己而言，在这二十年里，遇到了太多有趣的人，可以说他们就是我的缩影，也可以说我就是他们每一个人。因为，时隔多年，他们的言行举止都在时刻影响着我。趁着宁静的夜，我想一下他们都是谁呢？</p>
<p>在读小学时，我就是瘦瘦小小的身材，偶尔会被人欺负。但生活总是待我不薄，我有一个好朋友。有一次我被欺负，哭了，他“气势汹汹”地让我带他找那个人“寻仇”。我们去了，回来时，我俩一起哭的。那时候我知道，这应该就是朋友。如今已经十几年过去了，挨欺负的和欺负人的，我们三个成了很好的朋友。现在，我们对当年的事都直言不讳，一回忆就开心——我们都曾经“喜欢”同班的一个小女生呢！然后，我们商量把女孩“让”给其中一个，因为他最帅，打架最厉害，我们都承认的。那份童稚，怀念至今，和我熟识的人很明显会看出我时常有些幼稚。那份童稚中有我，有他们，这些无疑是我这个人的一部分。</p>
<p>后来离开家去外面读书，五年级，寄宿。那时爱哭，后来发现哭似乎没什么用呢（哭多了是会累的），于是我就不经常哭了，那时候我大概十来岁的样子。慢慢地，我学会独立，学会坚强，学会面对。有一个同来读书的小伙伴，我从未见过他哭，几年后我偶尔问他：为什么没见你哭过呢？他说，楼下有个卫生间的。我笑了。原来我们每个人，都是一步一步走过来的，没有人例外。正如有句话所说，不要到处宣扬自己的内心，每个人都有自己的故事。从五年级到现在大学，近十年的寄宿生活，从同一屋檐下的他们那里比我学到哭也许并不会起作用呢，伤口呢还是自己舔来得靠谱。但是，谁不想哭呢？我这个人呢，又开始胡说八道了。</p>
<p>高中呢，离家就更远了。当时学习算是比较好，所以几乎听不到什么真话的（也可能不对）。但是有一个同学不一样，她不管这些，我有什么不对的地方，她能指着鼻子骂我。我只能回尴尬一笑，内心却是开心。现在，我的朋友不多，但她算是顶好的一个。因为能说真话的人太少，好容易遇见一个，不能弄丢了不是。（自认为）我这个人呢是不坏的，从她那里我知道，不坏的人喜欢听实话——即使再难听呢。所以，这些年，我告诉自己要做个老实人。我还年轻，应该纯粹点，不然人家又该说我太物质了（这里可能也不对，我可能不太在意别人的看法）。不管怎样，这也是我。</p>
<p>高考失利（不喜欢这个词，但是大家都用呢，姑且先留下。其实不算是失利）后，奔往济南。当真是如吉普林所言，“看着自己新手所建立的大厦轰然倒塌”。不过当时没有想着“低身拾起残废的工具把他重建”，说实话，我有些厌倦了（其实我也不知道在厌倦什么）。我做兼职，因为我太笨了（我的朋友也说这个，问为什么会有人要我这个人做员工呢，但是真有，不知道他们怎么想的），所以搞得头破血流（一点不疼，真的，没什么太大感觉，可惜把衣服上沾上了血，还要好好洗，有些麻烦）。后来伤好了，回去工作，培训新人（是体力活，不过也要培训下），恍然如梦。直到有一次，教一位大我二十多岁的阿姨，阿姨说，谢谢您，沈老师（在济南，尊称人都是用“老师”，可能取自“三人行必有我师”，我喜欢这个，文化底蕴嘛）。听到过太多谢谢，只有这一次不是靠给别人讲题（或是和高考学习相关的方法）听到人那样真诚地说“谢谢您”。我乐了，真的。我知道，原来除了学习，我还可以在别的地方成就自己。原来，生活可以这样呢。那一刻，我弯腰拾起来角落里的自信说，‘你好，幸会’。这也是我，在超市，穿着红马甲（应该是紫色的那件，公司不给穿），和推销酸奶的小女生说笑，等经理路过时——大声对女孩说，嗨，帮忙拿两箱酸奶好吗，仓库等着要呢。我笑，女生也笑，经理也笑，嗨呀真好。</p>
<p>大学呢，也有很多的人很有趣的，不过现在比较晚了，要去睡了（好多人都让我早睡，所以不能过分，他们会伤心的），早晨起来或是什么时候再写吧。</p>
<p>========好了，这是第二天上午了已经，接着写完吧================</p>
<p>经过高三暑假那段日子，我是当真知道要珍惜学校的生活了，能读书真好（可能像假的似的，但是这不是，我那时真的这样想，现在也是）。遇见一个朋友，一个胖子，我们住在一个宿舍，被称作舍友。从他那里，我学到的是一种勇气（是的，勇气，这东西之前我也有，不过不太一样）。他对生活算是认真的，不过在别人看来可能是一团糟。不管怎样，他总是乐呵呵的，发自内心的那种——世界呢，他们呢，不在乎呢。他知道自己在干嘛（虽说不是那么上进），而大部分人是不知道的。现在的我，走在路上也会时而肆无忌惮地仰天大笑（因为真的想笑嘛）。这也是我。</p>
<p>有次生病，原因是久坐和熬夜（当然是在网上查的），我觉着这是“绝症”了，因为很难改的（经常坐在电脑前面写程序或者玩游戏啥的）。后来，我的另外一个舍友跑去外面帮我拿药。说真的，我很感动。他什么也没说，一笑，我也什么也没说（说声谢谢似乎过于苍白，其他也不知道说啥），一笑。我明白，有些东西是不需要用语言这种介质去表达的，他可以直接表达出来，不走任何弯路。现在的我，对有些事有时候也是懒得去说（同学偶尔说我总是那么神秘，我自己真的并不知道），说也是只言片语，太麻烦了。这也是我。</p>
<p>有次航班延误，和同行的同学玩成语接龙。一个同学接不上了，边上坐着的空姐顺着就接了一句——“世外桃源”（我记得很清，怎么也忘不了）。她就坐在我旁边，我微笑着看她（是的，微笑是学的，不过可能不像，并不能算作他们所说的微笑），她也一笑，真心的那种，不同于面具，无关于工作的笑，真的好看呢。我想，原来她们也和我们每个人一样——是个人，不是机器呢。遇见很多所谓的人，真的与机器无异，他们有面具机器（变脸很快的），声音机器（声音在男生和女生面前是不一样的，神奇吧）， 高精度识别机器（他们号称以自己多年的器龄可以一眼看透别人）， 推理机器（他们可以从一个的一句话推断整个人的人格， 通过一个人的衣着推断整个人的灵魂，厉害吧？我是及其怕这种机器的， 因为我对衣着的认识是取暖蔽体。我有个同学和我谈起过这个，不过她不能算作机器人，说实话的人怎么可能是机器人呢），等等。所以，我时刻告诫自己，要做个人，尽量做个好人（稍微坏点也成，但是不能做机器人呢）。所以吧，等你看到一个怪人（千真万确是人）和一堆机器打招呼问：“您好，您是人吗？是人的话交个朋友吧，我很孤独的”，那么这个人八成就是我了。这也是我。</p>
<p>还是那次和同学候机，我拿她那个玩偶在玩，她叫睡萌娃娃。我扔下手机，玩的不亦乐乎，同学说我童心未泯。嗯？这是不是说明大部分人都已经“泯”去了“童心”呢？为什么会被“泯”去呢，又不是个坏的东西？我这么想着，也是一笑（其实我真不知道说什么，何况一会就要把玩偶还她了，我得抓紧玩会）。可能我真的有时候像个小孩子，这也是我一直把“不秩稚童”作为自己的很多网站ID的原因吧。一个从来不遵守秩序（不想，也不去遵守，当然要吃苦头的。这个秩序呢，其中也许就包括，长大了就要“泯”去“童心”）的小孩子。这也是我。</p>
<p>大学还在继续，生活还在继续，我也还在继续。只要我还和别人（除外以外其他的个体）接触，那么我这个人呢，就一直是个未完成式（大部分人都是的，对吧？），我将是他们，他们也将是我。也许我像机器太少，也许是因为不太遵守“秩序”，我这个人呢，似乎和这个世界格格不入。我觉着最大的原因在于我虽说与其他人接触，但我不在乎大部分人对自己的看法（我在乎自己的看法和说实话的人的看法），我活给自己和喜欢的人看，而大部分人是活给所有人看（我都有点累了，不知道他们怎样）。</p>
<p>既然与这大时代“格格不入”，那我便“别具一格”好了（我还年轻，总要纯粹点，总要信点什么，总要想些不可能的事嘛。年轻人嘛）。不过我肯定还将遇到有趣的人（实则是有趣的灵魂），他们日后也必将出现在此，因为我会一直守着这里——一座由0和1组成的孤城。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>我，Arch和Ubuntu的故事</title>
    <url>/2017/03/30/%E6%88%91%EF%BC%8CArch%E5%92%8CUbuntu%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>最近几天，准确说是整整四天，一直在折腾系统，故事比较多…<br>
享受win &amp; Ubuntu16.04LTS双系统的时候，突然Ubuntu就无法登入，进入无线login的情况。各种谷歌查资料，无果。在编程群问，无果。</p>
<blockquote>
<p>这里犯下两个错误。<br>
1.在google不行的情况下，并没有尝试进行百度，或者其他搜索。[显然后面他们起了作用]。<br>
2.在编程群问，毕竟不是专门玩系统的，无果也是难免。</p>
</blockquote>
<p>随后，开始重装Ubuntu,撞了两次，都是可以进去，配置Python和Cpp等一系列的开发环境后，重启，一样进入无限login。[注意到当中出现命令提示，含有sd2 , clean, blocks这些词]<br>
失败告终。</p>
<blockquote>
<p>一个错误。<br>
再次遇见同样的错误，并没有去深入研究然后尝试解决它！[说好的探索精神呢…]</p>
</blockquote>
<p>万念俱灰之时，大佬介绍Arch,开始整。查些资料，一次就安装成功了。xfce4桌面，startx启动。<br>
之后再次配置环境，仍然出现[sd2, clean, blocks]这些提示，但是系统可以运行。换dde桌面（deepin），开启黑屏，发现壁纸是黑的，改变壁纸，完美运行，桌面环境很漂亮。配置环境，重启，黑屏，真的黑了。。。无解，重启，还是无法进入桌面…进tty,发现环境变量一团糟[这里是重点。。。]，继续配置已经没有可能…</p>
<p>被arch搞得巨伤…主要opencv，R也不好配置，滚回去再次尝试装Ubuntu。轻车熟路，装好重启，并未打开win10，进入grub的rescue模式，按照百度经验教程，一路ls (hd0,msdos6)/boot/grub，发现系统一道文件，在启动normal.mod，发现文件丢失。经玩系统的大佬指点，U盘安装微PE，进去PE后，DiskGenius重建MBR，成功进入win10!再easybcd引导Ubuntu,完成安装。再次进入Ubuntu,一样，配置环境之后重启，进入无限login，这时候…说实话，近乎崩溃了，毕竟四天了…</p>
<p>然而，还是没有放弃。。。喝口水，再来。</p>
<p>百度，转机出现，发现有人设置错了系统的环境变量进入无限login,回去tty看我的/home/.xession-error文件[过程中一样是一团糟的环境变量]，发现果然错了！现在找对了方向，于是进入/etc/profile，发现Anaconda的路径前面没有加export,而且路径格式不对…于是连同下面自己添加的java环境境变量一同注释，重启，搞定！</p>
<p>四天不眠不休的折腾[每天睡5个小时多点…]，确实很伤，但是也学到了很多知识。<br>
下面总结下：</p>
<p>系统相关：</p>
<blockquote>
<p>双系统之间不要随意拖拽文件，之前那些莫名的提示，可能就是这个造成的。<br>
启动arch桌面不要用startx,用lightdm[用前者启动deepin桌面可能黑屏]<br>
设置wifi最简单的办法，命令nmtui</p>
</blockquote>
<p>博客转移：</p>
<blockquote>
<p>一定记得备份文件<br>
记得hexo需要的node版本不要最新，官方稳定版本即可<br>
只需要重新将hexo文件复制到新的电脑，配置git,安装hexo[不需要init等其他的，一条安装命令即可]</p>
</blockquote>
<p>方法：</p>
<blockquote>
<p>百度有时候比Google来得更加简单直接。<br>
记得找专业的人士解决相关的问题<br>
记得要针对问题探索，不要逃避问题…</p>
</blockquote>
<p>最后，真心感谢arch群里各位大佬的帮助，感谢废帝大佬多次建议让我换电脑:-)————不要折腾系统，换电脑————有钱会换的orz…</p>
<p>虽说又回到最初的起点，但是这四天，没有浪费。</p>
<p>继续努力吧少年，20岁，本就是野蛮生长的年纪。<br>
也许明天是个好天气呢。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>所谓偶然</title>
    <url>/2019/01/19/%E6%89%80%E8%B0%93%E5%81%B6%E7%84%B6/</url>
    <content><![CDATA[<p>读一些书的时候，渐渐发现一些“所谓偶然”的东西，也就是说，似乎许多人在他们的文字都在诉说着相同的事情。以下所言，或来自读书笔记，或来自书籍的勾画，或只是回忆…作为参考。</p>
<p>当论及悲观。钱钟书说，目光放远，万事皆悲。木心说，悲观是一种远见。罗曼·罗兰说，生活并不可悲，只是有些时候可悲罢了。</p>
<p>当论及痛苦。木心说，悲伤有很多种，能加以抑制的悲伤，未必称得上悲伤。罗曼·罗兰说，奢谈痛苦之人并非是苦难深重之人…真正的痛苦是在心灵深处安放了一张床，睡在上面显得很平静，其实它仍在腐蚀着灵魂。</p>
<p>当论及爱情的一隅。罗曼·罗兰说，人在爱时，心不会善…一个貌美的姑娘往往爱玩残忍的感情游戏。它觉得大家喜欢她是天经地义的，而她除了自己钟爱的人之外，对其他人根本无需负有任何责任。对这段的话印象还是比较深的，因为塞万提斯在《堂·吉诃德》里面，有段牧羊人追求一个女生的片段，很好地诠释了前面的话。鉴于两者的相似度，或许说成罗曼·罗兰的话概括了牧羊人的故事比较好（《唐·吉诃德》毕竟是被称作西方文学史上的第一部现代小说）。</p>
<p>当论及爱情的另一隅。木心说，我爱你，与你何涉。罗曼·罗兰说（其实是年轻的约翰·克利斯朵夫的台词，说给他喜欢的女孩的母亲），你无情地让我知道，我没资格爱你的女儿。可是我爱什么人，无论是什么也挡不住，我是没有你的门第，但是我和你一样高贵，只有心才会让人高贵！</p>
<blockquote>
<p>前面和后面的“罗曼·罗兰说”也都是来自《约翰·克利斯朵夫》，强烈推荐，非常好的书。</p>
</blockquote>
<p>关于少年之后。木心说，很多人的失落，是违背了自己年少时的立志。自认为成熟、自认为练达、自认为精明，从前多幼稚，总算看透了、想穿了。于是，我们就此变成自己年少时最憎恶的那种人。罗曼·罗兰说，大多数人实际上在二十岁或三十岁的时候就已经死了，过了这个时段，他们已经成了自身的影子。此后的人生只是来自我模仿，把从前那种生气盎然的时期的所言，所谓，所思，所爱，日复一日地重复，而且其形式越来越呆板吗越来越远离实质。</p>
<p>关于面对。鲁迅说，真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。罗曼·罗兰说，我们应该睁大眼睛看着事实的真相；正视人间的痛苦，从每个毛孔中间吸收生命的气息并且放声大笑。（有没有想起太白捏:-)</p>
<p>关于困境与抉择。托马斯·杰弗逊说（1790年12月30日给大女儿玛莎的一封信中），如果你发觉自己陷入困境，不知道如何才能摆脱出来，只需去做正确的事情，你会发现这就是走出困境的最佳途径。（我所读过的书中，这句话印象算是最深了）。关于这种困境，鲁迅先生的《死火》描述的最为生动——是燃尽还是冻灭？但是鲁迅先生并没有给出如何作出“抉择”。关于对“死火”状态的抉择，一个比较好的答案是在《北大文学讲堂》中钱理群老师提到的，下面的话是他的导师王瑶先生说的（王瑶先生曾师从朱自清攻读中古文学）：我已经七十多岁了，我要什么事都不干呢，那就是“坐以待毙”，我如果继续拼命，说的好听点是发挥余热，其实呢，不过是‘垂死挣扎’…与其坐以待毙不如垂死挣扎。</p>
<blockquote>
<p>杰弗逊这个记不太清楚了，特地查了查，大概是两年前在林语堂的《美国的精神》看到的这篇文章。叫做《杰弗逊式的民主》，写到了一些托马斯·杰弗逊的信件。书中林对其评价很高：加入有人问我谁是美国最伟大的哲学家，我的回答将是托马斯·杰弗逊，除非我们对于“哲学家”一次的理解是错误的。</p>
</blockquote>
<p>又及，最近想到一个有意思的东西。王小波说，人的一切痛苦，本质上都是对自己无能的愤怒，却没有说无能的原因何在，那么无能的原因在哪？在于懒惰。懒惰的原因在哪？在于怯懦。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>最大似然估计与经验风险最小化</title>
    <url>/2017/03/03/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E4%B8%8E%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
    <content><![CDATA[<p>李航老师《统计学习方法》第一章笔记——经验风险最小化推导极大似然估计</p>
<p>题目：当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计</p>
<p>1.1预备知识——统计学习三要素</p>
<p>模型的假设空间，模型选择的标准以及模型学习的算法是统计学习方法的三要素。</p>
<p>简记为： 方法 = 模型+策略+算法</p>
<p>1.2.预备知识——损失函数</p>
<p>在模型的假设空间，我们要确定一定的准则来确定模型的好坏，即我们需要确定一定的策略[三要素之一]去衡量，所以我们引入了损失函数[loss function]或代价函数[cost function].</p>
<p>损失函数有很多种，例如0-1损失函数， 平方损失函数等，这里我们要用的是对数损失函数。<br>
$$L(Y, P(Y | X)) = - \log P(Y | X)$$</p>
<p>1.3.预备知识——风险函数</p>
<p>选定损失函数后，其值越小，模型就越好。模型的输入与输出(X, Y)是随机变量，遵循联合分布P（X, Y）， 所以损失函数的期望为:</p>
<p>$$R_{exp} = E_p[L(Y, f(X))] = \int_{X \times Y} L(y, f(x))P(x, y)dxdy $$</p>
<p>这就是风险函数[risk function] 或 期望损失[expected loss], 其代表理论上模型f(X)关于联合分布P(X, Y)的平均意义下的损失.</p>
<p>1.4.预备知识——经验风险</p>
<p>关于有监督学习的病态问题[ill-formed problem]: 一方面，根据最小化风险函数确立最优的的模型需要联合分布P(X, Y)，另一方面此联合分布又是未知的。</p>
<p>我们想到用样本估计整体， 为此我们引入经验风险[empirical risk]或经验损失[empirical loss] ：</p>
<p>$$ R_{emp}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i)) $$</p>
<p>其中，定义训练集为：</p>
<p>$$T = {(x_1, y_1), (x_2, y_2), \cdots , (x_N, y_N)}$$</p>
<p>根据大数定律，在样本量N趋向于无穷时， $R_{emp}(f)$趋于$R_{exp}(f)$. 当然实际上标注好的样本一般达不到要求，所以效果不太好，这时我们可以引入关于模型复杂度的罚项来纠正，这里暂时不展开讨论。</p>
<p>1.5.预备知识——极大似然估计</p>
<ol start="2">
<li>证明：</li>
</ol>
<p>设$x_1, x_2, \cdots , x_n$为独立同分布[i.i.d., independent and identically distributed]的样本，$\theta$为模型参数，$f$为我们使用的模型。</p>
<p>由i.i.d.:</p>
<p>$$f(x_1, x_2, \cdots, x_n) = f(x_1|\theta)\times f(x_2|\theta)\times \cdots \times f(x_n|\theta)$$</p>
<p>而实际上我们已知$x_1, x_2, \cdots , x_n$, 未知的是，$\theta$， 故似然定义为:</p>
<p>$$L(\theta|x_1, x_2, \cdots , x_n) = f(x_1, x_2, \cdots , x_n|\theta) = \coprod_{i=1}^{n}f(x_i|\theta)$$</p>
<p>此为样本发生可能性的大小，而极大似然估计的核心即为，以使得当前样本发生概率最大时的参数$\hat{\theta}$作为真实参数$\theta$的一个估计值。所以此时我们要求的是$L(\theta|x_1, x_2, \cdots , x_n)$取得最大值时$\theta$的值，即为$\hat{\theta}$。即问题转化为求$L(\theta|x_1, x_2, \cdots , x_n)$的极值问题。自然想到导数，而由于连乘的存在，可利用对数函数单调递增的性质，两边取对数再求导，可以简化计算。</p>
<p>$$\ln{L(\theta|x_1, x_2, \cdots, x_n)} = \sum_{i=1}^{n}\ln{f(x_i|\theta)}$$</p>
<p>上式即为对数似然，而一般而言的最大似然中的似然指的是对数平均似然$\hat{l}$，即为：</p>
<p>$$\hat{l} = \frac{1}{n}\ln{L}$$</p>
<p>整理得：</p>
<p>$$\hat{\theta} = \mathop{\arg\max}_{\theta\epsilon R^n}\hat{l}(\theta|x_1, x_2, \cdots, x_n)$$</p>
<p>看到，极大似然估计即为:</p>
<p>$$max\frac{1}{n}\sum_{i=1}^{n}\ln{f(x_i|\theta)}$$</p>
<p>即：</p>
<p>$$min\frac{1}{n}\sum_{i=1}^{n}-\ln{f(x_i|\theta)}$$</p>
<p>而经验风险最小化公式为：</p>
<p>$$ \arg\min_{f\epsilon F}\frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i) )$$</p>
<p>所以，在模型为条件概率分布模型，损失函数是对数损失函数$L(Y, P(Y | X)) = - \log P(Y | X)$时，经验风险最小化就等价于极大似然估计</p>
<p>证毕。</p>
]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>校内交流分享会[Python与数据科学]</title>
    <url>/2018/04/24/%E6%9C%89%E5%85%B3%E6%A0%A1%E5%86%85%E4%BA%A4%E6%B5%81%E5%88%86%E4%BA%AB%E4%BC%9A/</url>
    <content><![CDATA[<h3 id="Overview-61">Overview</h3>
<p>一次校内的交流会，探讨关于Python与其数据分析的应用等。</p>
<h3 id="Files">Files</h3>
<p>以下是本次分享所用的展示文件[工商管理，市场营销]：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/12sJmYiTk_SK8BaVbZwKtyw">https://pan.baidu.com/s/12sJmYiTk_SK8BaVbZwKtyw</a> 密码: cscd</p>
</blockquote>
<p>ps:文件是.exe格式的，可能需要关闭360等杀毒软件后运行，不然可能会误报成病毒。</p>
<p>另外，有其他资源之后也会放在这里。</p>
<p>提问后续解答：</p>
<blockquote>
<ol>
<li>Kaggle社区目前国内的网络是可以正常登录，速度也还可以。</li>
<li>校内教育网邮箱申请参考<a href="http://datahonor.com/2017/08/10/%E5%85%B3%E4%BA%8E%E6%95%99%E8%82%B2%E7%BD%91%E9%82%AE%E7%AE%B1/">这篇</a>文章。</li>
</ol>
</blockquote>
<p>========2018/04/26更新=========<br>
16级经济统计所用展示文件[加入教材推荐页面]：</p>
<blockquote>
<p>链接：链接: <a href="https://pan.baidu.com/s/1qslROAqk7vlpqf1zeFyZ2g">https://pan.baidu.com/s/1qslROAqk7vlpqf1zeFyZ2g</a> 密码: rg2t</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯算法的简单实现</title>
    <url>/2017/03/03/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>李航老师，《统计学习方法》第四章，朴素贝叶斯算法笔记。</p>
<h5 id="算法原理-3">算法原理</h5>
<h6 id="极大似然估计">极大似然估计</h6>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch4/Screenshot%20from%202017-03-03%2012-38-53.png" alt=""></p>
<h6 id="贝叶斯估计">贝叶斯估计</h6>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch4/Screenshot%20from%202017-03-03%2012-46-57.png" alt=""></p>
<p>如上所述，在lambda = 0时，贝叶斯估计就等价于极大似然估计。</p>
<h5 id="Python实现">Python实现</h5>
<blockquote>
<p>这里用的是<a href="http://download.csdn.net/detail/zouxy09/6610571">数字手写体</a>的数据，之前在<a href="http://datahonor.com/2017/03/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0KNN-Python/">KNN</a>也用到过。</p>
</blockquote>
<h6 id="手动实现算法">手动实现算法</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">朴素贝叶斯预测手写体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 处理单个txt文件, 将文件转化为1-d数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img2vector</span>(<span class="params">filename</span>):</span><br><span class="line">    rows = <span class="number">32</span></span><br><span class="line">    cols = <span class="number">32</span></span><br><span class="line">    imgVector = np.zeros((<span class="number">1</span>, rows * cols))</span><br><span class="line">    fileIn = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        lineStr = fileIn.readline()</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            imgVector[<span class="number">0</span>, row * <span class="number">32</span> + col] = <span class="built_in">int</span>(lineStr[col])</span><br><span class="line">    fileIn.close()</span><br><span class="line">    <span class="keyword">return</span> imgVector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取训练集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_training_sample</span>():</span><br><span class="line">    os.chdir(<span class="string">&#x27;/home/shen/PycharmProjects/MyPython/统计学习方法/Naive Bayes/digits/trainingDigits&#x27;</span>)</span><br><span class="line">    files = os.listdir()</span><br><span class="line">    numSamples = <span class="built_in">len</span>(files)</span><br><span class="line">    train_x = np.zeros((numSamples, <span class="number">1024</span>))</span><br><span class="line">    train_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">        filename = files[i]</span><br><span class="line">        yi = <span class="built_in">int</span>(filename.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        xi = img2vector(filename)</span><br><span class="line"></span><br><span class="line">        train_x[i, :] = xi</span><br><span class="line">        train_y.append(yi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_x, train_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取测试集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_sample</span>():</span><br><span class="line">    os.chdir(<span class="string">&#x27;/home/shen/PycharmProjects/MyPython/统计学习方法/Naive Bayes/digits/testDigits&#x27;</span>)</span><br><span class="line">    files = os.listdir()</span><br><span class="line">    numSamples = <span class="built_in">len</span>(files)</span><br><span class="line">    test_x = np.zeros((numSamples, <span class="number">1024</span>))</span><br><span class="line">    test_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">        filename = files[i]</span><br><span class="line">        yi = <span class="built_in">int</span>(filename.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        xi = img2vector(filename)</span><br><span class="line"></span><br><span class="line">        test_x[i, :] = xi</span><br><span class="line">        test_y.append(yi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> test_x, test_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心训练算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_x_yi</span>(<span class="params">train_x, train_y, yi</span>):</span><br><span class="line">    <span class="keyword">if</span> yi == <span class="number">0</span>:</span><br><span class="line">        train_x_yi = train_x[train_y == np.zeros(<span class="built_in">len</span>(train_y))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        train_x_yi = train_x[train_y == np.ones(<span class="built_in">len</span>(train_y)) * yi]</span><br><span class="line"></span><br><span class="line">    x_equal_1 = (train_x_yi.<span class="built_in">sum</span>(axis=<span class="number">0</span>)+lamda)/ (<span class="built_in">len</span>(train_x_yi)+<span class="built_in">len</span>(train_x_yi[<span class="number">0</span>])*lamda)</span><br><span class="line">    x_equal_0 = np.ones(<span class="built_in">len</span>(x_equal_1)) - x_equal_1</span><br><span class="line">    x_prec = np.vstack((x_equal_0, x_equal_1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_prec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">train_x, train_y</span>):</span><br><span class="line">    <span class="comment"># 根据需要，构造合适的结构</span></span><br><span class="line">    <span class="comment"># [[0, [&#123;0:p0, 1:p1&#125;, &#123;...&#125;, &#123;...&#125;,...&#123;...&#125;]], [1, [...]], [...], ...]</span></span><br><span class="line">    train_result = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> train_result:</span><br><span class="line">        train_result[i] = [<span class="number">0</span>, [&#123;&#125; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span> * <span class="number">32</span>)]]</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">len</span>(train_y)</span><br><span class="line">    unique_yi, counts_yi = np.unique(train_y, return_counts=<span class="literal">True</span>)</span><br><span class="line">    prec_yi = (counts_yi+lamda) / (<span class="built_in">len</span>(train_y)+<span class="built_in">len</span>(unique_yi)*lamda)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prec_yi)):</span><br><span class="line">        train_result[i][<span class="number">0</span>] = <span class="built_in">list</span>(prec_yi)[i]</span><br><span class="line">    <span class="comment"># yi = dict(zip(unique_yi, prec_yi))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        x_prec = get_train_x_yi(train_x, train_y, y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> xi <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_prec[<span class="number">0</span>])):</span><br><span class="line">            train_result[y][<span class="number">1</span>][xi][<span class="number">0</span>] = x_prec[<span class="number">0</span>][xi]</span><br><span class="line">            train_result[y][<span class="number">1</span>][xi][<span class="number">1</span>] = x_prec[<span class="number">1</span>][xi]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集进行预测</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">test_x, test_y, train_result</span>):</span><br><span class="line">    true_pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_x)):</span><br><span class="line">        yi = test_y[i]</span><br><span class="line">        xi = test_x[i]</span><br><span class="line">        result_xi = []</span><br><span class="line">        <span class="keyword">for</span> classx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            P_yi = train_result[classx][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(xi)):</span><br><span class="line">                <span class="comment"># print(train_result[classx][1][k][int(xi[k])])</span></span><br><span class="line">                P_yi *= train_result[classx][<span class="number">1</span>][k][<span class="built_in">int</span>(xi[k])]</span><br><span class="line">            result_xi.append(P_yi)</span><br><span class="line"></span><br><span class="line">        y0 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(result_xi, <span class="built_in">range</span>(<span class="built_in">len</span>(result_xi))))[<span class="built_in">max</span>(result_xi)]</span><br><span class="line">        <span class="keyword">if</span> y0 == yi:</span><br><span class="line">            true_pre += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预测准确率为： &#x27;</span>, true_pre / <span class="built_in">len</span>(test_x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    s = time.time()</span><br><span class="line">    train_x, train_y = get_training_sample()</span><br><span class="line">    test_x, test_y = get_test_sample()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    train_result = train(train_x, train_y)</span><br><span class="line">    predict(train_x, train_y, train_result)</span><br><span class="line">    e = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次训练预测共耗时 &#x27;</span>, e - s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 选取合适的lamda</span></span><br><span class="line">    <span class="comment"># lamda=0是为极大似然估计</span></span><br><span class="line">    <span class="comment"># lamda&gt;0是为贝叶斯估计，特别地，在其为1时，称作拉普拉斯平滑。</span></span><br><span class="line">    lamda = <span class="number">0</span>  <span class="comment"># 这里lamda=0得到的准确率较高</span></span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch4/Screenshot%20from%202017-03-03%2012-48-31.png" alt=""></p>
<h6 id="与sklearn实现对比">与sklearn实现对比</h6>
<p>为了对比，我们也用sklearn的朴素贝叶斯算法实现下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">import</span> os</span><br><span class="line">   <span class="keyword">import</span> time</span><br><span class="line">   <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">   <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">   <span class="comment"># the Naive Bayes model</span></span><br><span class="line">   <span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB, GaussianNB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的函数还是上面那些，只不过用到其中几个而已，这里不再赘述</span></span><br><span class="line">   <span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">       s = time.time()</span><br><span class="line"></span><br><span class="line">       train_x, train_y = get_training_sample()</span><br><span class="line">       test_x, test_y = get_test_sample()</span><br><span class="line">       nb = MultinomialNB()</span><br><span class="line">       <span class="comment"># nb = GaussianNB()</span></span><br><span class="line">       nb.fit(train_x, train_y)</span><br><span class="line">       <span class="built_in">print</span>(nb.score(test_x, test_y))</span><br><span class="line"></span><br><span class="line">       e = time.time()</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;本次训练预测共耗时 &#x27;</span>, e-s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>nb = MultinomialNB()<br>
0.923890063425<br>
本次训练预测共耗时  1.693662405014038</p>
</blockquote>
<blockquote>
<p>nb = GaussianNB()<br>
0.733615221987<br>
本次训练预测共耗时  1.8078570365905762</p>
</blockquote>
<p>可以看到，sklearn的算法实现明显要快得多，在正确选择合适算法时，也能达到较高的准确率。</p>
<h5 id="补充-3">补充</h5>
<p>这里训练数据的结果用了一个比较复杂结构，开始的时候怎么也构造不出。但是后来反过来逆向考虑</p>
<blockquote>
<p>在新的待预测的测试向量进入时,我需要哪些数据去预测呢？<br>
怎样高效地调用这些数据呢？<br>
所以，从其需要，构造其现有的就够，变得简单许多。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Analysis</tag>
        <tag>ML</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>梅贾的窃魂卷(0/25)——始末</title>
    <url>/2019/09/26/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-0-25-%E2%80%94%E2%80%94%E5%A7%8B%E6%9C%AB/</url>
    <content><![CDATA[<blockquote>
<p>这样，他就不会因为自己经验知识有限而陷于无助；不用再次去发现他人早已发现过的事物，重蹈他人的覆辙，重犯他人的错误。他可以继承他人的成果，继续前进。换句话说，语言使得人类有了进步的可能。                            ——《语言学的邀请》</p>
</blockquote>
<h3 id="始末-2">始末</h3>
<p>我时常感谢很多人，其中一种就是推荐好书给我的人。我曾看到过许多足够影响我一生的书籍，如《约翰·克利斯朵夫》， 《堂·吉诃德》，《沉默的大多数》，《温莎墓园日记》，《看不见的城市》，《飘》以及上面《语言学的邀请》等等。如果不是从各个角落知晓这些书籍十分有趣，那我也将永远不会打开他们…我想这不是一件好事。</p>
<p>好书应当共赏。在不断学习Python的这几年，也看到国外很多优秀的书籍，或是因为没有中译本（或者翻译的太差）等原因，使得他们并不被大多数人知晓，以至于很多新的知识没有得到很好的普及。所以打算写这一系列的文章来分享这些有趣的知识，综合各种因素，我将这一系列命名为“梅贾的窃魂卷”。</p>
<p>这一系列将包含25篇Python进阶的知识，它们更加适合由一定Python基础的读者。这些分享的东西之中，鲜有我自己琢磨出来的东西，因为我即没有工作，也没有写过大型的项目，所以对很多东西也是停留在表面的理解。但是，即使如此，我还是会尽力将这个系列做好，如有不足之处还请指正。</p>
<h3 id="参考书-2">参考书</h3>
<p>该系列参考书如下：</p>
<p>[1]. <em>Fluent Python</em></p>
<p>[2]. <em>Python Cookbook</em></p>
<p>[3]. <em>Modern Python Cookbook</em></p>
<p>[4]. <em>Python Tricks: The Book</em></p>
<p>[5]. <em>Functional Programming in Python</em></p>
<p>[6]. <em>How to make Mistakes in Python</em></p>
<p>[7]. <em>The Hitchhiker’s Guide to Python</em></p>
<p>[8]. <em>Effective Python</em></p>
<p>[9]. <em>SICP in Python</em></p>
<h3 id="系列框架（持续更新）">系列框架（持续更新）</h3>
<p>(1/25): Decorator&amp;Closure</p>
<p>(2/25): Context Manager(with)</p>
<p>(3/25): Annotations</p>
<p>(4/25): Print, F-String, etc.</p>
<p>(5/25): Multi-Line Code and Strings</p>
<p>(6/25): Functional Programming</p>
<p>(7/25): Iterable, Iterator and Generator</p>
<p>&lt;待续&gt;</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>梅贾的窃魂卷(1/25)——Decorator and Closure</title>
    <url>/2019/09/26/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-1-25-%E2%80%94%E2%80%94Decorator-and-Closure/</url>
    <content><![CDATA[<h3 id="为什么需要装饰器-MotivaMotion">为什么需要装饰器(MotivaMotion)</h3>
<p>存在即合理。在开始之前，我们必须先搞清楚我们为什么需要装饰器,亦即我们可以用它来做什么。总的来说用处很多，下面我们举几个例子。</p>
<h4 id="计时器-日志记录">计时器,日志记录</h4>
<p>比如说我们想要测试一些函数的运行时间。在函数不多的时候，我们可以分别计时测试。</p>
<p>比如对函数<code>func</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am func.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>计时代码大概是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am func.&quot;</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, I am func.</span><br><span class="line">Spend:2.5510787963867188e-05s</span><br></pre></td></tr></table></figure>
<p>可以看出我们这里修改了<code>func</code>的函数定义才完成计时的任务,使得代码可读性十分差,对于复杂点的函数,我们可能会很艰难地才能找到函数原始的定义.有些读者可能觉得,我们也可以不修改函数定义达到计时的目的确实如此,代码大概是下面这样.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am a function.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, I am a function.</span><br><span class="line">Spend:2.2411346435546875e-05s</span><br></pre></td></tr></table></figure>
<p>这样当然是可以的。但是如果函数很多呢？我们也这样一一测试，即使是粘贴复制去测试，也会很耗时间。而使用装饰器，我们可以很方便地对函数进行批量计时。</p>
<p>如，我们可以用下面的代码，很方便地在函数执行的时候自动打印运行所需要的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeIt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am func1.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeIt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am func2.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br><span class="line">    func2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, I am func1.</span><br><span class="line">Spend:3.886222839355469e-05s</span><br><span class="line">Hello, I am func2.</span><br><span class="line">Spend:8.106231689453125e-06s</span><br></pre></td></tr></table></figure>
<p>同样地,我们可以将函数执行的时间和其他信息记录到日志文件当中.</p>
<h4 id="缓存器">缓存器</h4>
<p>我们也可以使用装饰器完成缓存的任务.下面我们会介绍Python内置的<code>lru_cache</code>装饰器的使用,它可以通过Memoization的方式, 帮助我们更好地完成动态规划(Dynamic Programming)的任务.</p>
<h3 id="装饰器是什么">装饰器是什么</h3>
<p>通过上面的例子,我们了解到了装饰器的必要性,即简化我们的工作.(看不懂不要紧,因为我们还没开始讲:-)那么,到底装饰器是什么呢?</p>
<blockquote>
<p>“A decorator is a callable that takes a callable as input and returns another callable.”                                     – Dan, <em>Python Tricks: The Book</em></p>
</blockquote>
<hr>
<p><strong>NOTE</strong></p>
<p>函数<code>function</code>是<code>callable</code>的一种,也是最主要的一种, 其它像class实现了<code>__call__</code>方法的也是属于callable的.后面我们将围绕函数来展开装饰器的讲解,我们下面用函数(function)来指代这里的<code>callable</code>.更多关于<code>callable</code>的内容可以参考<a href="https://docs.python.org/3/library/functions.html?highlight=callable#callable">文档</a>和<a href="https://stackoverflow.com/questions/111234/what-is-a-callable">stackoverflow</a>.此外，可以参考<a href="https://www.geeksforgeeks.org/class-as-decorator-in-python/">Class as decorator in python</a>来找到class(作为callable)实现装饰器的具体例子。</p>
<hr>
<p>这样,上面对装饰器的解释就是: <strong>装饰器是一个函数, 特别的是,它以一个函数作为它的输入,并返回另一个函数.</strong></p>
<p><em>注意,在Python中,函数是first class object, 也就是说函数的使用是很自由的,具体可以参考<a href="https://stackoverflow.com/questions/245192/what-are-first-class-objects">stackoverflow</a>.所以Python对FP的支持还是比较好的,有趣的是,这种良好的支持并非设计者有意为之:-)(在Fluent Python提到)</em></p>
<p>那么关于装饰器是什么的问题就解释清楚了,它是一个函数而已,只不过比较特殊.在函数式编程(FP, Functional Programming)中,我们将这类输出或输出涉及函数的函数,叫做高阶函数(High-Order Function). 所以,确切地说,<strong>装饰器是一个高阶函数</strong>.</p>
<p>在了解了为什么和是什么之后，我们需要知道怎么正确使用装饰器。在这之前，我们先介绍下闭包(Closure)的概念，理解闭包有助于我们对装饰器的理解。</p>
<h3 id="什么是闭包">什么是闭包</h3>
<blockquote>
<p>“Actually, a closure is function with an extended scope that encompasses non-global variables referenced in the body of the function but not defined there.”                          ——<em>Fluent Python</em></p>
</blockquote>
<p>简单翻译下：实际上，<strong>闭包就是一个函数连同一个额外的作用域</strong>，其中这个作用域包含一些在该函数用到（但并非在该函数定义）的一些非全局变量。可能有些抽象，让我们来看到一个例子(来自<em>Fluent Python</em>)。</p>
<p>设想这样一个场景，我们想要定义一个形如<code>avg(x)</code>函数，在第一次调用的时候，返回传入的参数本身，比如传入10，返回10；第二调用的时候返回传入参数的累计平均，比如本次传入11， 那么这一次函数返回10.5, 即（10 + 11）/ 2； 以此类推。</p>
<p>我们知道因为我们每次只传入一个参数，但是却要求函数具有“记忆性”一样，这种记忆性就是通过闭包来实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total / <span class="built_in">len</span>(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里函数<code>averager</code>连同<code>series</code>构成了一个闭包。这里和装饰器一样用到了函数嵌套，实际上从闭包的定义就可以看出其总是和函数嵌套联系在一起。</p>
<p><img src="https://datahonor-1252464519.cos.ap-beijing-1.myqcloud.com/2019/decorator" alt=""></p>
<p>这里变量<code>series</code>原本就是函数<code>make_averager</code>的一个局部变量(local variable),其在调用函数<code>make_averager</code>返回<code>averager</code>之后就不存在了。但是却不是永远的消失，而是作为一个自由变量(free variable， 表示变量不与局部作用域绑定)存储在<code>averager</code>之中组成闭包。</p>
<p>那么又有问题出现了，这个自由变量到底怎么储存的呢？答案是储存在返回函数<code>avg</code>的<code>__closure__</code>属性之中， 在<code>avg.__closure__</code>中的有很多<code>cell</code>，每个<code>cell</code>有一个<code>cell_contents</code>属性，这里存储着其具体包含的数据。此外，我们可以在<code>avg.__code__co_freevars</code>看到所有<code>cell</code>对应的自由变量名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">&#x27;series&#x27;</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x7ff64747f978</span>: <span class="built_in">list</span> <span class="built_in">object</span> at <span class="number">0x7ff6475695c8</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<p>总的来说闭包就是为了重分利用非全局变量而存在的。</p>
<h3 id="修改闭包中自由变量">修改闭包中自由变量</h3>
<p>我们可以对上面闭包的实现进行初步改进，因为我们只需要保存总和和总的数量就可以完成上面的要求。所以可以试着写下如下代码，但是它是错的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        reutrn total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> averager</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">&#x27;count&#x27;</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>错误的原因是这里我们对<code>count</code>和<code>total</code>进行重新绑定(rebinding)，相当于执行<code>count = count + 1</code>，这种绑定实际上会将他们从自由变量变为局部变量，局部变量不会保存在闭包，所以也就找不到了。之前的<code>series</code>由于是一个列表，所以我们只进行<code>append</code>是不会进行重新绑定的，所以是可行的。</p>
<p>也就是说，对于<code>int</code>, <code>str</code>, <code>tuple</code>等不可变类型(immutable type)， 我们对闭包一般只有读取权限。说一般肯定是因为有其他方法可以获得读取权限，那就是使用<code>nonlocal</code>去做一个声明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数内部对变量进行赋值的时候，这个声明使得变量成为自由变量。这样我们就可以改变闭包的值了。</p>
<h3 id="怎么用装饰器">怎么用装饰器</h3>
<h4 id="如何写-作用原理">如何写&amp;作用原理</h4>
<p>当然是按照定义写就可以了:-)</p>
<p>也就是说，<strong>写一个高阶函数，它接受一个一般意义上的函数)(我们叫它<code>func</code>好了)作为参数，然后内部在嵌套定义一个新的函数(叫它<code>wrapper</code>)，其在完成<code>func</code>本来功能的基础上在加上其他想要的功能，最后返回<code>wrapper</code>函数</strong>就可以了。</p>
<p>重新来看下上面的<code>timeIt</code>装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>直接对比上面的定义就很清晰了。</p>
<p>那么，有一个问题，就是装饰器有了，它具体怎么工作的呢？为什么在想要装饰的函数上面加上一个<code>@timeIt</code>就可以了呢？</p>
<p>答案其实很简单，<code>@</code>在这里只是一个语法糖(Syntactic sugar)，只是起到一个<strong>简化</strong>的作用。下面两种写法是完全等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timeIt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I am func1.&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func1 = timeIt(func1)</span><br></pre></td></tr></table></figure>
<p>他们都是把原始的<code>func1</code>作为参数传入<code>timeIt</code>装饰器，然后返回一个新的函数，并将重新绑定到<code>func1</code>.</p>
<p>注意，这里我们用的被装饰的函数，如这里的<code>func1</code>都只是示例作用，只是打印一些信息，并无返回值。但是在大多数场合下，被装饰函数还是有返回值的，这是我们就要向上面一样用<code>result</code>接受原始函数调用的返回值，并作为<code>wrapper</code>函数的返回值来返回。下面有的时候不会带有<code>result</code>返回，只是为了说明方便，还望不要引起误解。</p>
<h4 id="参数传入-被装饰函数func">参数传入(被装饰函数<code>func</code>)</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeIt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_args</span>(<span class="params">x, y, a=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I have three args: %s, %s, %s.&quot;</span> % (x, y, a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func_args(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Hello, I have three args: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span></span><br><span class="line">Spend:<span class="number">5.602836608886719</span>e-05s</span><br></pre></td></tr></table></figure>
<h4 id="参数传入-装饰器本身timeIt">参数传入(装饰器本身<code>timeIt</code>)</h4>
<p>还是上面的计时场景，上面的<code>time.time</code>和<code>time.perf_counter</code>是类似的，都是返回当前的时间，以秒为单位（后者更加适合做benchmarking一点）。那么，我们如何定义一个装饰器，使得我们可以控制装饰器本身的行为呢？</p>
<p>一种比较自然的方式是直接在<code>timeIt</code>中增加额外的参数来完成这一改进。大概像下面这样去改进，但是这是<strong>不可行的</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func, seconds=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 以秒为单位，返回浮点数</span></span><br><span class="line">    <span class="keyword">if</span> seconds:</span><br><span class="line">        measure = time.perf_counter</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 以纳秒为单位，返回整数</span></span><br><span class="line">        measure = time.perf_counter_ns</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;ns&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = measure()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = measure()</span><br><span class="line">        <span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="built_in">float</span>(end) - <span class="built_in">float</span>(start)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timeIt(<span class="params">seconds=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_args</span>(<span class="params">x, y, a=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I have three args: %s, %s, %s.&quot;</span> % (x, y, a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行上面的代码，将会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">23</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="meta">    @timeIt(<span class="params">seconds=<span class="literal">False</span></span>)</span></span><br><span class="line">TypeError: timeIt() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;func&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也就是说，我们如果在装饰器传入其他参数，就会使得<code>@</code>失效，因为它不再能后完成将下面函数作为参数传入的任务。</p>
<p>当然，我们可以手动完成这个任务，即用<code>@</code>的等价表示来“手动装饰”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func, seconds=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 以秒为单位，返回浮点数</span></span><br><span class="line">    <span class="keyword">if</span> seconds:</span><br><span class="line">        measure = time.perf_counter</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 以纳秒为单位，返回整数</span></span><br><span class="line">        measure = time.perf_counter_ns</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;ns&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = measure()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = measure()</span><br><span class="line">        <span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="built_in">float</span>(end) - <span class="built_in">float</span>(start)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_args</span>(<span class="params">x, y, a=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I have three args: %s, %s, %s.&quot;</span> % (x, y, a))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1 = timeIt(func_args, seconds=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Hello, I have three args: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span></span><br><span class="line">Spend:<span class="number">3.587399987736717</span>e-05s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2 = timeIt(func_args, seconds=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Hello, I have three args: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span></span><br><span class="line">Spend:<span class="number">64493.0</span>ns</span><br></pre></td></tr></table></figure>
<p>这种方法是可以的，但是可惜的一点是我们不能使用<code>@</code>来进行装饰，可能会有些不方便。真正可以同时利用<code>@</code>语法糖的做法是再次进行函数的嵌套，对装饰器本身进行嵌套。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">seconds=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 以秒为单位，返回浮点数</span></span><br><span class="line">    <span class="keyword">if</span> seconds:</span><br><span class="line">        measure = time.perf_counter</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;s&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 以纳秒为单位，返回整数</span></span><br><span class="line">        measure = time.perf_counter_ns</span><br><span class="line">        fmt = <span class="string">&#x27;Spend:&#123;&#125;ns&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timeIt</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start = measure()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end = measure()</span><br><span class="line">            <span class="built_in">print</span>(fmt.<span class="built_in">format</span>(<span class="built_in">float</span>(end) - <span class="built_in">float</span>(start)))</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> timeIt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_args_1</span>(<span class="params">x, y, a=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I have three args: %s, %s, %s.&quot;</span> % (x, y, a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock(<span class="params">seconds=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_args_2</span>(<span class="params">x, y, a=<span class="number">3</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, I have three args: %s, %s, %s.&quot;</span> % (x, y, a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func_args_1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Hello, I have three args: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span></span><br><span class="line">Spend:<span class="number">8.46920011099428</span>e-05s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func_args_2(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Hello, I have three args: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span></span><br><span class="line">Spend:<span class="number">62385.0</span>ns</span><br></pre></td></tr></table></figure>
<p>让我们从一个更加广阔的视角看待这种嵌套。对原始函数<code>func</code>进行嵌套，组成装饰器，我们在不修改<code>func</code>定义的情况下，对<code>func</code>调用时的行为进行了改进； 同样地，这里我们对装饰器本身<code>timeIt</code>进行嵌套，进而控制装饰器的行为。</p>
<p>注意，这里的<code>clock</code>函数并不是装饰器，为什么？因为装饰器的定义是接受函数作为参数，这里很明显不满足。所以<code>clock</code>只是一个单纯的高阶函数而已，它接受一个参数，根据参数定义装饰器的行为，而后<strong>返回一个装饰器</strong>。所以，从某种意义上讲，它可以看作一个装饰器的生产函数，这是一种更高层次的抽象。</p>
<h4 id="多重装饰-decorator-stacking">多重装饰(decorator stacking)</h4>
<p>想一下调用<code>func</code>函数会输出什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_hi</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        org = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;hi&gt;&#x27;</span> + org + <span class="string">&#x27;&lt;/hi&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_hello</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        org = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;hello&gt;&#x27;</span> + org + <span class="string">&#x27;&lt;/hello&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@add_hello</span></span><br><span class="line"><span class="meta">@add_hi</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func()</span><br><span class="line"><span class="string">&#x27;&lt;hello&gt;&lt;hi&gt;func&lt;/hi&gt;&lt;/hello&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>add_hi</code>是先于<code>add_hello</code>对<code>func</code>进行装饰的，所以下面两种写法是等价的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@add_hello</span></span><br><span class="line"><span class="meta">@add_hi</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = add_hello(add_hi(func))</span><br></pre></td></tr></table></figure>
<h4 id="可用于DEBUG的装饰器">可用于DEBUG的装饰器</h4>
<p>在以上所有的装饰器中，都存在一个问题，那就是我们看到函数名和实际内部函数的名字是不一致的，而且初始函数在被装饰后其<code>docstring</code>, <code>parameter list</code>也会被隐藏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_hello</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        org = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;hello&gt;&#x27;</span> + org + <span class="string">&#x27;&lt;/hello&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Just return the name of the function.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br><span class="line">decorate_func = add_hello(func)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__name__</span><br><span class="line"><span class="string">&#x27;func&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__doc__</span><br><span class="line"><span class="string">&#x27;Just return the name of the function.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorate_func.__name__</span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decorate_func.__doc__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>毕竟，到了这里，我们早就知道装饰过后返回的是一个新的函数，自然名字和文档都会变为新的。因为我们使用装饰器的初衷就是为了<strong>不修改</strong>函数的定义等来进行新功能的加入，这种情况看起来不太妙，而且尤其不利于我们DEBUG，毕竟谁看到一个莫名<code>wrapper</code>函数出错都感到茫然…</p>
<p>解决的方法就是…用一个装饰器(要用魔法打败魔法:-)我们可以用<code>functools.wraps</code>来复制原始函数<code>func</code>中的元数据(metadata)到装饰器的闭包当中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_hello</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        org = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;hello&gt;&#x27;</span> + org + <span class="string">&#x27;&lt;/hello&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@add_hello</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Just return the name of the function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__name__</span><br><span class="line"><span class="string">&#x27;func&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__doc__</span><br><span class="line"><span class="string">&#x27;Just return the name of the function.&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<p>装饰器的“装饰”是在正式调用函数前就进行的(Fluent Python有例子)，也就是一旦对函数进行了装饰，要返回去得到初始的函数是比较麻烦，如果有这种需求可以不用<code>@</code>，在运行需要的时候手动调用装饰器。</p>
<p><code>decorator stacking</code>虽好，也没有层次限制，但是当堆叠太多的时候还是对程序的运行效率带来压力，毕竟本身是函数的调用。</p>
<hr>
<p><strong>NOTE</strong><br>
Python也是有<a href="https://www.python.org/dev/peps/pep-3129/#rationale">Class Decorator</a>的哦，后面可能会讲到:-)</p>
<blockquote>
<p>A common use of class decorators is to be a simpler alternative to some use-cases of metaclasses. In both cases, you are changing the definition of a class dynamically. (<a href="https://realpython.com/primer-on-python-decorators/">Primer on Python Decorators</a>)</p>
</blockquote>
<hr>
<p>我们一直在讲用装饰器来对函数进行计时,但是如果采用上述方式对递归函数计时会发现程序在每次执行函数时候都会打印一个时间,这显然不是我们想要的.解决方法有两种,第一是继续使用装饰器,但是需要做一些细节的处理,参考<a href="https://stackoverflow.com/questions/29560643/python-counting-executing-time-of-a-recursion-function-with-decorator">这里</a>, 另一种就是参考后面基于<a href="http://datahonor.com/2019/11/01/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-2-25-%E2%80%94%E2%80%94Context-Managers-with/">Context Managers</a>的方法.</p>
<h3 id="Python内部的装饰器">Python内部的装饰器</h3>
<p>比较好用且常用的就是用<a href="https://docs.python.org/3/library/functools.html?highlight=lru_cache#functools.lru_cache"><code>functools.lru_cache</code></a>来进行<code>Memoization</code>。常见的求Fibonacci数列时，使用这个装饰器可以在提升运行速度的同时极大地简化程序。</p>
<p>此外一些比较常见的就是<code>@property</code>, <code>@classmethod</code>, <code>@staticmethod</code>这三个，而这三个装饰器(甚至包括<code>__slots__</code>与class method)的实现都是依赖于Descriptor的，具体见<a href="https://docs.python.org/3/howto/descriptor.html#technical-tutorial">Descriptor HowTo Guide</a>： 文档给出了上述常见装饰器的Pure Python实现，参考这些实现可以更加深入具体地了解这些装饰器的本质是什么，而不是仅仅停留在怎么用的阶段。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>梅贾的窃魂卷(2/25)——Context Managers(with)</title>
    <url>/2019/11/01/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-2-25-%E2%80%94%E2%80%94Context-Managers-with/</url>
    <content><![CDATA[<h3 id="为什么需要Context-Managers-Motivation">为什么需要Context Managers(Motivation)</h3>
<p>先来看一个读写文件的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"><span class="comment"># 一些其他操作等</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>很明显，在执行<code>f.write</code>和其他操作的时候可能会出错，这就会导致我们的<code>f</code>无法被正常关闭。所以，对于诸如此类的资源释放问题，我们一般都会加上异常判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line">    <span class="comment"># 一些其他操作等</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<p>但是这样会显得代码比较繁杂，降低了可读性。所以现在我们一般看到的读写文件的写法都是用<code>with</code>来写的，它定义了一个<code>Context Manager</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line">    <span class="comment"># 一些其他操作等</span></span><br></pre></td></tr></table></figure>
<p>这种写法可以保证在任何情况下<code>f</code>都可以被正常关闭，保持简洁同时代码的可读性大大提升。</p>
<p>不仅是读写文件，其他的诸如读写数据库，线程的释放等，都是需要做类似处理的。这就催生出了我们的<code>with</code>， 它就是<strong>专门为简化这种<code>try/finally</code>的写法而设计的，它保证在运行一段代码后我们总能进行一些操作，即使运行的那段代码出错也不影响</strong>。</p>
<h3 id="Context-Manager是什么">Context Manager是什么</h3>
<p>我们知道，Python的内部实现依赖Duck Type(“If it walks like a duck and it quacks like a duck, then it must be a duck”), 所以一般要实现某种行为，我们只需要对应实现一些必须的<code>protocol</code>. 就像<code>str(x)</code>对应<code>__str__</code>， <code>len(x)</code>对应<code>__len__</code>， <code>in</code>对应<code>__contains__</code>这样，<strong>这里的Context Manager对应<code>__enter__</code>和<code>__exit__</code>， 其表现形式一般是一个类(class)</strong>， 后面也会介绍用已有的<strong>装饰器工具和生成器(generator)来构造Context Manager</strong>的例子。</p>
<p>好了，我知道要实现这些protocol了，那么，所谓的Context Manager到底长什么样呢？下面就是一个很好的例子(来自Fluent Python)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LookingGlass</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write= self.reverse_write</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ABCD&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">self, text</span>):</span><br><span class="line">        self.original_write(text[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        sys.stdout.write = self.original_write</span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们先来看下这个Context Manager到底是用来干什么的，之后在具体解释其背后的运行机制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dlroW olleH</span><br><span class="line">DCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">&#x27;ABCD&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">Hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>with</code>内打印的内容全部是其真实内容的倒序，如<code>Hello World</code>变成<code>dlroW olleH</code>, <code>ABCD</code>变成<code>DCBA</code>。退出<code>with</code>之后打印行为又恢复正常。下面我们来深入解释其背后的原理。</p>
<h3 id="Context-Manager运行机制">Context Manager运行机制</h3>
<p>其实运行机制也非常简单，就是在<code>with LookingGlass() as what</code>时，执行<code>__enter__</code>做一些操作（比如这里更改打印行为），并将该函数的返回值赋给<code>as</code>后面的<code>what</code>。之后执行<code>with</code> 段的程序（即这里的两个<code>print</code>）。执行完之后跳出<code>with</code>段，同时调用<code>__exit__</code>函数做一些操作（这里是将打印行为恢复正常）。</p>
<p>此外，注意<code>__exit__</code>中的异常判断，在<code>if exc_type is ZeroDivisionError:</code>中，我们返回<code>True</code>表示该异常已经被处理。如果上述异常未触发，该处的<code>__exit__</code>会默认返回<code>None</code>，如果在<code>with</code>段内执行的代码有其他类型的错误，即<code>exc_type</code>并非<code>ZeroDivisionError</code>那么错误将会被<code>raise</code>出来。</p>
<h3 id="创建自己的Context-Manager">创建自己的Context Manager</h3>
<p>前面那种基于类的方法是一种可行自定义Context Manager的方法,就是自己<strong>定义好<code>__enter__</code>和<code>__exit__</code>方法</strong>.此外, Python还提供了一些库函数可以帮助我们更快地创建自己的Context Manager. <code>contextlib</code>库提供了很多的帮助函数,这里我们专注于其中最重要也是最常用的**<code>@contextmanager</code>装饰器**, 其可以十分方便地将生成器转化为一个Context Manager(此处也向我们展示了生成器不是只能用于迭代,也可以用于此处,以及后面可能会涉及的协程(coroutine)).</p>
<p>下面我们来看一些<code>@contextmanager</code>的使用方法,先看一个例子,它用装饰器加生成器的方法实现之前基于类的Context Manager.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">looking_glass</span>():</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">text</span>):</span><br><span class="line">        original_write(text[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;ABCD&#x27;</span></span><br><span class="line">    sys.stdout.write = original_write</span><br></pre></td></tr></table></figure>
<p>测试其行为是否和之前的实现一样.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dlroW olleH</span><br><span class="line">DCBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">&#x27;ABCD&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>可以看到和之前基于类的方法调用是一样,且行为也正如我们预期的那样.</p>
<p>那么,上面的程序到底是怎么运行的呢?换句话说,我们是怎么通过生成器和库提供的装饰器结合来构造Context Manager的呢?</p>
<p>简言之,在生成器(此处是函数<code>looking_glass</code>)中<code>yield xxx</code>语句将整个函数体分割为三个部分,<code>yield</code>之前的部分相当于函数<code>__enter__</code>的内容, <code>yield</code>之后的部分相当于函数<code>__exit__</code>的内容, <code>yield 'ABCD'</code>返回的<code>ABCD</code>在执行<code> with looking_glass() as what</code>时被绑定到<code>what</code>(相当于<code>__enter__</code>中<code>return</code>的值).</p>
<p>这样,在加上装饰器之后,整个函数被视作一个Context Manager, 在解释器调用<code>__enter__</code>时,它就执行<code>yield</code>之前的程序,然后将<code>yield</code>产生的内容绑定到<code>as</code>后的变量中(若<code>with f() as xxx</code>, 即绑定到<code>xxx</code>).之后执行<code>with</code>段的程序(上面例子中的两个<code>print</code>). 执行完毕后,解释器调用<code>__exit__</code>方法,此时程序去执行<code>yield</code>之后的部分.这就是使用装饰器和生成器来创建Context Manager的整个流程了.</p>
<p>需要注意的一点是,上面我们并为介绍生成器方法在此时并不完全等价于上面基于类的方法,关键在于**对异常的处理.**就内部细节来看,如果<code>with</code>语句后的内容执行出错,程序会报错一次.之后由于我们的Context Manager的实现,会在生成器内重新报错一次,在生成器内部的报错会终止我们的程序,使得Context Manager失效,资源无法释放.所以我们必须要对该错误进行处理才可以使得其完全等价于基于类的实现.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">looking_glass</span>():</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">text</span>):</span><br><span class="line">        original_write(text[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;ABCD&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样修改过,才算是真正写好了一个Context Manager,其和之前基于类的方法是等价的.因为我们不知道用户会用我们写的Context Manager做什么,所以这种内部的异常处理是基于生成器写Context Manager必须付出的代价(Leonardo Rochael).</p>
<p>那么,之前不是说搞Context Manager出来就是为了简化<code>try/finally</code>的写法吗,这里不是更加复杂了吗?</p>
<p>我个人感觉这类似封装的思想,我们将资源释放和异常处理统统加到我们的Context Manager里面,在调用的时候只需要一个<code>with</code>语句,使得代码逻辑更加清晰,也更加容易维护.</p>
<h3 id="具体应用">具体应用</h3>
<h4 id="文件修改-in-place">文件修改(in-place)</h4>
<p>从前的叙述中我们可以看到Context Manager的应用好像总是和资源释放等有关,其实并非如此.在Fluent Python中,作者提到Martijn Pieter的一个妙用, 他使用Context Manager来完成文件的就地(in-place)修改.</p>
<p>先定义好Context Manager<code>inplace</code>,之后可以通过简单的调用完成修改.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> inplace(csvfilename, <span class="string">&#x27;r&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> (infh, outfh):</span><br><span class="line">    reader = csv.reader(infh)</span><br><span class="line">    writer = csv.writer(outfh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        row += [<span class="string">&#x27;new&#x27;</span>, <span class="string">&#x27;columns&#x27;</span>]</span><br><span class="line">        writer.writerow(row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体内容参考其<a href="https://www.zopatista.com/python/2013/11/26/inplace-file-rewriting/">博客</a></p>
<h4 id="程序计时">程序计时</h4>
<p>我们知道装饰器可以用来函数的计时,我们也可以写一个Context Manager完成函数的计时,而且相对更加方便一点.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timeit</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.start = <span class="literal">None</span></span><br><span class="line">        self.end = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        self.end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Spend <span class="subst">&#123;self.end - self.start&#125;</span> s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> Timeit() <span class="keyword">as</span> f:</span><br><span class="line">        y = fib(<span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;fib(30) = <span class="subst">&#123;y&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Spend <span class="number">0.5587637424468994</span> s</span><br><span class="line">fib(<span class="number">30</span>) = <span class="number">832040</span></span><br></pre></td></tr></table></figure>
<p>在<a href="http://datahonor.com/2019/09/26/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-1-25-%E2%80%94%E2%80%94Decorator-and-Closure/">梅贾的窃魂卷(1/25)——Decorator and Closure</a>中我们了解到用装饰器计时大概有三个缺点:</p>
<blockquote>
<p>1.仅仅可以对某函数计时,对程序块计时需要先将其定义为函数</p>
<p>2.对递归函数的计时需要进一步的处理</p>
<p>3.不灵活,一旦将函数&quot;装饰&quot;起来,一般不能去掉&quot;装饰&quot;</p>
</blockquote>
<p>而上面基于Context Manager的计时方法更加灵活且友好.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>梅贾的窃魂卷(3/25)——Annotations</title>
    <url>/2019/11/10/%E6%A2%85%E8%B4%BE%E7%9A%84%E7%AA%83%E9%AD%82%E5%8D%B7-3-25-%E2%80%94%E2%80%94Annotations/</url>
    <content><![CDATA[<h3 id="Overview-62">Overview</h3>
<p>整理下关于<code>Python</code>中<code>Type Checking</code>的资料。主要参考<a href="https://realpython.com/python-type-checking/">realpython</a>.关于<code>Type Checking</code>，这篇文章主要是基于<code>mypy</code>来讲的，另外微软的<code>pyright</code>用着也还可以（还是有Bug…），可以和<code>Vscode</code>一起用。</p>
<h3 id="Annotations">Annotations</h3>
<p>在<code>variable</code>, <code>function</code>,和<code>class</code>中均可以使用<code>Annotations</code>.此外有<code>Type Comments</code>可以用为旧版本<code>Python</code>的替代品，不过不太好用，一般只用<code>Annotations</code>。</p>
<h4 id="Variable-Annotations">Variable Annotations</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pi: <span class="built_in">float</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p><code>Variable</code>的<code>Annotations</code>被存储在字典<code>__annotations__ </code>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(__annotations__)</span><br></pre></td></tr></table></figure>
<p>输出<code>&#123;'pi': &lt;class 'float'&gt;&#125;</code>.</p>
<h4 id="Function-Annotations">Function Annotations</h4>
<p>定义格式如下，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">arg: arg_type, optarg: arg_type = default</span>) -&gt; return_type:</span><br></pre></td></tr></table></figure>
<p>示例代码，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calArea</span>(<span class="params">r: <span class="built_in">float</span>, pi:<span class="built_in">float</span> = <span class="number">3.14</span></span>):</span><br><span class="line">    <span class="keyword">return</span> pi * r * r</span><br></pre></td></tr></table></figure>
<p>在函数不返回任何值的时候，使用<code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">player_name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;player_name&#125;</span> plays&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>因为<code>Python</code>是支持<code>Gradual typing</code>的，所以如果函数不返回任何值，这里是可以不写返回值的。不同的是，不写返回值的时候，<code>ret_val = play(&quot;Henrik&quot;)</code>是被<code>mypy</code>允许的，而上面的写返回值为<code>None</code>的时候，<code>ret_val = play(&quot;Henrik&quot;)</code>是不被允许的——<code>error: &quot;play&quot; does not return a value</code>。</p>
<h4 id="Class-Type-Hints-for-Methods">Class: Type Hints for Methods</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>:</span><br><span class="line">    SUITS = <span class="string">&quot;♠ ♡ ♢ ♣&quot;</span>.split()</span><br><span class="line">    RANKS = <span class="string">&quot;2 3 4 5 6 7 8 9 10 J Q K A&quot;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, suit: <span class="built_in">str</span>, rank: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.suit = suit</span><br><span class="line">        self.rank = rank</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.suit&#125;</span><span class="subst">&#123;self.rank&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Composite-Types-Type-Aliases">Composite Types&amp;Type Aliases</h3>
<p>对于简单的变量类型，我们可以直接使用内置的类型，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name: <span class="built_in">str</span> = <span class="string">&quot;Guido&quot;</span></span><br><span class="line">pi: <span class="built_in">float</span> = <span class="number">3.142</span></span><br><span class="line">centered: <span class="built_in">bool</span> = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>也可以进行依据内置的类型进行复合，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names: <span class="built_in">list</span> = [<span class="string">&quot;Guido&quot;</span>, <span class="string">&quot;Jukka&quot;</span>, <span class="string">&quot;Ivan&quot;</span>]</span><br><span class="line">version: <span class="built_in">tuple</span> = (<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">options: <span class="built_in">dict</span> = &#123;<span class="string">&quot;centered&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;capitalize&quot;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种写法存在问题，通过<code>Annotations</code>，可以直接推断出<code>names</code>是一个<code>list</code>，但是对于<code>names[0]</code>的类型，并不能通过<code>Annotations</code>知道（因为在<code>Python</code>中做<code>Type Checking</code>大部分不是在运行时进行的，所以我们无从知道<code>names[0]</code>的类型，换言之，我们能且只能通过<code>Annotations</code>来获取变量的类型）。</p>
<p>这就引出了下面的用法，即依靠<code>typing</code>库的内置类型，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">names: <span class="type">List</span>[<span class="built_in">str</span>] = [<span class="string">&quot;Guido&quot;</span>, <span class="string">&quot;Jukka&quot;</span>, <span class="string">&quot;Ivan&quot;</span>]</span><br><span class="line">version: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">options: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">bool</span>] = &#123;<span class="string">&quot;centered&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;capitalize&quot;</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如此，我们可以得到：</p>
<blockquote>
<p><code>names</code>是<code>str</code>组成的<code>list</code><br>
<code>version</code>是三个<code>int</code>组成的<code>tuple</code><br>
<code>options</code>是<code>key</code>为<code>str</code>，<code>value</code>为<code>bool</code>的<code>dict</code></p>
</blockquote>
<p>比如在后面<code>Example</code>段中将要提到的扑克牌（格式<code>♠8</code>）的例子就是利用上述类型，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_deck</span>(<span class="params">shuffle: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a new deck of 52 cards&quot;&quot;&quot;</span></span><br><span class="line">    deck = [(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> RANKS <span class="keyword">for</span> s <span class="keyword">in</span> SUITS]</span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        random.shuffle(deck)</span><br><span class="line">	<span class="keyword">return</span> deck</span><br></pre></td></tr></table></figure>
<p>观察上面的代码我们也可以发现一个问题，<code>List[Tuple[str, str]]</code>已经变的复杂，不仅其实际代表的数据结构的含义被掩盖，我们后面将此类型的参数传入函数的时候，其<code>Annotations</code>也会变得冗长，如，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deal_hands</span>(<span class="params"></span></span><br><span class="line"><span class="params">    deck: <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[</span><br><span class="line">    <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]],</span><br><span class="line">    <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]],</span><br><span class="line">    <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]],</span><br><span class="line">    <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]],</span><br><span class="line">]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deal the cards in the deck into four hands&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (deck[<span class="number">0</span>::<span class="number">4</span>], deck[<span class="number">1</span>::<span class="number">4</span>], deck[<span class="number">2</span>::<span class="number">4</span>], deck[<span class="number">3</span>::<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>于是就有了<code>Type Alias</code>的引入，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">Card = <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]</span><br><span class="line">Deck = <span class="type">List</span>[Card]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_hands</span>(<span class="params">deck: Deck</span>) -&gt; <span class="type">Tuple</span>[Deck, Deck, Deck, Deck]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deal the cards in the deck into four hands&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (deck[<span class="number">0</span>::<span class="number">4</span>], deck[<span class="number">1</span>::<span class="number">4</span>], deck[<span class="number">2</span>::<span class="number">4</span>], deck[<span class="number">3</span>::<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>如此，我们不但简化了<code>Annotations</code>的编写，也使得代码逻辑更容易理解。</p>
<h3 id="Special-Types-Any-Type-Variables">Special Types: <code>Any</code>&amp;<code>Type Variables</code></h3>
<p>考虑如下函数，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Sequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">items: <span class="type">Sequence</span>[<span class="type">Any</span>]</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">    <span class="keyword">return</span> random.choice(items)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Why Sequence: In many cases your functions will expect some kind of sequence, and not really care whether it is a list or a tuple.</p>
</blockquote>
<p>这里，我们的意图是：使用<code>choose</code>函数从一个<code>Sequence</code>中任取一个值并返回，因为我们不关心<code>Sequence</code>中元素的类型，所以使用<code>Any</code>，代表任意类型。我们是想要其返回元素的类型与输入的<code>Sequence</code>元素的类型是一致的（在使用<code>Any</code>的情况下），但实际上并非如此——这里函数返回值丢失了原来<code>Sequence</code>中的元素类型，看下面的例子，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># choose.py</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Sequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">items: <span class="type">Sequence</span>[<span class="type">Any</span>]</span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">    <span class="keyword">return</span> random.choice(items)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;Guido&quot;</span>, <span class="string">&quot;Jukka&quot;</span>, <span class="string">&quot;Ivan&quot;</span>]</span><br><span class="line">reveal_type(names)</span><br><span class="line"></span><br><span class="line">name = choose(names)</span><br><span class="line">reveal_type(name)</span><br></pre></td></tr></table></figure>
<p>运行<code>mypy choose.py</code>，</p>
<blockquote>
<p><a href="http://choose.py:10">choose.py:10</a>: error: Revealed type is ‘builtins.list[builtins.str*]’<br>
<a href="http://choose.py:13">choose.py:13</a>: error: Revealed type is ‘Any’,可以看到原来元素为<code>str</code>，现在已经丢失为<code>Any</code>类型。</p>
</blockquote>
<p>为解决此问题，我们引入了<code>Type Variables</code>，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Sequence</span>, TypeVar</span><br><span class="line"></span><br><span class="line">Choosable = TypeVar(<span class="string">&quot;Chooseable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">items: <span class="type">Sequence</span>[Choosable]</span>) -&gt; Choosable:</span><br><span class="line">    <span class="keyword">return</span> random.choice(items)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;Guido&quot;</span>, <span class="string">&quot;Jukka&quot;</span>, <span class="string">&quot;Ivan&quot;</span>]</span><br><span class="line">reveal_type(names)</span><br><span class="line"></span><br><span class="line">name = choose(names)</span><br><span class="line">reveal_type(name)</span><br></pre></td></tr></table></figure>
<p>运行<code>mypy choose.py</code>，</p>
<blockquote>
<p><a href="http://choose.py:12">choose.py:12</a>: error: Revealed type is ‘builtins.list[builtins.str*]’<br>
<a href="http://choose.py:15">choose.py:15</a>: error: Revealed type is ‘builtins.str*’</p>
</blockquote>
<p>此外，我们也可以进一步地限制<code>Type Variables</code>的可选类型范围，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Choosable = TypeVar(<span class="string">&quot;Choosable&quot;</span>, <span class="built_in">str</span>, <span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Example-A-Deck-of-Cards">Example: A Deck of Cards</h3>
<h4 id="Without-Annotations">Without Annotations</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">SUITS = <span class="string">&quot;♠ ♡ ♢ ♣&quot;</span>.split()</span><br><span class="line">RANKS = <span class="string">&quot;2 3 4 5 6 7 8 9 10 J Q K A&quot;</span>.split()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_deck</span>(<span class="params">shuffle=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a new deck of 52 cards&quot;&quot;&quot;</span></span><br><span class="line">    deck = [(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> RANKS <span class="keyword">for</span> s <span class="keyword">in</span> SUITS]</span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        random.shuffle(deck)</span><br><span class="line">        <span class="keyword">return</span> deck</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_hands</span>(<span class="params">deck</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deal the cards in the deck into four hands&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (deck[<span class="number">0</span>::<span class="number">4</span>], deck[<span class="number">1</span>::<span class="number">4</span>], deck[<span class="number">2</span>::<span class="number">4</span>], deck[<span class="number">3</span>::<span class="number">4</span>])</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Play a 4-player card game&quot;&quot;&quot;</span></span><br><span class="line">    deck = create_deck(shuffle=<span class="literal">True</span>)</span><br><span class="line">    names = <span class="string">&quot;P1 P2 P3 P4&quot;</span>.split()</span><br><span class="line">    hands = &#123;n: h <span class="keyword">for</span> n, h <span class="keyword">in</span> <span class="built_in">zip</span>(names, deal_hands(deck))&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> name, cards <span class="keyword">in</span> hands.items():</span><br><span class="line">		card_str = <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;s&#125;</span><span class="subst">&#123;r&#125;</span>&quot;</span> <span class="keyword">for</span> (s, r) <span class="keyword">in</span> cards)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;card_str&#125;</span>&quot;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	play()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>P4: ♣9 ♢9 ♡2 ♢7 ♡7 ♣A ♠6 ♡K ♡5 ♢6 ♢3 ♣3 ♣Q<br>
P1: ♡A ♠2 ♠10 ♢J ♣10 ♣4 ♠5 ♡Q ♢5 ♣6 ♠A ♣5 ♢4<br>
P2: ♢2 ♠7 ♡8 ♢K ♠3 ♡3 ♣K ♠J ♢A ♣7 ♡6 ♡10 ♠K<br>
P3: ♣2 ♣8 ♠8 ♣J ♢Q ♡9 ♡J ♠4 ♢8 ♢10 ♠9 ♡4 ♠Q</p>
</blockquote>
<h4 id="With-Annotations">With Annotations</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line">SUITS = <span class="string">&quot;♠ ♡ ♢ ♣&quot;</span>.split()</span><br><span class="line">RANKS = <span class="string">&quot;2 3 4 5 6 7 8 9 10 J Q K A&quot;</span>.split()</span><br><span class="line"></span><br><span class="line">Card = <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]</span><br><span class="line">Deck = <span class="type">List</span>[Card]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_deck</span>(<span class="params">shuffle: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; Deck:</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Create a new deck of 52 cards&quot;&quot;&quot;</span></span><br><span class="line">	deck = [(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> RANKS <span class="keyword">for</span> s <span class="keyword">in</span> SUITS]</span><br><span class="line">	<span class="keyword">if</span> shuffle:</span><br><span class="line">		random.shuffle(deck)</span><br><span class="line">	<span class="keyword">return</span> deck</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_hands</span>(<span class="params">deck: Deck</span>) -&gt; <span class="type">Tuple</span>[Deck, Deck, Deck, Deck]:</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Deal the cards in the deck into four hands&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> (deck[<span class="number">0</span>::<span class="number">4</span>], deck[<span class="number">1</span>::<span class="number">4</span>], deck[<span class="number">2</span>::<span class="number">4</span>], deck[<span class="number">3</span>::<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">items</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Choose and return a random item&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> random.choice(items)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">player_order</span>(<span class="params">names, start=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Rotate player order so that start goes first&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		start = choose(names)</span><br><span class="line">	start_idx = names.index(start)</span><br><span class="line">	<span class="keyword">return</span> names[start_idx:] + names[:start_idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Play a 4-player card game&quot;&quot;&quot;</span></span><br><span class="line">	deck = create_deck(shuffle=<span class="literal">True</span>)</span><br><span class="line">	names = <span class="string">&quot;P1 P2 P3 P4&quot;</span>.split()</span><br><span class="line">	hands = &#123;n: h <span class="keyword">for</span> n, h <span class="keyword">in</span> <span class="built_in">zip</span>(names, deal_hands(deck))&#125;</span><br><span class="line">	start_player = choose(names)</span><br><span class="line">	turn_order = player_order(names, start=start_player)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Randomly play cards from each player&#x27;s hand until empty</span></span><br><span class="line">	<span class="keyword">while</span> hands[start_player]:</span><br><span class="line">		<span class="keyword">for</span> name <span class="keyword">in</span> turn_order:</span><br><span class="line">			card = choose(hands[name])</span><br><span class="line">			hands[name].remove(card)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: <span class="subst">&#123;card[<span class="number">0</span>] + card[<span class="number">1</span>]:&lt;<span class="number">3</span>&#125;</span>  &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	play()</span><br></pre></td></tr></table></figure>
<h4 id="With-Annotations-OOP">With Annotations &amp; OOP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>:</span><br><span class="line">	SUITS = <span class="string">&quot;♠ ♡ ♢ ♣&quot;</span>.split()</span><br><span class="line">	RANKS = <span class="string">&quot;2 3 4 5 6 7 8 9 10 J Q K A&quot;</span>.split()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, suit, rank</span>):</span><br><span class="line">		self.suit = suit</span><br><span class="line">		self.rank = rank</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.suit&#125;</span><span class="subst">&#123;self.rank&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deck</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cards</span>):</span><br><span class="line">		self.cards = cards</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">cls, shuffle=<span class="literal">False</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Create a new deck of 52 cards&quot;&quot;&quot;</span></span><br><span class="line">		cards = [Card(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> Card.RANKS <span class="keyword">for</span> s <span class="keyword">in</span> Card.SUITS]</span><br><span class="line">		<span class="keyword">if</span> shuffle:</span><br><span class="line">			random.shuffle(cards)</span><br><span class="line">		<span class="keyword">return</span> cls(cards)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">deal</span>(<span class="params">self, num_hands</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Deal the cards in the deck into a number of hands&quot;&quot;&quot;</span></span><br><span class="line">		cls = self.__class__</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">tuple</span>(cls(self.cards[i::num_hands]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_hands))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hand</span>):</span><br><span class="line">		self.name = name</span><br><span class="line">		self.hand = hand</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">play_card</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Play a card from the player&#x27;s hand&quot;&quot;&quot;</span></span><br><span class="line">		card = random.choice(self.hand.cards)</span><br><span class="line">		self.hand.cards.remove(card)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>: <span class="subst">&#123;card!r:&lt;<span class="number">3</span>&#125;</span>  &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *names</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Set up the deck and deal cards to 4 players&quot;&quot;&quot;</span></span><br><span class="line">		deck = Deck.create(shuffle=<span class="literal">True</span>)</span><br><span class="line">		self.names = (<span class="built_in">list</span>(names) + <span class="string">&quot;P1 P2 P3 P4&quot;</span>.split())[:<span class="number">4</span>]</span><br><span class="line">		self.hands = &#123;</span><br><span class="line">			n: Player(n, h) <span class="keyword">for</span> n, h <span class="keyword">in</span> <span class="built_in">zip</span>(self.names, deck.deal(<span class="number">4</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Play a card game&quot;&quot;&quot;</span></span><br><span class="line">		start_player = random.choice(self.names)</span><br><span class="line">		turn_order = self.player_order(start=start_player)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Play cards from each player&#x27;s hand until empty</span></span><br><span class="line">		<span class="keyword">while</span> self.hands[start_player].hand.cards:</span><br><span class="line">			<span class="keyword">for</span> name <span class="keyword">in</span> turn_order:</span><br><span class="line">				self.hands[name].play_card()</span><br><span class="line">			<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">player_order</span>(<span class="params">self, start=<span class="literal">None</span></span>):</span><br><span class="line">		<span class="string">&quot;&quot;&quot;Rotate player order so that start goes first&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> start <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			start = random.choice(self.names)</span><br><span class="line">		start_idx = self.names.index(start)</span><br><span class="line">		<span class="keyword">return</span> self.names[start_idx:] + self.names[:start_idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	<span class="comment"># Read player names from command line</span></span><br><span class="line">	player_names = sys.argv[<span class="number">1</span>:]</span><br><span class="line">	game = Game(*player_names)</span><br><span class="line">	game.play()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法[Gradient Descent]</title>
    <url>/2017/03/02/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95-Gradient-Descent/</url>
    <content><![CDATA[<p>初步认识梯度下降这一算法，认识并分析其优缺点以更好地利用此算法。</p>
<h5 id="简介wiki">简介<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">wiki</a></h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/1.png" alt=""></p>
<h5 id="描述">描述</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/2.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/3.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/4.png" alt=""></p>
<h5 id="线性回归的应用">线性回归的应用</h5>
<p>参考<a href="https://github.com/mattnedrich/GradientDescentExample">这里</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = mx + b</span></span><br><span class="line"><span class="comment"># m is slope, b is y-intercept</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_error_for_line_given_points</span>(<span class="params">b, m, points</span>):</span><br><span class="line">    totalError = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">        x = points[i, <span class="number">0</span>]</span><br><span class="line">        y = points[i, <span class="number">1</span>]</span><br><span class="line">        totalError += (y - (m * x + b)) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> totalError / <span class="built_in">float</span>(<span class="built_in">len</span>(points))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_gradient</span>(<span class="params">b_current, m_current, points, learningRate</span>):</span><br><span class="line">    b_gradient = <span class="number">0</span></span><br><span class="line">    m_gradient = <span class="number">0</span></span><br><span class="line">    N = <span class="built_in">float</span>(<span class="built_in">len</span>(points))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">        x = points[i, <span class="number">0</span>]</span><br><span class="line">        y = points[i, <span class="number">1</span>]</span><br><span class="line">        b_gradient += -(<span class="number">2</span>/N) * (y - ((m_current * x) + b_current))</span><br><span class="line">        m_gradient += -(<span class="number">2</span>/N) * x * (y - ((m_current * x) + b_current))</span><br><span class="line">    new_b = b_current - (learningRate * b_gradient)</span><br><span class="line">    new_m = m_current - (learningRate * m_gradient)</span><br><span class="line">    <span class="keyword">return</span> [new_b, new_m]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent_runner</span>(<span class="params">points, starting_b, starting_m, learning_rate, num_iterations</span>):</span><br><span class="line">    b = starting_b</span><br><span class="line">    m = starting_m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">        b, m = step_gradient(b, m, array(points), learning_rate)</span><br><span class="line">    <span class="keyword">return</span> [b, m]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    points = genfromtxt(<span class="string">&quot;data.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    learning_rate = <span class="number">0.0001</span></span><br><span class="line">    initial_b = <span class="number">0</span> <span class="comment"># initial y-intercept guess</span></span><br><span class="line">    initial_m = <span class="number">0</span> <span class="comment"># initial slope guess</span></span><br><span class="line">    num_iterations = <span class="number">1000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting gradient descent at b = &#123;0&#125;, m = &#123;1&#125;, error = &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(initial_b, initial_m, compute_error_for_line_given_points(initial_b, initial_m, points)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Running...&quot;</span>)</span><br><span class="line">    [b, m] = gradient_descent_runner(points, initial_b, initial_m, learning_rate, num_iterations)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After &#123;0&#125; iterations b = &#123;1&#125;, m = &#123;2&#125;, error = &#123;3&#125;&quot;</span>.<span class="built_in">format</span>(num_iterations, b, m, compute_error_for_line_given_points(b, m, points)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 作图[只是为了直观地看下拟合的效果]</span></span><br><span class="line">    plt.plot([points[i,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))], [points[i,<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line">    x = linspace(<span class="built_in">min</span>([points[i,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))])-<span class="number">5</span>, <span class="built_in">max</span>([points[i,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points))])+<span class="number">5</span>, <span class="number">1000</span>)</span><br><span class="line">    plt.plot(x, m*x+b)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/5.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/6.png" alt=""></p>
<h5 id="梯度下降的弊端及验证">梯度下降的弊端及验证</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/7.png" alt=""></p>
<p>尝试验证wiki的下图：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/8.gif" alt=""></p>
<p>选取不同的学习率，实验结果如下：</p>
<blockquote>
<p>E1：Learning Rate = 0.0045</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/9.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/10.png" alt=""></p>
<blockquote>
<p>E2: Learning Rate = 0.0025</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/11.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/12.png" alt=""><br>
可以看到还是有一定的差别，推测与学习率和迭代次数有关，这个暂时留到以后深究。</p>
<p>Python实现源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归实现逐次求梯度，这里为了充分迭代，修改递归次数限制</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Rosenbrock函數的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - X) ** <span class="number">2</span> + <span class="number">100</span> * ((Y - X ** <span class="number">2</span>) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_gradient</span>(<span class="params">pre, learningRate=<span class="number">0.0025</span></span>):  <span class="comment">#0.0025</span></span><br><span class="line">    scatter.append(pre)</span><br><span class="line">    x = pre[<span class="number">0</span>]</span><br><span class="line">    y = pre[<span class="number">1</span>]</span><br><span class="line">    x_gradient = <span class="number">2</span>*(x-<span class="number">1</span>)+<span class="number">400</span>*x*(x**<span class="number">2</span>-y)</span><br><span class="line">    y_gradient = <span class="number">200</span>*(y-x**<span class="number">2</span>)</span><br><span class="line">    step_x = learningRate * x_gradient</span><br><span class="line">    step_y = learningRate * y_gradient</span><br><span class="line">    steps = [step_x, step_y]</span><br><span class="line">    now = [pre[<span class="number">0</span>] - steps[<span class="number">0</span>], pre[<span class="number">1</span>] - steps[<span class="number">1</span>]]</span><br><span class="line">    <span class="comment"># 将新的点存储到scatter列表里面去</span></span><br><span class="line">    z = func(now[<span class="number">0</span>], now[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># print(z)</span></span><br><span class="line">    z_l.append(z)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        step_gradient(now)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    <span class="comment"># ax = Axes3D(fig)</span></span><br><span class="line">    <span class="comment"># 随机度下降起始点</span></span><br><span class="line">    point = (-<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    scatter = []</span><br><span class="line">    z_l = []</span><br><span class="line">    scatter.append(point)</span><br><span class="line">    step_gradient(point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Total times&#x27;</span>, <span class="built_in">len</span>(scatter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Min_z--&gt;&quot;</span>, <span class="built_in">min</span>(z_l))</span><br><span class="line">    plt.plot([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], [point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    X = np.arange(-<span class="number">0.8</span>, <span class="number">1</span>, <span class="number">0.01</span>)</span><br><span class="line">    Y = np.arange(-<span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">0.025</span>)</span><br><span class="line">    X, Y = np.meshgrid(X, Y)</span><br><span class="line">    Z = func(X, Y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=&#x27;rainbow&#x27;)</span></span><br><span class="line">    <span class="comment"># plt.show()</span></span><br><span class="line">    CS = plt.contour(X, Y, Z, <span class="number">100</span>)</span><br><span class="line">    manual_locations = [(i, i+<span class="number">0.02</span>) <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(-<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">10</span>)]</span><br><span class="line">    manual_locations.append((<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    plt.clabel(CS, inline=<span class="number">1</span>, fontsize=<span class="number">8</span>, manual=manual_locations)</span><br><span class="line">    plt.title(<span class="string">&#x27;Rosenbrock&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>适当调节参数，也可以作出下面的图：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/13.png" alt=""><br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/14.png" alt=""></p>
<p>第一次补充：[尝试放大局部图像找到所谓的“之”字形失败]<br>
之前未能实现wiki“之”字形震荡, 就想到可能是点过于密集导致微小的弯折被掩盖，于是进行局部放大图像的尝试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归实现逐次求梯度，这里为了充分迭代，修改递归次数限制</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Rosenbrock函數的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - X) ** <span class="number">2</span> + <span class="number">100</span> * ((Y - X ** <span class="number">2</span>) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step_gradient</span>(<span class="params">pre, learningRate=<span class="number">0.0045</span></span>):  <span class="comment">#0.0025</span></span><br><span class="line">    scatter.append(pre)</span><br><span class="line">    x = pre[<span class="number">0</span>]</span><br><span class="line">    y = pre[<span class="number">1</span>]</span><br><span class="line">    x_gradient = <span class="number">2</span>*(x-<span class="number">1</span>)+<span class="number">400</span>*x*(x**<span class="number">2</span>-y)</span><br><span class="line">    y_gradient = <span class="number">200</span>*(y-x**<span class="number">2</span>)</span><br><span class="line">    step_x = learningRate * x_gradient</span><br><span class="line">    step_y = learningRate * y_gradient</span><br><span class="line">    steps = [step_x, step_y]</span><br><span class="line">    now = [pre[<span class="number">0</span>] - steps[<span class="number">0</span>], pre[<span class="number">1</span>] - steps[<span class="number">1</span>]]</span><br><span class="line">    <span class="comment"># 将新的点存储到scatter列表里面去</span></span><br><span class="line">    z = func(now[<span class="number">0</span>], now[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># print(z)</span></span><br><span class="line">    z_l.append(z)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        step_gradient(now)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">16</span>, <span class="number">8</span>), dpi=<span class="number">98</span>)</span><br><span class="line">    p1 = plt.subplot(<span class="number">121</span>, aspect=<span class="number">1.8</span> / <span class="number">1.3</span>)</span><br><span class="line">    p2 = plt.subplot(<span class="number">122</span>, aspect=<span class="number">0.06</span> / <span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机度下降起始点</span></span><br><span class="line">    point = (-<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    scatter = []</span><br><span class="line">    z_l = []</span><br><span class="line">    scatter.append(point)</span><br><span class="line">    step_gradient(point)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Total times&#x27;</span>, <span class="built_in">len</span>(scatter))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Min_z--&gt;&quot;</span>, <span class="built_in">min</span>(z_l))</span><br><span class="line">    p1.plot([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], [point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p2.plot([point[<span class="number">0</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], [point[<span class="number">1</span>] <span class="keyword">for</span> point <span class="keyword">in</span> scatter], <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    p2.axis([-<span class="number">0.02</span>, <span class="number">0.04</span>, -<span class="number">0.0005</span>, <span class="number">0.0005</span>])</span><br><span class="line"></span><br><span class="line">    X = np.arange(-<span class="number">0.8</span>, <span class="number">1</span>, <span class="number">0.01</span>)</span><br><span class="line">    Y = np.arange(-<span class="number">0.2</span>, <span class="number">1.1</span>, <span class="number">0.025</span>)</span><br><span class="line">    X, Y = np.meshgrid(X, Y)</span><br><span class="line">    Z = func(X, Y)</span><br><span class="line"></span><br><span class="line">    CS = p1.contour(X, Y, Z, <span class="number">100</span>)</span><br><span class="line">    manual_locations = [(i, i+<span class="number">0.02</span>) <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(-<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">10</span>)]</span><br><span class="line">    manual_locations.append((<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    p1.clabel(CS, inline=<span class="number">1</span>, fontsize=<span class="number">8</span>, manual=manual_locations)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到结果如下[显然实验失败了:-)]<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/ML/gradient/15.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ML</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>添加OpenCV3对Python3的支持&amp;QT中使用OpenCV</title>
    <url>/2017/08/15/%E6%B7%BB%E5%8A%A0OpenCV3%E5%AF%B9Python3%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>一直用的Python3,但是呢之前编译OpenCV只是按照默认添加了对Python2的支持，于是有进行重新编译，多次挂掉后总算成功了，这里做下记录。</p>
<h5 id="关于编译时的可选参数">关于编译时的可选参数</h5>
<p>编译环境：</p>
<blockquote>
<p>Ubuntu16.04LTS 64-Bit 英文版</p>
</blockquote>
<p>编译还是根据<a href="http://docs.opencv.org/3.1.0/d7/d9f/tutorial_linux_install.html">官网教程</a>来的，但是教程只是给了最基本的编译示例，其他的可选参数并未做太多说明。我们用的是cmake-gui进行选择，影响编译的几个选项就是下面这些：</p>
<blockquote>
<p><strong>CUDA</strong>: 本次编译只是选了<code>WITH_CUDA</code>， 但是选择其他相关的文件进行编译有时会出错。由于我这小本本不支持CUDA的，所以下次不选就是了。</p>
<p><strong>dnn</strong>: 只要包含dnn就出错orz…本次编译全部取消勾选dnn相关文件才通过了.可能是新版本支持不好？</p>
<p><strong>TBB</strong>：这个也是十分蛋疼啊。。。加上也是出错</p>
<p><strong>EIGEN</strong>: 可以添加，未出错</p>
<p><strong>OPENCL</strong>： 可以添加，未出错</p>
<p><strong>OPENGL</strong>: 未添加</p>
</blockquote>
<p>关于Python（使用的anaconda）路径的设置：</p>
<p>参考<a href="https://stackoverflow.com/questions/36201282/install-opencv-for-python3">这里</a></p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Screenshot%20from%202017-08-15%2017-31-16.png" alt=""></p>
<h5 id="关于最后的软链接">关于最后的软链接</h5>
<p>参考<a href="http://www.pyimagesearch.com/2015/07/20/install-opencv-3-0-and-python-3-4-on-ubuntu/">这里</a></p>
<p>切换到<code>/home/shensir/anaconda3/lib/python3.6/site-packages</code><br>
执行：</p>
<blockquote>
<p>sudo ln -s ‘/home/shensir/anaconda3/lib/python3.6/site-packages/cv2.cpython-36m-x86_64-linux-gnu.so’  <a href="http://cv2.so">cv2.so</a></p>
</blockquote>
<h5 id="Python下的报错">Python下的报错</h5>
<p>嗯，上面准备的很妥当了，接下来就是…新的报错了orz…</p>
<blockquote>
<p>ImportError: /usr/lib/liblapack.so.3: undefined symbol: gotoblas</p>
</blockquote>
<p>基本上没找到相关资料，但是有个<a href="https://stackoverflow.com/questions/8917977/installing-lapack-for-numpy">类似的</a>, 试了试竟然成功了：</p>
<blockquote>
<p>sudo apt-get remove libopenblas-base</p>
</blockquote>
<h5 id="在QT中使用OpenCV">在QT中使用OpenCV</h5>
<p>看到很多书上的教程是基于QT来讲的，这里也接着在QT设置了OpenCV的支持。主要参考<a href="https://www.youtube.com/watch?v=qA46fvP3O5A">这里</a>[及其风骚的操作…]。其实关键是在QT添加OpenCV库的链接，只需要在配置文件<code>xxx.pro</code>中最后添加两行即可：</p>
<blockquote>
<p>INCLUDEPATH += “/usr/local/include/”<br>
LIBS += <code>pkg-config --libs opencv</code></p>
</blockquote>
<blockquote>
<p>ps: 看到视频里面用QT做应用竟然如此方便…嗯，又要入坑QT吗。。。</p>
</blockquote>
<h5 id="后记-2">后记</h5>
<p>折腾那么久，终于解决了…其实添加3的支持也是因为今天看到了<a href="https://pythonprogramming.net/">这个</a>, 绝对的大佬…想着有空跟进这里的项目来学习。嗯，就这样。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊的均匀分布U(0, 1)</title>
    <url>/2018/04/08/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83U-0-1/</url>
    <content><![CDATA[<iframe src="http://nbviewer.jupyter.org/github/shenxiangzhuang/Probability/blob/master/MyRandom.ipynb" width="700" height="900"></iframe>
<p>参考：<br>
<a href="https://zh.wikipedia.org/wiki/%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0">erf</a><br>
<a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal distribution</a><br>
<a href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.special.erfinv.html#scipy.special.erfinv">scipy.special.erfinv</a><br>
<a href="http://www.codecogs.com/latex/eqneditor.php">latex</a><br>
<a href="http://huanyouchen.github.io/2018/05/30/hexo-support-jupyter-notebook-in-blog/">在hexo中写的文章支持jupyter-notebook显示</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title>百年回首--关于心形曲线的几种画法</title>
    <url>/2017/08/16/%E7%99%BE%E5%B9%B4%E5%9B%9E%E9%A6%96-%E5%85%B3%E4%BA%8E%E5%BF%83%E5%9E%8B%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%BB%E6%B3%95/</url>
    <content><![CDATA[<h4 id="Overview-63">Overview</h4>
<p>今天和同学聊到了心形曲线。。刚吃完饭闲着。。。来画一下。</p>
<h4 id="Code-52">Code</h4>
<h5 id="Python-2">Python</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = <span class="number">5.21</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">100</span>)</span><br><span class="line">r = a*(<span class="number">1</span> - np.sin(theta))</span><br><span class="line">plt.polar(theta, r)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/figure_1.png" alt=""></p>
<h5 id="Octave-Matlab">Octave/Matlab</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">theta = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">100</span>);</span><br><span class="line">r = <span class="number">5.21</span>*(<span class="number">1</span>-<span class="built_in">sin</span>(theta));</span><br><span class="line">polar(theta, r)</span><br><span class="line">polar(theta, r)</span><br><span class="line">title(<span class="string">&#x27;5.21-L&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/octave.png" alt=""></p>
<h5 id="R">R</h5>
<p>emmm…由于R好像没有现成的画极座标的东西，所以手动转了下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a <span class="operator">&lt;-</span> 5.21</span><br><span class="line">theta <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span><span class="operator">*</span><span class="built_in">pi</span><span class="punctuation">,</span> len<span class="operator">=</span><span class="number">100</span><span class="punctuation">)</span></span><br><span class="line">r <span class="operator">&lt;-</span> a<span class="operator">*</span><span class="punctuation">(</span><span class="number">1</span> <span class="operator">-</span> <span class="built_in">sin</span><span class="punctuation">(</span>theta<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">cos</span><span class="punctuation">(</span>theta<span class="punctuation">)</span><span class="operator">*</span>r</span><br><span class="line">y <span class="operator">&lt;-</span> <span class="built_in">sin</span><span class="punctuation">(</span>theta<span class="punctuation">)</span><span class="operator">*</span>r</span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">)</span></span><br><span class="line">title<span class="punctuation">(</span><span class="string">&#x27;5.21-L&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Rplot.png" alt=""></p>
<h5 id="Cpp-2">Cpp</h5>
<p>Cpp画图实在是比较伤…用了OpenCV的接口才勉强能看…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlotCurve</span><span class="params">(<span class="type">double</span> a=<span class="number">5.21</span>)</span></span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">Mat</span>(<span class="number">300</span>, <span class="number">300</span>, CV_8U, cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    <span class="type">double</span> theta0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(theta0 &lt;= <span class="number">2</span>*M_PI)&#123;</span><br><span class="line">        <span class="type">double</span> r0 = a*(<span class="number">1</span>-<span class="built_in">sin</span>(theta0));</span><br><span class="line">        cv::Point p = cv::<span class="built_in">Point</span>(<span class="built_in">cos</span>(theta0)*r0*<span class="number">10</span>+<span class="number">150</span>, <span class="number">300</span>-(<span class="built_in">sin</span>(theta0)*r0*<span class="number">10</span>+<span class="number">200</span>));</span><br><span class="line">        cv::<span class="built_in">circle</span>(image, p, <span class="number">1</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),<span class="number">-1</span>);</span><br><span class="line">        theta0 += <span class="number">2</span>*M_1_PI/<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;5.21-L&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">PlotCurve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201707/Cpp.png" alt=""></p>
<p>嗯，就这些吧，Haskell还是不碰的好:-)…其他的语言也不会了orz…</p>
<h5 id="SAS">SAS</h5>
<p>========2017.9.23更==============</p>
<p>感觉SAS这货的做的图也是很不错…</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">DATA </span>heart;</span><br><span class="line">    a = 0.521;</span><br><span class="line">    pi = 3.1415926;</span><br><span class="line">    theta = 0;</span><br><span class="line">    r = 0;</span><br><span class="line">    <span class="keyword">x</span>=0;</span><br><span class="line">    y=0;</span><br><span class="line">    <span class="keyword">do</span> i=1 to 101;</span><br><span class="line">    theta = theta + pi/50;</span><br><span class="line">    r = a<span class="comment">*(1-sin(theta));</span></span><br><span class="line">    <span class="keyword">x</span> = r<span class="comment">*cos(theta);</span></span><br><span class="line">    y = r<span class="comment">*sin(theta);</span></span><br><span class="line">    <span class="keyword">output</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">RUN;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">PROC gplot </span>data=heart;</span><br><span class="line">    symbol v=none i=spline c=red;</span><br><span class="line">    <span class="keyword">title</span> <span class="string">&#x27;My Heart&#x27;</span>;</span><br><span class="line">    plot y<span class="comment">*x;</span></span><br><span class="line"><span class="keyword">RUN;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图。。忘记保存了…放个照片先…</p>
<p><img src="http://datahonor-1252464519.costj.myqcloud.com/201708/IMG_20170923_173943.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Cpp</tag>
        <tag>Octave</tag>
        <tag>R</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>百度新闻爬虫——多进程抓取</title>
    <url>/2017/03/02/%E7%99%BE%E5%BA%A6%E6%96%B0%E9%97%BB%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<hr>
<p>基于<a href="http://datahonor.com/2017/03/02/%E7%99%BE%E5%BA%A6%E6%96%B0%E9%97%BB%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%99%AE%E9%80%9A%E6%8A%93%E5%8F%96/">上文</a>的改进，使用进程池抓取。</p>
<p>环境：</p>
<blockquote>
<p>Ubuntu14.04, Pycharm, Anaconda3,<br>
MySQL:mysql  Ver 14.14 Distrib 5.5.53, for debian-linux-gnu (x86_64) using readline 6.3</p>
</blockquote>
<p>文件目录：</p>
<blockquote>
<p><a href="http://MyTools.py">MyTools.py</a> 存放获取，解析并储存网页内容的工具函数[和上文的一样]<br>
processing_pool.py  单线程普通抓取的实现<br>
<a href="http://globalValue.py">globalValue.py</a>  新闻条数count的跨文件传递.</p>
</blockquote>
<h5 id="MyTools-py"><a href="http://MyTools.py">MyTools.py</a></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  globalValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># headers = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&quot;&#125;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开数据库，之后在具体调用后close</span></span><br><span class="line">db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;数据库密码&quot;</span>, <span class="string">&quot;数据库名称&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现：给定新闻类别链接的列表class_urls，获取并储存数据</span></span><br><span class="line"><span class="comment"># 待实现函数:get_class_data, getdata</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_save_data</span>(<span class="params">class_urls</span>):</span><br><span class="line">    <span class="keyword">for</span> class_url <span class="keyword">in</span> class_urls:</span><br><span class="line">        class_data = get_class_data(class_url)</span><br><span class="line">        getdata(class_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个分类提取单个新闻标题信息class_data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class_data</span>(<span class="params">class_url</span>):</span><br><span class="line">    classname = class_url.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    class_data = requests.get(class_url, headers=headers)</span><br><span class="line">    pa = re.<span class="built_in">compile</span>(<span class="string">r&#x27;charset=(.*?)&quot;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        charset = re.findall(pa, class_data.text)[<span class="number">0</span>]</span><br><span class="line">        class_data.encoding = charset</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># class_data.encoding = &#x27;gbk&#x27;</span></span><br><span class="line">    class_data = class_data.text</span><br><span class="line">    soup = BeautifulSoup(class_data, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    data = soup.findAll(<span class="string">&#x27;a&#x27;</span>, &#123;<span class="string">&#x27;target&#x27;</span>: <span class="string">&#x27;_blank&#x27;</span>&#125;)</span><br><span class="line">    class_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        title = data[i].get_text()</span><br><span class="line">        href = data[i].get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="comment"># 过滤一些干扰链接</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(title) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;下载&#x27;</span> <span class="keyword">in</span> title:</span><br><span class="line">                class_data[title] = href</span><br><span class="line"></span><br><span class="line">    classname = class_url.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>][<span class="number">7</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里返回classname,主要是为了入库方便</span></span><br><span class="line">    <span class="keyword">return</span> [classname, class_data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现：根据传入的新闻类别的信息class_data, 获取新闻文本并存入数据库</span></span><br><span class="line"><span class="comment"># 待实现函数：get_news_text</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdata</span>(<span class="params">class_data</span>):</span><br><span class="line">    class_title = class_data[<span class="number">0</span>]</span><br><span class="line">    class_data = class_data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> news_title, news_url <span class="keyword">in</span> <span class="built_in">dict</span>(class_data).items():</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(news_title)</span><br><span class="line">        text = get_news_text(news_url)</span><br><span class="line">        <span class="keyword">if</span> text <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Got text data...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text = <span class="string">&#x27;lost&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sql = <span class="string">&#x27;INSERT INTO BaiduNews(class, title, text)VALUES(%s,%s,%s)&#x27;</span></span><br><span class="line">            cursor.execute(sql, (class_title, news_title, text))</span><br><span class="line">            <span class="comment"># 提交事务</span></span><br><span class="line">            db.commit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Save fail...&#x27;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每条新闻的具体文本内容，粗略抓取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">百度新闻的链接是跳转到各个新闻网站的，网站大部分的结构都不同，</span></span><br><span class="line"><span class="string">很难做到完全抓取到文本，所以目前只能粗略抓取。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">之后会进行pyquery 的 css抓取，有时间会研究下专门的文本抓取算法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_news_text</span>(<span class="params">href</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = requests.get(href, headers=headers)</span><br><span class="line">        <span class="comment"># 检测编码</span></span><br><span class="line">        char = chardet.detect(data.content)</span><br><span class="line">        data.encoding = char[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line">        <span class="comment"># 解析网页</span></span><br><span class="line">        data = BeautifulSoup(data.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        <span class="comment"># 这里对于同一属性多个值进行匹配</span></span><br><span class="line">        <span class="comment"># data = BeautifulSoup(data.text,&#x27;lxml&#x27;).find(&quot;div&quot;, &#123;&#x27;class&#x27;: [&#x27;text&#x27;, &#x27;article&#x27;, &#x27;content&#x27;]&#125;)</span></span><br><span class="line">        data = data.find(<span class="string">&quot;div&quot;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: re.<span class="built_in">compile</span>(<span class="string">r&quot;^(text|article|content)$&quot;</span>)&#125;)</span><br><span class="line">        text = data.get_text()</span><br><span class="line">        count = globalValue.get_value()</span><br><span class="line">        <span class="built_in">print</span>(count)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        globalValue.set_value(count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        text = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_format_addr</span>(<span class="params">s</span>):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name,<span class="string">&#x27;utf-8&#x27;</span>).encode(), addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_ms</span>(<span class="params">T</span>):</span><br><span class="line">    from_addr = <span class="string">&quot;发件箱，自定义&quot;</span></span><br><span class="line">    <span class="comment"># 开启QQ邮箱STMP服务的授权码</span></span><br><span class="line">    <span class="comment"># 参考这里http://jingyan.baidu.com/article/4f7d5712b1ac7c1a201927da.html</span></span><br><span class="line">    password = <span class="string">&#x27;授权码&#x27;</span></span><br><span class="line">    to_addr = <span class="string">&#x27;收件箱[需开启STMP服务]&#x27;</span></span><br><span class="line">    smtp_server = <span class="string">&#x27;smtp.qq.com&#x27;</span></span><br><span class="line">    msg = MIMEText(T, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;Anyone&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;Echo&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;The New Report&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line">    server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>, timeout=<span class="number">10</span>)</span><br><span class="line">    server.set_debuglevel(<span class="number">0</span>)</span><br><span class="line">    server.login(from_addr,password)</span><br><span class="line">    server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="processing-pool-py">processing_pool.py</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">进程池抓取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> send_email</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> MyTools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span>  globalValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    globalValue.set_value(count)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    s = time.ctime()</span><br><span class="line"></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&quot;</span>&#125;</span><br><span class="line">    class_list = [<span class="string">&#x27;http://finance.baidu.com/&#x27;</span>, <span class="string">&#x27;http://internet.baidu.com/&#x27;</span>, <span class="string">&#x27;http://yule.baidu.com/&#x27;</span>,</span><br><span class="line">                       <span class="string">&#x27;http://shipin.news.baidu.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    data_lists = []</span><br><span class="line">    <span class="keyword">for</span> class_url <span class="keyword">in</span> class_list:</span><br><span class="line">        data = get_class_data(class_url)</span><br><span class="line">        data_lists.append(data)</span><br><span class="line"></span><br><span class="line">    pool = Pool(processes=<span class="number">4</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(getdata, data_lists)</span><br><span class="line">    count = globalValue.get_value()</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    e = time.ctime()</span><br><span class="line"></span><br><span class="line">    total_time = end - start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;processing_pool.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;\nprocessing_pool抓取\n本次抓取开始于%s,结束于%s,耗时%s\n&quot;</span>%(s, e, total_time))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="globalValue-py"><a href="http://globalValue.py">globalValue.py</a></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">input_value</span>):</span><br><span class="line">    <span class="keyword">global</span> value</span><br><span class="line">    value = input_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>():</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志文件：</p>
<p>[可以看到约190秒,较普通抓取有明显的速度提速]<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/baidu/3.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>百度新闻爬虫——普通抓取</title>
    <url>/2017/03/02/%E7%99%BE%E5%BA%A6%E6%96%B0%E9%97%BB%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%99%AE%E9%80%9A%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<p>一个关于百度新闻的爬虫， 分类提取新闻文本。</p>
<p>环境</p>
<blockquote>
<p>Ubuntu14.04, Pycharm, Anaconda3,<br>
MySQL:mysql  Ver 14.14 Distrib 5.5.53, for debian-linux-gnu (x86_64) using readline 6.3</p>
</blockquote>
<p>文件目录：</p>
<blockquote>
<p><a href="http://MyTools.py">MyTools.py</a> 存放获取，解析并储存网页内容的工具函数<br>
single_thread.py  单线程普通抓取的实现<br>
<a href="http://globalValue.py">globalValue.py</a>  新闻条数count的跨文件传递，参考<a href="http://www.jianshu.com/p/6cee728f3490">这里</a></p>
</blockquote>
<h5 id="MyTools-py-2"><a href="http://MyTools.py">MyTools.py</a></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  globalValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># headers = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&quot;&#125;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开数据库，之后在具体调用后close</span></span><br><span class="line">db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;你的密码&quot;</span>, <span class="string">&quot;USpiderData&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现：给定新闻类别链接的列表class_urls，获取并储存数据</span></span><br><span class="line"><span class="comment"># 待实现函数:get_class_data, getdata</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_save_data</span>(<span class="params">class_urls</span>):</span><br><span class="line">    <span class="keyword">for</span> class_url <span class="keyword">in</span> class_urls:</span><br><span class="line">        class_data = get_class_data(class_url)</span><br><span class="line">        getdata(class_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个分类提取单个新闻标题信息class_data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class_data</span>(<span class="params">class_url</span>):</span><br><span class="line">    classname = class_url.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    class_data = requests.get(class_url, headers=headers)</span><br><span class="line"></span><br><span class="line">    char = chardet.detect(class_data.content)</span><br><span class="line">    class_data.encoding = char[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line">    <span class="comment"># 解析网页</span></span><br><span class="line">    class_data = class_data.text</span><br><span class="line">    soup = BeautifulSoup(class_data, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    data = soup.findAll(<span class="string">&#x27;a&#x27;</span>, &#123;<span class="string">&#x27;target&#x27;</span>: <span class="string">&#x27;_blank&#x27;</span>&#125;)</span><br><span class="line">    class_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        title = data[i].get_text()</span><br><span class="line">        href = data[i].get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="comment"># 过滤一些干扰链接</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(title) &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;下载&#x27;</span> <span class="keyword">in</span> title:</span><br><span class="line">                class_data[title] = href</span><br><span class="line"></span><br><span class="line">    classname = class_url.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>][<span class="number">7</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里返回classname,主要是为了入库方便</span></span><br><span class="line">    <span class="keyword">return</span> [classname, class_data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现：根据传入的新闻类别的信息class_data, 获取新闻文本并存入数据库</span></span><br><span class="line"><span class="comment"># 待实现函数：get_news_text</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getdata</span>(<span class="params">class_data</span>):</span><br><span class="line">    class_title = class_data[<span class="number">0</span>]</span><br><span class="line">    class_data = class_data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> news_title, news_url <span class="keyword">in</span> <span class="built_in">dict</span>(class_data).items():</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(news_title)</span><br><span class="line">        text = get_news_text(news_url)</span><br><span class="line">        <span class="keyword">if</span> text <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Got text data...&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text = <span class="string">&#x27;lost&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sql = <span class="string">&#x27;INSERT INTO BaiduNews(class, title, text)VALUES(%s,%s,%s)&#x27;</span></span><br><span class="line">            cursor.execute(sql, (class_title, news_title, text))</span><br><span class="line">            <span class="comment"># 提交事务</span></span><br><span class="line">            db.commit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Save fail...&#x27;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每条新闻的具体文本内容，粗略抓取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">百度新闻的链接是跳转到各个新闻网站的，网站大部分的结构都不同，</span></span><br><span class="line"><span class="string">很难做到完全抓取到文本，所以目前只能粗略抓取。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">之后会进行pyquery 的 css抓取，有时间会研究下专门的文本抓取算法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_news_text</span>(<span class="params">href</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = requests.get(href, headers=headers)</span><br><span class="line">        <span class="comment"># 检测编码</span></span><br><span class="line">        char = chardet.detect(data.content)</span><br><span class="line">        data.encoding = char[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line">        <span class="comment"># 解析网页</span></span><br><span class="line">        data = BeautifulSoup(data.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        <span class="comment"># 这里对于同一属性多个值进行匹配</span></span><br><span class="line">        <span class="comment"># data = BeautifulSoup(data.text,&#x27;lxml&#x27;).find(&quot;div&quot;, &#123;&#x27;class&#x27;: [&#x27;text&#x27;, &#x27;article&#x27;, &#x27;content&#x27;]&#125;)</span></span><br><span class="line">        data = data.find(<span class="string">&quot;div&quot;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: re.<span class="built_in">compile</span>(<span class="string">r&quot;^(text|article|content)$&quot;</span>)&#125;)</span><br><span class="line">        text = data.get_text()</span><br><span class="line">        count = globalValue.get_value()</span><br><span class="line">        <span class="built_in">print</span>(count)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        globalValue.set_value(count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        text = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_format_addr</span>(<span class="params">s</span>):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name,<span class="string">&#x27;utf-8&#x27;</span>).encode(), addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_ms</span>(<span class="params">T</span>):</span><br><span class="line">    from_addr = <span class="string">&quot;1021550072@qq.com&quot;</span></span><br><span class="line">    <span class="comment"># 开启QQ邮箱STMP服务的授权码</span></span><br><span class="line">    <span class="comment"># 参考这里http://jingyan.baidu.com/article/4f7d5712b1ac7c1a201927da.html</span></span><br><span class="line">    password = <span class="string">&#x27;你的密钥&#x27;</span></span><br><span class="line">    to_addr = <span class="string">&#x27;1021550072@qq.com&#x27;</span></span><br><span class="line">    smtp_server = <span class="string">&#x27;smtp.qq.com&#x27;</span></span><br><span class="line">    msg = MIMEText(T, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;Anyone&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;Echo&#x27;</span>)</span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;The New Report&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line">    server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>, timeout=<span class="number">10</span>)</span><br><span class="line">    server.set_debuglevel(<span class="number">0</span>)</span><br><span class="line">    server.login(from_addr,password)</span><br><span class="line">    server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="single-thread-py">single_thread.py</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> MyTools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  globalValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 初始化count，记录抓取的新闻条数</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    globalValue.set_value(count)</span><br><span class="line"></span><br><span class="line">    s = time.ctime()</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    class_lists = [<span class="string">&#x27;http://finance.baidu.com/&#x27;</span>, <span class="string">&#x27;http://internet.baidu.com/&#x27;</span>, <span class="string">&#x27;http://yule.baidu.com/&#x27;</span>,</span><br><span class="line">                       <span class="string">&#x27;http://shipin.news.baidu.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始抓取</span></span><br><span class="line">    get_save_data(class_lists)</span><br><span class="line">    count = globalValue.get_value()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记得关闭数据库</span></span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    e = time.ctime()</span><br><span class="line">    total_time = end - start</span><br><span class="line">    <span class="built_in">print</span>(total_time)</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="comment"># 抓取的日志文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;single_thread.txt&quot;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;\nSingle-thread抓取\n本次抓取开始于%s,结束于%s,耗时%s\n共抓取新闻%s条&quot;</span>%(s, e, total_time, count))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送邮件通知，可选</span></span><br><span class="line">    T = <span class="string">&quot;\nSingle-thread抓取\n本次抓取开始于%s,结束于%s,耗时%s\n共抓取新闻%s条&quot;</span>%(s, e, total_time, count)</span><br><span class="line"></span><br><span class="line">    send_ms(T)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;已成功发送邮件，请查收&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="globalValue-py-2"><a href="http://globalValue.py">globalValue.py</a></h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">input_value</span>):</span><br><span class="line">    <span class="keyword">global</span> value</span><br><span class="line">    value = input_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>():</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>日志文件及运行结果[同时会发送邮件到指定邮箱]：<br>
[可以看到约400多秒]</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/baidu/1.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/baidu/2.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛入门经典[紫书]习题笔记(第三章)</title>
    <url>/2017/03/16/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%B4%AB%E4%B9%A6-%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<p>紫书第三章习题代码及笔记。主要是想练习下c++的使用，有错误欢迎指出，有可以改进的地方请不吝赐教，多加交流。</p>
<h5 id="练习题">练习题</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目1--统计个数[不用数组]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;  <span class="comment">// count用于计数</span></span><br><span class="line">    <span class="type">float</span> num;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;num) == <span class="number">1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nums: %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//题目1--求最大值，最小值，均值[不用数组]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int  count = 0;</span></span><br><span class="line"><span class="comment">    float num, sum=0, min_x, max_x;</span></span><br><span class="line"><span class="comment">    while ( scanf(&quot;%f&quot;, &amp;num) == 1)&#123;</span></span><br><span class="line"><span class="comment">        if(count == 0)&#123;min_x = max_x = num;&#125;</span></span><br><span class="line"><span class="comment">        if(num &gt; max_x) max_x = num;</span></span><br><span class="line"><span class="comment">        if(num &lt; min_x) min_x = num;</span></span><br><span class="line"><span class="comment">        sum += num;</span></span><br><span class="line"><span class="comment">        count++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;Max:%f Min:%f Ave:%f\n&quot;, max_x, min_x, sum/count);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目1--哪两个数最接近[数组]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int nums[maxn];</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int num, n = 0;</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%d&quot;, &amp;num) == 1) &#123;</span></span><br><span class="line"><span class="comment">        nums[n] = num;</span></span><br><span class="line"><span class="comment">        n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int min_d = std::abs(nums[0]-nums[1]);</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;n;j++)&#123;</span></span><br><span class="line"><span class="comment">            if(j != i)&#123;</span></span><br><span class="line"><span class="comment">                if(std::abs(nums[i]-nums[j]) &lt; min_d) min_d = std::abs(nums[i]-nums[j]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;, min_d);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目1--第二大的数[数组]</span></span><br><span class="line"><span class="comment">//思路一：先获取数组最大值，在获取去除最大值后的数组，在求最大值</span></span><br><span class="line"><span class="comment">// 获取数组的最大值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float getmax(float arr[], int n);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    float num, nums[maxn];</span></span><br><span class="line"><span class="comment">    int n=0;</span></span><br><span class="line"><span class="comment">    // 将输入的数字存入数组nums</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%f&quot;, &amp;num) == 1)&#123;</span></span><br><span class="line"><span class="comment">        nums[n] = num;</span></span><br><span class="line"><span class="comment">        n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    float max_x = getmax(nums, n);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    float newnums[maxn];</span></span><br><span class="line"><span class="comment">    int newn = 0;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(nums[i] != max_x) &#123;</span></span><br><span class="line"><span class="comment">            newnums[newn] = nums[i];</span></span><br><span class="line"><span class="comment">            newn++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    float sec_max_x = getmax(newnums, newn);</span></span><br><span class="line"><span class="comment">    printf(&quot;%f\n&quot;, sec_max_x);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">float getmax(float arr[], int n)&#123;</span></span><br><span class="line"><span class="comment">    float max_x_arr = arr[0];</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(arr[i] &gt; max_x_arr) max_x_arr = arr[i];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return max_x_arr;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目1--第二大的数[数组]</span></span><br><span class="line"><span class="comment">// 思路二：冒泡排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void bubblesort(float A[], int n)&#123;</span></span><br><span class="line"><span class="comment">    bool sorted = false;  // 整体排序标志，首先假定尚未进行排序</span></span><br><span class="line"><span class="comment">    while(!sorted)&#123;  //在尚未确认已经全局排序之前，逐趟进行扫描交换</span></span><br><span class="line"><span class="comment">        sorted = true;  // 假定已经排序</span></span><br><span class="line"><span class="comment">        for (int i =1; i &lt; n; i++ )&#123;</span></span><br><span class="line"><span class="comment">            if (A[i - 1] &gt; A[i])&#123; // 一旦A[i-1]与A[i]逆序，则</span></span><br><span class="line"><span class="comment">                std::swap( A[i-1], A[i]); // 交换之</span></span><br><span class="line"><span class="comment">                sorted = false;// 因整体排序不能保证，需要清除排序标志</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">           n--;  // 至此末位元素必然就位， 故可以缩短排序序列的有效长度。</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;// 借助布尔值标志位sorted, 可以及时提前退出，而不至于总是忙里地做n-1次扫描</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    float num, nums[maxn];</span></span><br><span class="line"><span class="comment">    int n = 0;</span></span><br><span class="line"><span class="comment">    // 将输入的数字存入数组nums</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%f&quot;, &amp;num) == 1) &#123;</span></span><br><span class="line"><span class="comment">        nums[n] = num;</span></span><br><span class="line"><span class="comment">        n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    bubblesort(nums, n);</span></span><br><span class="line"><span class="comment">    printf(&quot;%f\n&quot;, nums[n-2]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目1--方差[数组]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数组方差</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float getvar(float arr[], int n);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    float num, nums[maxn];</span></span><br><span class="line"><span class="comment">    int n = 0;</span></span><br><span class="line"><span class="comment">    // 将输入的数字存入数组nums</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%f&quot;, &amp;num) == 1) &#123;</span></span><br><span class="line"><span class="comment">        nums[n] = num;</span></span><br><span class="line"><span class="comment">        n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    float var = getvar(nums, n);</span></span><br><span class="line"><span class="comment">    printf(&quot;%f\n&quot;, var);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">float getvar(float arr[], int n)&#123;</span></span><br><span class="line"><span class="comment">    float sum = 0;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">        sum += arr[i];</span></span><br><span class="line"><span class="comment">    float ave = sum/n;</span></span><br><span class="line"><span class="comment">    float p_var;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        p_var += (arr[i]-ave)*(arr[i]-ave);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    float var = p_var/(n-1);</span></span><br><span class="line"><span class="comment">    return var;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目1--不超过平均数的数字个数[数组]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    float num, nums[maxn], sum=0;</span></span><br><span class="line"><span class="comment">    int n = 0;</span></span><br><span class="line"><span class="comment">    // 将输入的数字存入数组nums</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%f&quot;, &amp;num) == 1) &#123;</span></span><br><span class="line"><span class="comment">        sum += num;</span></span><br><span class="line"><span class="comment">        nums[n] = num;</span></span><br><span class="line"><span class="comment">        n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    float ave = sum/n;</span></span><br><span class="line"><span class="comment">    int nx = 0;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">        if(nums[i] &lt;= ave) nx += 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d\n&quot;, nx);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="OJ练习">OJ练习</h5>
<ul>
<li>[ ] UVa 1585</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 85</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=(i<span class="number">-1</span>);j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] UVa 1586</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 85</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> const_s[] = <span class="string">&quot;CHON&quot;</span>;</span><br><span class="line">    <span class="type">float</span> const_num[<span class="number">4</span>] = &#123;<span class="number">12.01</span>, <span class="number">1.008</span>, <span class="number">16.00</span>, <span class="number">14.01</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> s[maxn];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalpha</span>(s[j])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">4</span>; m++)</span><br><span class="line">                <span class="keyword">if</span>(s[j] == const_s[m])&#123;</span><br><span class="line">                    sum += const_num[m];</span><br><span class="line">                    <span class="keyword">if</span>((j+<span class="number">1</span>)&lt; len &amp;&amp; !<span class="built_in">isalpha</span>(s[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                        <span class="keyword">if</span>((j+<span class="number">2</span>)&lt; len &amp;&amp; !<span class="built_in">isalpha</span>(s[j+<span class="number">2</span>])) sum += const_num[m]*((<span class="built_in">int</span>(s[j+<span class="number">1</span>])<span class="number">-48</span>)*<span class="number">10</span>+<span class="built_in">int</span>(s[j+<span class="number">2</span>])<span class="number">-48</span><span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">else</span> sum += const_num[m]*(<span class="built_in">int</span>(s[j+<span class="number">1</span>])<span class="number">-48</span><span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] UVa 1225</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sprintf is the key to solve the problem.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># define maxn 10005</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d&quot;, &amp;n);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">        int nums[10], nx;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        memset(nums, 0, sizeof(nums));</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d&quot;, &amp;nx);</span></span><br><span class="line"><span class="comment">        char strnum[maxn];</span></span><br><span class="line"><span class="comment">        for (int j = 1; j &lt;=nx; j++) &#123;</span></span><br><span class="line"><span class="comment">            sprintf(strnum, &quot;%d&quot;, j);</span></span><br><span class="line"><span class="comment">            for (int k = 0; k &lt; strlen(strnum); k++) &#123;</span></span><br><span class="line"><span class="comment">                for (int l = 0; l &lt;= 9; l++) &#123;</span></span><br><span class="line"><span class="comment">                    if((int(strnum[k])-48) == l) nums[l] += 1;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int m = 0; m &lt; 9; m++) &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;%d &quot;, nums[m]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d\n&quot;, nums[9]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] UVa 455</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curses.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 85</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> times;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;times);</span><br><span class="line">    <span class="keyword">while</span> (times--)&#123;</span><br><span class="line">        <span class="type">char</span> s[maxn];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> T = <span class="number">1</span>; T &lt; length+<span class="number">1</span>; T++) &#123;  <span class="comment">// 这里最大周期可以是它本身的！！</span></span><br><span class="line">            <span class="type">int</span> isans = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> T_nums;</span><br><span class="line">            <span class="keyword">if</span>(length%T == <span class="number">0</span>) &#123;</span><br><span class="line">                T_nums = length/T;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; T_nums; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(s[i] != s[(i+T*j)])&#123;isans = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> isans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(isans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times)<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛入门经典[紫书]习题笔记(第二章)</title>
    <url>/2017/03/13/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%B4%AB%E4%B9%A6-%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>紫书第二章习题代码及笔记。主要是想练习下c++的使用，这里纯粹作为记录，有错误欢迎指出，多加交流。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 水仙花</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>; i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">        a = i / <span class="number">100</span>;</span><br><span class="line">        b = (i % <span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">        c = (i % <span class="number">100</span>)%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">pow</span>(a,<span class="number">3</span>)+<span class="built_in">pow</span>(b,<span class="number">3</span>)+<span class="built_in">pow</span>(c,<span class="number">3</span>)) == i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 韩信点兵</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a, b, c, n=1;</span></span><br><span class="line"><span class="comment">    while(scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c) == 3)&#123;</span></span><br><span class="line"><span class="comment">        int get = 0;</span></span><br><span class="line"><span class="comment">        for(int i=10;i&lt;=100; i++ )&#123;</span></span><br><span class="line"><span class="comment">            if((i%3==a)&amp;&amp;(i%5==b)&amp;&amp;(i%7==c))</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                get = 1;</span></span><br><span class="line"><span class="comment">                printf(&quot;Case %d: %d\n&quot;, n, i);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(get == 0) printf(&quot;Case %d: %s\n&quot;, n, &quot;No answer&quot;);</span></span><br><span class="line"><span class="comment">    n++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒三角形</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    scanf(&quot;%d&quot;, &amp;n);</span></span><br><span class="line"><span class="comment">    int a=n, b=0;  // a控制#的数量， 把控制前后空格的数量</span></span><br><span class="line"><span class="comment">    do&#123;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=b; j++)</span></span><br><span class="line"><span class="comment">            printf(&quot;%s&quot;, &quot; &quot;);</span></span><br><span class="line"><span class="comment">        for(int i=1; i&lt;=2*a-1;i++ )</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;%s&quot;, &quot;#&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=b; j++)</span></span><br><span class="line"><span class="comment">            printf(&quot;%s&quot;, &quot; &quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        a -= 1;</span></span><br><span class="line"><span class="comment">        b++;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;while ((a&gt;=1)&amp;&amp;(a&lt;=20));</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子序列的和</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int n, m, num=0;</span></span><br><span class="line"><span class="comment">    while ((scanf(&quot;%d %d&quot;, &amp;n, &amp;m) == 2)&amp;&amp;m&amp;&amp;n)&#123;</span></span><br><span class="line"><span class="comment">        num += 1;</span></span><br><span class="line"><span class="comment">        float r=0.0;</span></span><br><span class="line"><span class="comment">        for(float i=n; i&lt;=m; i++)&#123;</span></span><br><span class="line"><span class="comment">            r += 1 / (i*i);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        printf(&quot;Case %d: %.5f\n&quot;, num, r);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分数化小数</span></span><br><span class="line"><span class="comment">// 偷懒~</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    int a, b ,c;</span></span><br><span class="line"><span class="comment">    while (scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c))&#123;</span></span><br><span class="line"><span class="comment">        float r;</span></span><br><span class="line"><span class="comment">        r = a/((float) b);</span></span><br><span class="line"><span class="comment">        std::cout&lt;&lt;std::setprecision(c)&lt;&lt;std::fixed&lt;&lt;r&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排列</span></span><br><span class="line"><span class="comment">// 不会...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思考题2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    double i;</span></span><br><span class="line"><span class="comment">//    freopen(&quot;output.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="comment">    for(i=0; i != 10; i += 0.1)&#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%.1f\n&quot;, i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后的思考题，原因在与10.0属于float, 不等于10[int]，所以会一直输出打印的内容，但开始并未出现0.1,0.2,…等的递增的情况，debug发现没有问题，最后发现原因是输出太多内容，将上面的内容掩盖，通过写入文件后再查看，发现打印还是正常的。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>经济周期与股票价格实证研究</title>
    <url>/2018/05/08/%E7%BB%8F%E6%B5%8E%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>金融统计分析作业…下面是流程图[这篇文章就是为了展示流程图orz…个ithub的README不支持…]<br>
代码和数据放在<a href="https://github.com/shenxiangzhuang/Stock">Github</a></p>
<iframe width='100%' height='600px' scrolling='no' src='https://www.goconqr.com/en-US/p/13633950-----------mind_maps?frame=true' style='border: 1px solid #ccc' allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe><a href='https://www.goconqr.com/en/mind-maps'>Mind Map created by 祥壮 沈 with GoConqr</a>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法——简单实现KNN[Python]</title>
    <url>/2017/03/02/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0KNN-Python/</url>
    <content><![CDATA[<p>李航老师《统计学习方法》第三章笔记。</p>
<p>关于KNN[k-Nearest Neighbors algorithm]的基本知识和实验。</p>
<h5 id="KNN的基本知识">KNN的基本知识</h5>
<p>详情参考<a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">WIKI</a>, 这里我们暂时先研究分类方面的应用。<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/1.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/2.png" alt=""></p>
<h5 id="算法的描述：">算法的描述：</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/3.png" alt=""></p>
<blockquote>
<p>(1)在K近邻法中，当训练集、距离度量[如欧式距离]、K值及分类决策规则[如多数表决]确定后，对于任一新的输入实例，它所属的类唯一地确定。</p>
</blockquote>
<blockquote>
<p>(2)k值的减小就意味着整体模型变得复杂，容易发生过拟合。K一般取较小的值，通常采用交叉验证法来选取最优的K值。</p>
</blockquote>
<h5 id="Python实现-2">Python实现</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S1--&gt;随机生成训练集并标注</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟对原始数据标注</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">Px, D, classx</span>):</span><br><span class="line">    <span class="keyword">for</span> px <span class="keyword">in</span> Px:</span><br><span class="line">        D[<span class="built_in">tuple</span>(px)] = classx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 湖区train_data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_train_data</span>():</span><br><span class="line">    <span class="comment"># D 用来储存所有的标注好的实例点</span></span><br><span class="line">    D = &#123;&#125;</span><br><span class="line">    P1 = np.random.random((<span class="number">100</span>, <span class="number">2</span>))</span><br><span class="line">    sign(P1, D, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    P2 = np.random.random((<span class="number">100</span>, <span class="number">2</span>)) - <span class="number">0.7</span></span><br><span class="line">    sign(P2, D, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    P3 = np.random.random((<span class="number">100</span>, <span class="number">2</span>)) + <span class="number">0.7</span></span><br><span class="line">    sign(P3, D, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    plt.plot(P1[:, <span class="number">0</span>], P1[:, <span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>, label=<span class="string">&#x27;class1&#x27;</span>, alpha = <span class="number">0.7</span>)</span><br><span class="line">    plt.plot(P2[:, <span class="number">0</span>], P2[:, <span class="number">1</span>], <span class="string">&#x27;go&#x27;</span>, label=<span class="string">&#x27;class2&#x27;</span>, alpha = <span class="number">0.7</span>)</span><br><span class="line">    plt.plot(P3[:, <span class="number">0</span>], P3[:, <span class="number">1</span>], <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;class3&#x27;</span>, alpha = <span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S2--&gt; 算法实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_dist</span>(<span class="params">px, py</span>):</span><br><span class="line">        <span class="keyword">return</span> np.linalg.norm(np.array(px)-np.array(py))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照与待测点距离的大小排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_rank</span>(<span class="params">D, p0</span>):</span><br><span class="line">    plt.plot(p0[<span class="number">0</span>], p0[<span class="number">1</span>], <span class="string">&#x27;k*&#x27;</span>, markersize=<span class="number">15</span>, label=<span class="string">&quot;Test Point&quot;</span>)</span><br><span class="line">    point_dist = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> px <span class="keyword">in</span> D.keys():</span><br><span class="line">        point_dist[px] = calc_dist(px, p0)</span><br><span class="line">    point_dist = pd.Series(point_dist, index=point_dist.keys())</span><br><span class="line">    point_dist.sort_values(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> point_dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最近的k个数据点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_knn</span>(<span class="params">point_dist, k=<span class="number">1</span></span>):</span><br><span class="line">    knn = point_dist[:k].index</span><br><span class="line">    knn_x = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(knn)]</span><br><span class="line">    knn_y = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(knn)]</span><br><span class="line"></span><br><span class="line">    plt.plot(knn_x, knn_y, <span class="string">&#x27;yo&#x27;</span>, markersize=<span class="number">5</span>, label=<span class="string">&quot;k nearest neighbors&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> knn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到待测点所属的类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class</span>(<span class="params">knn, D</span>):</span><br><span class="line">    class_all = [D[point] <span class="keyword">for</span> point <span class="keyword">in</span> knn]</span><br><span class="line">    <span class="comment"># print(class_all)</span></span><br><span class="line">    c = Counter(class_all)</span><br><span class="line">    <span class="comment"># 多数表决</span></span><br><span class="line">    classx = c.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classx</span><br><span class="line"></span><br><span class="line"><span class="comment"># S3--&gt; 运行测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">p0 = (<span class="params"><span class="number">0</span>, <span class="number">1</span></span>)</span>):</span><br><span class="line">    D = get_train_data()</span><br><span class="line">    point_dist = get_rank(D, p0)</span><br><span class="line">    knn = get_knn(point_dist, <span class="number">3</span>)</span><br><span class="line">    get_class(knn, D)</span><br><span class="line">    class_x = get_class(knn, D)</span><br><span class="line">    <span class="built_in">print</span>(p0, <span class="string">&#x27;所属的类别为：&#x27;</span>, class_x)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.title(<span class="string">&#x27;raw knn&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run((<span class="number">0</span>, <span class="number">0.5</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/4.png" alt=""></p>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/5.png" alt=""></p>
<h5 id="进一步的应用：">进一步的应用：</h5>
<p>注意：这里有三个版本的实现，前两个只有在计算距离上有所不同，但是很慢[第二个快些也还是要10min+], 最后一个速度很快，也就1min左右，参考这里。</p>
<h6 id="1-代码way1–-V1-0-大部分继承自上面的方法，速度极其慢">(1)代码way1–&gt;V1.0[大部分继承自上面的方法，速度极其慢]</h6>
<h6 id="2-代码way2–-V2-0-速度有所提升，但是依旧很慢">(2)代码way2–&gt;V2.0[速度有所提升，但是依旧很慢]</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># get data from file</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">filepath</span>):</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    files = os.listdir(os.getcwd()+filepath)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        classx = file.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.getcwd()+filepath+<span class="string">&#x27;/&#x27;</span>+file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            key = f.read().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            data[key] = classx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># get training data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_training_data</span>():</span><br><span class="line">    training_data = get_data(<span class="string">&quot;/trainingDigits&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> training_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get test data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_test_data</span>():</span><br><span class="line">    test_data = get_data(<span class="string">&quot;/testDigits&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> test_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S2--&gt; 算法实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># way1 ---&gt; 速度极其慢</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def calc_dist(px, py):</span></span><br><span class="line"><span class="string">    px = np.array([float(i) for i in np.array(list(px))])</span></span><br><span class="line"><span class="string">    py = np.array([float(i) for i in np.array(list(py))])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return np.linalg.norm(px-py)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 按照与待测点距离的大小排序</span></span><br><span class="line"><span class="string">def get_rank(training_data, p0):</span></span><br><span class="line"><span class="string">    point_dist = &#123;&#125;</span></span><br><span class="line"><span class="string">    for px in training_data.keys():</span></span><br><span class="line"><span class="string">        point_dist[px] = calc_dist(px, p0)</span></span><br><span class="line"><span class="string">    point_dist = pd.Series(point_dist, index=point_dist.keys())</span></span><br><span class="line"><span class="string">    point_dist.sort_values(inplace=True)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return point_dist</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># way2--&gt; 速度有所提高，但也是很慢</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def calc_dist(training_data, p0):</span></span><br><span class="line"><span class="string">    def str2array(p):</span></span><br><span class="line"><span class="string">        return np.array([float(i) for i in list(p)])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    numSamples = len(training_data)</span></span><br><span class="line"><span class="string">    training_data_pro = [str2array(p) for p in list(training_data.keys())]</span></span><br><span class="line"><span class="string">    p0 = str2array(p0)</span></span><br><span class="line"><span class="string">    # step1:calculate Euclidean distance</span></span><br><span class="line"><span class="string">    # tile(A, reps):Constract an array by repeating A reps times</span></span><br><span class="line"><span class="string">    diff = np.matrix(np.tile(p0, (numSamples, 1))) - np.matrix(training_data_pro)</span></span><br><span class="line"><span class="string">    squreDiff = np.square(diff)</span></span><br><span class="line"><span class="string">    squreDist = np.sum(squreDiff, axis=1)  # sum if performed by row</span></span><br><span class="line"><span class="string">    distance = np.sqrt(squreDist)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    distance = [distance[i, 0] for i in range(len(distance))]</span></span><br><span class="line"><span class="string">    point_dist = pd.Series(distance, index=training_data.keys())</span></span><br><span class="line"><span class="string">    point_dist.sort_values(inplace=True)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return point_dist</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 按照与待测点距离的大小排序</span></span><br><span class="line"><span class="string">def get_rank(training_data, p0):</span></span><br><span class="line"><span class="string">    point_dist = calc_dist(training_data, p0)</span></span><br><span class="line"><span class="string">    return point_dist</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最近的k个数据点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_knn</span>(<span class="params">point_dist, k=<span class="number">1</span></span>):</span><br><span class="line">    knn = point_dist[:k].index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> knn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到待测点所属的类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_class</span>(<span class="params">knn, training_data</span>):</span><br><span class="line">    class_all = [training_data[point] <span class="keyword">for</span> point <span class="keyword">in</span> knn]</span><br><span class="line">    <span class="comment"># print(class_all)</span></span><br><span class="line">    c = Counter(class_all)</span><br><span class="line">    <span class="comment"># 多数表决</span></span><br><span class="line">    classx = c.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># S3--&gt; 运行测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">p0, training_data</span>):</span><br><span class="line">    point_dist = get_rank(training_data, p0)</span><br><span class="line">    knn = get_knn(point_dist, <span class="number">3</span>) class_x = get_class(knn, training_data)</span><br><span class="line">    <span class="built_in">print</span>(p0, <span class="string">&#x27;所属的类别为：&#x27;</span>, class_x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> class_x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    training_data = get_training_data()</span><br><span class="line">    test_data = get_test_data()</span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    <span class="built_in">all</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> test_data.keys():</span><br><span class="line">        <span class="built_in">all</span> += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">all</span>)</span><br><span class="line">        classx = classify(point, training_data)</span><br><span class="line">        <span class="keyword">if</span> test_data[point] == classx:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;all--&gt;&quot;</span>, <span class="built_in">all</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;right--&gt;&quot;</span>, right)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;accuracy--&gt;&#x27;</span>, right/<span class="built_in">all</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="V3-0速度大幅提高">V3.0速度大幅提高</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># classify using KNN</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KNNClassify</span>(<span class="params">newInput, dataSet, labels, k</span>):</span><br><span class="line">    numSamples = dataSet.shape[<span class="number">0</span>]  <span class="comment"># row number</span></span><br><span class="line">    <span class="comment"># step1:calculate Euclidean distance</span></span><br><span class="line">    <span class="comment"># tile(A, reps):Constract an array by repeating A reps times</span></span><br><span class="line">    diff = tile(newInput, (numSamples, <span class="number">1</span>)) - dataSet</span><br><span class="line">    squreDiff = diff ** <span class="number">2</span></span><br><span class="line">    squreDist = <span class="built_in">sum</span>(squreDiff, axis=<span class="number">1</span>)  <span class="comment"># sum if performed by row</span></span><br><span class="line">    distance = squreDist ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2:sort the distance</span></span><br><span class="line">    <span class="comment"># argsort() returns the indices that would sort an array in a ascending order</span></span><br><span class="line">    sortedDistIndices = argsort(distance)</span><br><span class="line"></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># choose the min k distance</span></span><br><span class="line">        voteLabel = labels[sortedDistIndices[i]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step4:count the times labels occur</span></span><br><span class="line">        <span class="comment"># when the key voteLabel is not in dictionary classCount,</span></span><br><span class="line">        <span class="comment"># get() will return 0</span></span><br><span class="line">        classCount[voteLabel] = classCount.get(voteLabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># step5:the max vote class will return</span></span><br><span class="line">    maxCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> classCount.items():</span><br><span class="line">        <span class="keyword">if</span> v &gt; maxCount:</span><br><span class="line">            maxCount = v</span><br><span class="line">            maxIndex = k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxIndex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># convert image to vector</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img2vector</span>(<span class="params">filename</span>):</span><br><span class="line">    rows = <span class="number">32</span></span><br><span class="line">    cols = <span class="number">32</span></span><br><span class="line">    imgVector = zeros((<span class="number">1</span>, rows * cols))</span><br><span class="line">    fileIn = <span class="built_in">open</span>(filename)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        lineStr = fileIn.readline()</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            imgVector[<span class="number">0</span>, row * <span class="number">32</span> + col] = <span class="built_in">int</span>(lineStr[col])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imgVector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataSet</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    <span class="comment">## step 1: Getting training set</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Getting training set...&quot;</span>)</span><br><span class="line">    dataSetDir = <span class="string">&#x27;/home/shen/PycharmProjects/MyPython/统计学习方法/KNN/digits/&#x27;</span></span><br><span class="line">    trainingFileList = os.listdir(dataSetDir + <span class="string">&#x27;trainingDigits&#x27;</span>)  <span class="comment"># load the training set</span></span><br><span class="line">    numSamples = <span class="built_in">len</span>(trainingFileList)</span><br><span class="line"></span><br><span class="line">    train_x = zeros((numSamples, <span class="number">1024</span>))</span><br><span class="line">    train_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">        filename = trainingFileList[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get train_x</span></span><br><span class="line">        train_x[i, :] = img2vector(dataSetDir + <span class="string">&#x27;trainingDigits/%s&#x27;</span> % filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get label from file name such as &quot;1_18.txt&quot;</span></span><br><span class="line">        label = <span class="built_in">int</span>(filename.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])  <span class="comment"># return 1</span></span><br><span class="line">        train_y.append(label)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## step 2: Getting testing set</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Getting testing set...&quot;</span>)</span><br><span class="line">    testingFileList = os.listdir(dataSetDir + <span class="string">&#x27;testDigits&#x27;</span>)  <span class="comment"># load the testing set</span></span><br><span class="line">    numSamples = <span class="built_in">len</span>(testingFileList)</span><br><span class="line">    test_x = zeros((numSamples, <span class="number">1024</span>))</span><br><span class="line">    test_y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numSamples):</span><br><span class="line">        filename = testingFileList[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get train_x</span></span><br><span class="line">        test_x[i, :] = img2vector(dataSetDir + <span class="string">&#x27;testDigits/%s&#x27;</span> % filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get label from file name such as &quot;1_18.txt&quot;</span></span><br><span class="line">        label = <span class="built_in">int</span>(filename.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>])  <span class="comment"># return 1</span></span><br><span class="line">        test_y.append(label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_x, train_y, test_x, test_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test hand writing class</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testHandWritingClass</span>():</span><br><span class="line">    <span class="comment">## step 1: load data</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 1: load data...&quot;</span>)</span><br><span class="line">    train_x, train_y, test_x, test_y = loadDataSet()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## step 2: training...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 2: training...&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## step 3: testing</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 3: testing...&quot;</span>)</span><br><span class="line">    numTestSamples = test_x.shape[<span class="number">0</span>]</span><br><span class="line">    matchCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTestSamples):</span><br><span class="line">        predict = KNNClassify(test_x[i], train_x, train_y, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> predict == test_y[i]:</span><br><span class="line">            matchCount += <span class="number">1</span></span><br><span class="line">    accuracy = <span class="built_in">float</span>(matchCount) / numTestSamples</span><br><span class="line"></span><br><span class="line">    <span class="comment">## step 4: show the result</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;step 4: show the result...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The classify accuracy is: %.2f%%&#x27;</span> % (accuracy * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">testHandWritingClass()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/ch3/6.png" alt=""></p>
<h5 id="要改进学习的地方">要改进学习的地方</h5>
<p>最后参考别人的代码快，感觉主要问题在numpy的矩阵运算上，这个之后要深入研究下，毕竟代码运行速度是极为重要的。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Analysis</tag>
        <tag>ML</tag>
        <tag>Clustering</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>罪在蒙昧</title>
    <url>/2018/04/01/%E7%BD%AA%E5%9C%A8%E8%92%99%E6%98%A7/</url>
    <content><![CDATA[<p>尼采说：凡一切文字，我只爱以血写成的。当然，这篇文字与这句话没有太大关系，但还是希望本文能表达的东西能像鲜血一样醒目。</p>
<p>出于各种原因，个人是不会特地去看现在的新闻的，只是偶尔在别的地方看到。就在这两天，看到两则新闻：研究生自杀和13岁女孩被害。就个人而言，对后者感触更加多一些，一来因为发生在自己身边，二是就在昨天还想着只是失踪而已，不久就能找回来。血淋淋的现实总是让人清醒。</p>
<p>同情和愤懑自然是有的，但是，暂且抛开这些不说，说下在现在的社会，一条生命的消失，到底意味着什么。不管是十几岁还是二十几岁，他们都有自己的家人，朋友，老师，同学等等，和太多人有着千丝万缕的联系。他们会怎样面对这些即成的事实呢？他们又能怎样去面对呢？我不知道答案，但肯定这不是一个可以“放平心态”就可以面对的事情。他们会伤心很久吗？很可能会。对于我们，不很相关的人，会伤心吗？会不平吗？会，当然会。但是，会很久吗，像当事人的家人那样久？或许没有一个人敢说自己会一直将这些血淋淋的事情放在心上，去想，去思考，去了解。一切看起来都是那么自然——相关的人伤心多一点，所谓局外人伤心少一点。但是，这真的自然吗，真的就该如此吗？</p>
<p>现在的社会变得太快了，快的让人丢了很多东西，也在不知不觉中清除了一些“缓存”。今日此时，又有多少人会提起莆田医院，猖獗的传销组织，被逼自杀的程序员，红黄蓝受害的孩子？有人会提吗？当然有。提的人多吗？或许很少。相信每个知道这些事人，到现在都还记得，但已不再那么经常提起。一桩接着一桩的事件，让人一时的阵痛总是被新一轮的阵痛所代替。与此同时，旧事件也相对会被掩盖一些，就这样，一层有加一层。我们是不是应该承认自己已经变得有些麻木，对这个世界黑暗的一面，对身边人的不幸？但是，即使是处身事外，我们就应当如此吗？</p>
<p>一石激起千层浪，浪花飞溅；涟漪过后，归于平静；周而复始，仿若自然。</p>
<p>现如今的我们，即使是知识分子，看似掌握了知识，掌握了科技，殊不知自己的思维却早已为人所掌控。必须承认的一点就是，文化对人的影响是潜移默化的，是根深蒂固的。我们从网络，从新闻，从外界获取的信息，都在潜移默化地改变着我们，每时每刻。最常见的信息输出点，也就是我们的信息输入来源就是影视节目。《铁拳》的中女权的缺失，我们有意识到吗？我们没有意识到并去反对，说明我们本来就是默认如此。而电影又更深层次地加深了这种认识，而我们浑然不知。《极限挑战》，我只看过一个镜头，演员在开车打电话。我们不知道开车的时候不能打电话吗？当然知道，很少有人不知道，但是有多少人在观看的时候注意到这一点呢，或是说对提出反对已经呢？没有看到新闻报道这件事，姑且认为没有人去反对吧。这种信息的无条件输入，难道不会使我们的安全意识变得淡薄吗？而我们有注意到这一点吗？这样的例子还有太多太多，我们都在被这个时代爆炸的信息悄然改变。但是，我们就应该这样被改变吗？</p>
<p>古之治国，有愚民政策。而今天，我们同样活在一片蒙昧之中。</p>
<p>我们所听所见，所知所感，我们自认为熟悉的一切，看似自然而然的一切，真的就应该是现在的样子吗？或是说，它们真正的样子是什么呢？我不得而知。但知道有些事情是不能被忘记的，无论时空怎么变换都不能，它们必须被人铭记，让人反思，直到永远。我们必须有清醒的认识，对我们生活中的一切。至少，在我们现在生活的这个社会，有太多东西需要去深刻地理解，这个过程可以很久，但至少在它因触犯某些人的利益之后被无形地归为现实虚无主义和历史虚无主义之前。</p>
<p>统计意义上说，这些不快事件的接连发生说明其根本不是小概率事件。或许有人会说，人口基数那么大，发生这么多事件是在正常范围？但是，一个现代的社会，一个合理的社会，这些事发生的概率更应该无限趋近于零，不是吗？说是偶然的，就更加说不过去了——“偶然不过是化了妆的、戴了面具的必然”。所以，钱学森之问的答案真的就那么难以寻找吗？根本在于哪里呢？窃以为，在于改变。而为何不变呢？无外乎“私之，畏之，欲有求于之”罢了。</p>
<p>其实，所有的一切，答案都写在历史之中——虎兕出于柙，龟玉毁于椟中，是谁之过与？何为虎兕何为柙？何为龟玉何为椟？君当自断。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>考研杂记</title>
    <url>/2019/03/28/%E8%80%83%E7%A0%94%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本来这应该是一篇经验贴…后来仔细想了下真要写的话可能不具有一般性，所以作罢。这里只是简单记录下考研的历程。</p>
</blockquote>
<p>考研对我来说是影响很大的选择，这点毋庸置疑。不过坦白说，这只是整个一大段无可奈何中的一小段无可奈何。于我而言，或许可以说过其无关奋斗，只是为后面的大冒险攒些盘缠罢了。对这段灰色的日子，我谈不上怀念，但是这段日子里有很多一直在帮助我的人，我真心感谢他们。</p>
<p>上面说不具有一般性是有一定根据的…首先我也算是考本专业（经济统计-&gt;应用统计），之前加上教科书和自己看的书，专业课基础还是可以的（所以我若写东西，不可能触及从基础开始学习的部分）。数学和喜欢的统计学专业课程除了教材都至少看过一本国外的教材，当然都是看着玩，不过还是能增长些见识。看的过程中顺便锻炼了英语阅读能力，然后在复习英语时几乎就是做做真题就完了…也没有进行那些长难句理解和翻译阅读文章的步骤（不过我看帖子说这些好像挺重要的）。我也跟着背了一些作文，不过我背不下来，最多熟读，然后考试也是直接写的。政治就算了，我66分在复试中垫底。不过明白一点就是政治真的是靠选择题拉分的。时间上。我是从七月中旬才正式开始准备（算是比较晚了），所以后面准备的很仓促，也比较乱（我从头到尾也没做过什么系统的计划Orz）。</p>
<blockquote>
<p>所以我觉着，还是不要误导别人的好:-)<br>
不过有一点就是，一定根据自己的实际情况出发去做决定。具体问题，具体…</p>
</blockquote>
<p>就最后成绩来说，我觉着就英语还挺满意，数学和专业课比我的预期差一些。数学是因为我从选择题第二（或三）题开始就慌了，卡了一下，发现别人都开始翻页了Orz…之后一路连滚带爬，做完还剩半个多小时，然后做空下来的题目，也没做出来。专业课谜之自信（觉着可以140+），至今不知道跪在哪里…估计是选择题错的多些，大题挂了半道题。</p>
<p>后面初试完了在岛上过了个悠闲的假期，顺便有时间写了几天代码，查了查调剂。</p>
<p>最后出成绩复试，又有幸结识了一起考中大的同学。我们一行人围着一张大床坐一圈讨论概率论，数理统计，多元统计，泊松回归…难忘！</p>
<p>整个考研过程对我来说是不太好受的（我想对每个人都是）。毫无疑问整个大背景是灰色的，所以请珍惜少有的彩色。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>背景建模</title>
    <url>/2017/05/19/%E8%83%8C%E6%99%AF%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h4 id="Overview-64">Overview</h4>
<p>背景建模在视频监控等动态图像的检测上有很重要的位置.这篇文章将会逐渐学习一系列的背景建模方法.</p>
<h4 id="Code-53">Code</h4>
<h5 id="简单背景差分">简单背景差分</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat back1, back2;</span><br><span class="line">    back1 = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/back1.jpg&quot;</span>);</span><br><span class="line">    back2 = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/back2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Mat Original_img = back1.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cvtColor</span>(back1, back1, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="built_in">cvtColor</span>(back2, back2, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">resize</span>(back1, back1, <span class="built_in">Size</span>(), <span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="built_in">resize</span>(back2, back2, <span class="built_in">Size</span>(), <span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;back1&quot;</span>, back1);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;back2&quot;</span>, back2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接相减</span></span><br><span class="line">    Mat result = back2 - back1;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:<br>
<img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051901.png" alt=""></p>
<p>可以看到，直接相减再thresh一下，效果还是比较好的。但是在实际上，这种方法要求比较高，它要求背景图像是静止的，任何微小的背景变动都会对检测造成影响：</p>
<blockquote>
<p>In this approach, we assume that the background is static. If some parts of our background start moving, then those parts will start getting detected as new objects. So, even if the movements are minor, say a waving flag, it will cause problems in our detection algorithm. This approach is also sensitive to changes in illumination, and it cannot handle any camera movement. Needless to say, it’s a delicate approach! We need something that can handle all these things in the real world.</p>
</blockquote>
<h5 id="帧差值法">帧差值法</h5>
<p>帧差值法是利用连续帧之间的差异来获取物体的移动信息。</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052101.png" alt=""></p>
<p>像这样, 重叠的部分是不会被检测到，只有边缘部分会被检测到，但是很明显，这要求物体在转化为灰度图时灰度级是近似均匀的，不然…即使重叠也还是会有差值，不能对冲掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">frameDiff</span><span class="params">(Mat prevFrame, Mat curFrame, Mat nextFrame)</span></span>&#123;</span><br><span class="line">    Mat diffFrames1, diffFrames2, output;</span><br><span class="line">    <span class="comment">// 计算当前帧和下一帧的绝对差值</span></span><br><span class="line">    <span class="built_in">absdiff</span>(nextFrame, curFrame, diffFrames1);</span><br><span class="line">    <span class="comment">// 计算当前帧和前一帧的绝对差值</span></span><br><span class="line">    <span class="built_in">absdiff</span>(curFrame, prevFrame, diffFrames2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对以上两个不同的图像进行按位“与”操作</span></span><br><span class="line">    <span class="built_in">bitwise_and</span>(diffFrames1, diffFrames2, output);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了使得边缘更加明显，进行dilate操作</span></span><br><span class="line">    <span class="built_in">dilate</span>(output, output, <span class="built_in">Mat</span>(), <span class="built_in">Point</span>(<span class="number">-1</span>,<span class="number">-1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从摄像头获取帧</span></span><br><span class="line"><span class="function">Mat <span class="title">getFrame</span><span class="params">(VideoCapture cap, <span class="type">float</span> scalingFactor)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 浮动比例因子设为0.5</span></span><br><span class="line">    Mat frame, output;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获当前帧</span></span><br><span class="line">    cap &gt;&gt; frame;</span><br><span class="line">    <span class="comment">// 调整大小</span></span><br><span class="line">    <span class="built_in">resize</span>(frame, frame, <span class="built_in">Size</span>(), scalingFactor, scalingFactor, INTER_AREA);</span><br><span class="line">    <span class="comment">// 转换为灰度</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(frame, output, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat frame, prevFrame, curFrame, nextFrame;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建捕获对象t</span></span><br><span class="line">    <span class="comment">// 0-&gt;输入变量表示数据源来自摄像头</span></span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果摄像头无法打开，停止执行</span></span><br><span class="line">    <span class="keyword">if</span>(!cap.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建GUI窗口</span></span><br><span class="line"><span class="comment">//    namedWindow(&quot;Frame&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整摄像头输入帧大小的缩放因子</span></span><br><span class="line">    <span class="type">float</span> scalingFactor = <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line">    prevFrame = <span class="built_in">getFrame</span>(cap, scalingFactor);</span><br><span class="line">    curFrame = <span class="built_in">getFrame</span>(cap, scalingFactor);</span><br><span class="line">    nextFrame = <span class="built_in">getFrame</span>(cap, scalingFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环知道用户按下Esc键</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 显示对象移动</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Object Movement&quot;</span>, <span class="built_in">frameDiff</span>(prevFrame, curFrame, nextFrame));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新变量并抓取下一帧</span></span><br><span class="line">        prevFrame = curFrame;</span><br><span class="line">        curFrame = nextFrame;</span><br><span class="line">        nextFrame = <span class="built_in">getFrame</span>(cap, scalingFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取键盘输入，并检测用户是否按下Esc键</span></span><br><span class="line">        <span class="comment">// 27-&gt;Esc 按钮的ASCII码</span></span><br><span class="line">        ch = <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="number">27</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在移动时摄像头情况：</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/1705/Object%20Movement_052103.png" alt=""></p>
<h5 id="混合高斯法">混合高斯法</h5>
<p>在<em>OpenCV By Example</em>上的MOG没法使用，查了查<code>cv::bgsegm::BackgroundSubtractorMOG</code>也无法使用…查看文档好像又是<code>cv::cuda::BackgroundSubtractorMOG</code>，仍然没办法使用，可能是编译的时候没有添加支持的问题。于是就看了看官方给的demo，用的MOG2.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv/cv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global variables</span></span><br><span class="line">Mat frame; <span class="comment">//current frame</span></span><br><span class="line">Mat fgMaskMOG2; <span class="comment">//fg mask fg mask generated by MOG2 method</span></span><br><span class="line">Ptr&lt;BackgroundSubtractor&gt; pMOG2; <span class="comment">//MOG2 Background subtractor</span></span><br><span class="line"><span class="type">char</span> keyboard; <span class="comment">//input from keyboard</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processVideo</span><span class="params">(<span class="type">char</span>* videoFilename)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processImages</span><span class="params">(<span class="type">char</span>* firstFrameFilename)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout</span><br><span class="line">            &lt;&lt; <span class="string">&quot;--------------------------------------------------------------------------&quot;</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;This program shows how to use background subtraction methods provided by &quot;</span>  &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot; OpenCV. You can process both videos (-vid) and images (-img).&quot;</span>             &lt;&lt; endl</span><br><span class="line">            &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Usage:&quot;</span>                                                                     &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;./bg_sub &#123;-vid &lt;video filename&gt;|-img &lt;image filename&gt;&#125;&quot;</span>                     &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;for example: ./bg_sub -vid video.avi&quot;</span>                                       &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;or: ./bg_sub -img /data/images/1.png&quot;</span>                                       &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;--------------------------------------------------------------------------&quot;</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//print help information</span></span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line">    <span class="comment">//check for the input parameter correctness</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;Incorret input list&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//create GUI windows</span></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Frame&quot;</span>);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;FG Mask MOG 2&quot;</span>);</span><br><span class="line">    <span class="comment">//create Background Subtractor objects</span></span><br><span class="line">    pMOG2 = <span class="built_in">createBackgroundSubtractorMOG2</span>(); <span class="comment">//MOG2 approach</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-vid&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//input data coming from a video</span></span><br><span class="line">        <span class="built_in">processVideo</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-img&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//input data coming from a sequence of images</span></span><br><span class="line">        <span class="built_in">processImages</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//error in reading input parameters</span></span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;Please, check the input parameters.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;Exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//destroy GUI windows</span></span><br><span class="line">    <span class="built_in">destroyAllWindows</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processVideo</span><span class="params">(<span class="type">char</span>* videoFilename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//create the capture object</span></span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(videoFilename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!capture.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">        <span class="comment">//error in opening the video input</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to open video file: &quot;</span> &lt;&lt; videoFilename &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//read input data. ESC or &#x27;q&#x27; for quitting</span></span><br><span class="line">    keyboard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( keyboard != <span class="string">&#x27;q&#x27;</span> &amp;&amp; keyboard != <span class="number">27</span> )&#123;</span><br><span class="line">        <span class="comment">//read the current frame</span></span><br><span class="line">        <span class="keyword">if</span>(!capture.<span class="built_in">read</span>(frame)) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Unable to read next frame.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//update the background model</span></span><br><span class="line">        pMOG2-&gt;<span class="built_in">apply</span>(frame, fgMaskMOG2);</span><br><span class="line">        <span class="built_in">erode</span>(fgMaskMOG2, fgMaskMOG2, <span class="built_in">Mat</span>(), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//get the frame number and write it on the current frame</span></span><br><span class="line">        stringstream ss;</span><br><span class="line">        <span class="built_in">rectangle</span>(frame, cv::<span class="built_in">Point</span>(<span class="number">10</span>, <span class="number">2</span>), cv::<span class="built_in">Point</span>(<span class="number">100</span>,<span class="number">20</span>),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">        ss &lt;&lt; capture.<span class="built_in">get</span>(CAP_PROP_POS_FRAMES);</span><br><span class="line">        string frameNumberString = ss.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">putText</span>(frame, frameNumberString.<span class="built_in">c_str</span>(), cv::<span class="built_in">Point</span>(<span class="number">15</span>, <span class="number">15</span>),</span><br><span class="line">                FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span> , cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//show the current frame and the fg masks</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Frame&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;FG Mask MOG 2&quot;</span>, fgMaskMOG2);</span><br><span class="line">        <span class="comment">//get the input from the keyboard</span></span><br><span class="line">        keyboard = (<span class="type">char</span>)<span class="built_in">waitKey</span>( <span class="number">30</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete capture object</span></span><br><span class="line">    capture.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processImages</span><span class="params">(<span class="type">char</span>* fistFrameFilename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//read the first file of the sequence</span></span><br><span class="line">    frame = <span class="built_in">imread</span>(fistFrameFilename);</span><br><span class="line">    <span class="keyword">if</span>(frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//error in opening the first image</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to open first image frame: &quot;</span> &lt;&lt; fistFrameFilename &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//current image filename</span></span><br><span class="line">    <span class="function">string <span class="title">fn</span><span class="params">(fistFrameFilename)</span></span>;</span><br><span class="line">    <span class="comment">//read input data. ESC or &#x27;q&#x27; for quitting</span></span><br><span class="line">    keyboard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( keyboard != <span class="string">&#x27;q&#x27;</span> &amp;&amp; keyboard != <span class="number">27</span> )&#123;</span><br><span class="line">        <span class="comment">//update the background model</span></span><br><span class="line">        pMOG2-&gt;<span class="built_in">apply</span>(frame, fgMaskMOG2);</span><br><span class="line">        <span class="comment">//get the frame number and write it on the current frame</span></span><br><span class="line">        <span class="type">size_t</span> index = fn.<span class="built_in">find_last_of</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == string::npos) &#123;</span><br><span class="line">            index = fn.<span class="built_in">find_last_of</span>(<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> index2 = fn.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        string prefix = fn.<span class="built_in">substr</span>(<span class="number">0</span>,index+<span class="number">1</span>);</span><br><span class="line">        string suffix = fn.<span class="built_in">substr</span>(index2);</span><br><span class="line">        string frameNumberString = fn.<span class="built_in">substr</span>(index+<span class="number">1</span>, index2-index<span class="number">-1</span>);</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(frameNumberString)</span></span>;</span><br><span class="line">        <span class="type">int</span> frameNumber = <span class="number">0</span>;</span><br><span class="line">        iss &gt;&gt; frameNumber;</span><br><span class="line">        <span class="built_in">rectangle</span>(frame, cv::<span class="built_in">Point</span>(<span class="number">10</span>, <span class="number">2</span>), cv::<span class="built_in">Point</span>(<span class="number">100</span>,<span class="number">20</span>),</span><br><span class="line">                  cv::<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">putText</span>(frame, frameNumberString.<span class="built_in">c_str</span>(), cv::<span class="built_in">Point</span>(<span class="number">15</span>, <span class="number">15</span>),</span><br><span class="line">                FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span> , cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//show the current frame and the fg masks</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Frame&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;FG Mask MOG 2&quot;</span>, fgMaskMOG2);</span><br><span class="line">        <span class="comment">//get the input from the keyboard</span></span><br><span class="line">        keyboard = (<span class="type">char</span>)<span class="built_in">waitKey</span>( <span class="number">30</span> );</span><br><span class="line">        <span class="comment">//search for the next image in the sequence</span></span><br><span class="line">        ostringstream oss;</span><br><span class="line">        oss &lt;&lt; (frameNumber + <span class="number">1</span>);</span><br><span class="line">        string nextFrameNumberString = oss.<span class="built_in">str</span>();</span><br><span class="line">        string nextFrameFilename = prefix + nextFrameNumberString + suffix;</span><br><span class="line">        <span class="comment">//read the next frame</span></span><br><span class="line">        frame = <span class="built_in">imread</span>(nextFrameFilename);</span><br><span class="line">        <span class="keyword">if</span>(frame.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//error in opening the next image in the sequence</span></span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Unable to open image frame: &quot;</span> &lt;&lt; nextFrameFilename &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//update the path of the current frame</span></span><br><span class="line">        fn.<span class="built_in">assign</span>(nextFrameFilename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>终端运行：</p>
<blockquote>
<p>cmake .<br>
make<br>
./Clions -vid /home/shensir/Documents/MyPrograming/Cpp/Clions/data/BGC.avi</p>
</blockquote>
<p>输出：<br>
<img src="http://blog-1252464519.costj.myqcloud.com/1705/Selection_052102.png" alt=""></p>
<p>上面的demo也可以对一系列的连续的图片进行检测，<a href="http://xn--1-br6ax5p9d8vf4juplnif70jq3b17s137and7d8qxbhwe.xxx">只需要将所有图片按顺序命名为1.xxx</a>， 2.xxx这样，然后运行的时候只提供第一帧的即1.xxx并使用-img即可。关于其中的字符串的操作，我们还原如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">fn</span><span class="params">(<span class="string">&quot;/data/1.jpg&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> index = fn.<span class="built_in">find_last_of</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Index: &quot;</span>&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">    string prefix = fn.<span class="built_in">substr</span>(<span class="number">0</span>, index+<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Prefix: &quot;</span>&lt;&lt;prefix&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> index2 = fn.<span class="built_in">find_last_of</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Index2: &quot;</span>&lt;&lt;index2&lt;&lt;endl;</span><br><span class="line">    string suffix = fn.<span class="built_in">substr</span>(index2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;suffix: &quot;</span>&lt;&lt;suffix&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    string frameNumberString = fn.<span class="built_in">substr</span>(index+<span class="number">1</span>, index2-index<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;frameNUmberString: &quot;</span>&lt;&lt;frameNumberString&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(frameNumberString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> frameNumber = <span class="number">0</span>;</span><br><span class="line">    iss &gt;&gt; frameNumber;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;frameNumber: &quot;</span>&lt;&lt;frameNumber&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss &lt;&lt; (frameNumber + <span class="number">1</span>);</span><br><span class="line">    string nextFrameNumberString = oss.<span class="built_in">str</span>();</span><br><span class="line">    string nextFrameFilename = prefix + nextFrameNumberString + suffix;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;nextFrameFilename: &quot;</span>&lt;&lt;nextFrameFilename&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Index: 5<br>
Prefix: /data/<br>
Index2: 7<br>
suffix: .jpg<br>
frameNUmberString: 1<br>
frameNumber: 1<br>
nextFrameFilename: /data/2.jpg</p>
</blockquote>
<p>开始的时候对<code>istringstream</code>的用法不太懂，查到下面一个例子，虽不懂原理，但是它的用途还是可以了解到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>      <span class="comment">// std::istringstream</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::string stringvalues = <span class="string">&quot;125 320 512 750 333&quot;</span>;</span><br><span class="line">  <span class="function">std::istringstream <span class="title">iss</span> <span class="params">(stringvalues)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;<span class="number">5</span>; n++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    iss &gt;&gt; val;</span><br><span class="line">    std::cout &lt;&lt; val*<span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>250<br>
640<br>
1024<br>
1500<br>
666</p>
</blockquote>
<h4 id="Refrence-4">Refrence</h4>
<p><em>OpenCV By Example</em></p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>自动光学检测，目标分割和检测</title>
    <url>/2017/05/18/%E8%87%AA%E5%8A%A8%E5%85%89%E5%AD%A6%E6%A3%80%E6%B5%8B%EF%BC%8C%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2%E5%92%8C%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h4 id="Overview-65">Overview</h4>
<p>在复习CookBook的闲暇，看了看<em>OpenCV By Example</em>, 里面的示例很不错，这里做下记录。此处实现了目标的背景去除，目标的分割和检测，以工厂螺母为例。就是下面的图啦。</p>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170518/light.png" alt=""><br>
<img src="http://blog-1252464519.costj.myqcloud.com/170518/test.png" alt=""></p>
<h4 id="Code-54">Code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by shensir on 17-5-17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光纹去除</span></span><br><span class="line"><span class="function">Mat <span class="title">removeLight</span><span class="params">(Mat img, Mat pattern, <span class="type">int</span> method)</span></span>&#123;</span><br><span class="line">    Mat aux;</span><br><span class="line">    <span class="comment">// 如果方法是归一化</span></span><br><span class="line">    <span class="keyword">if</span>(method==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 相除时需要将图像改为32位浮点型</span></span><br><span class="line">        Mat img32, pattern32;</span><br><span class="line">        img.<span class="built_in">convertTo</span>(img32, CV_32F);</span><br><span class="line">        pattern.<span class="built_in">convertTo</span>(pattern32, CV_32F);</span><br><span class="line">        <span class="comment">// 图像相除模式</span></span><br><span class="line">        aux = <span class="number">255</span>*(<span class="number">1</span>-(img32/pattern32));</span><br><span class="line">        <span class="comment">// 换回8bit</span></span><br><span class="line">        aux.<span class="built_in">convertTo</span>(aux, CV_8U);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        aux = pattern - img;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 估计背景图像，大尺寸核矩阵模糊</span></span><br><span class="line"><span class="function">Mat <span class="title">calculateLightPattern</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    Mat pattern;</span><br><span class="line">    <span class="built_in">blur</span>(img, pattern, <span class="built_in">Size</span>(img.cols/<span class="number">3</span>, img.rows/<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> pattern;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进行形态学操作[在背景色是核函数模糊得到的时候，很有必要]，再二值化</span></span><br><span class="line"><span class="function">Mat <span class="title">getBinary</span><span class="params">(Mat img_no_light, <span class="type">int</span> method_light)</span></span>&#123;</span><br><span class="line">    Mat img_thr;</span><br><span class="line">    <span class="keyword">if</span>(method_light!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">threshold</span>(img_no_light, img_thr, <span class="number">30</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">threshold</span>(img_no_light, img_thr, <span class="number">140</span>, <span class="number">255</span>, THRESH_BINARY_INV);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行形态学操作去除边缘不规则噪点</span></span><br><span class="line">    cv::Mat closed;</span><br><span class="line">    <span class="function">cv::Mat <span class="title">element5</span><span class="params">(<span class="number">5</span> ,<span class="number">5</span>, CV_8U, cv::Scalar(<span class="number">1</span>))</span></span>;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(img_thr, closed,   <span class="comment">// input and output</span></span><br><span class="line">                     cv::MORPH_CLOSE,  <span class="comment">// operator code</span></span><br><span class="line">                     element5);  <span class="comment">// structuring element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opening</span></span><br><span class="line">    cv::Mat opening;</span><br><span class="line">    cv::<span class="built_in">morphologyEx</span>(closed, opening,   <span class="comment">// input and output</span></span><br><span class="line">                     cv::MORPH_OPEN,  <span class="comment">// operator code</span></span><br><span class="line">                     element5);  <span class="comment">// structuring element</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img_thr_closed-opening&quot;</span>, opening);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> opening;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Scalar <span class="title">randomColor</span><span class="params">( RNG&amp; rng )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> icolor = (<span class="type">unsigned</span>) rng;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Scalar</span>( icolor&amp;<span class="number">255</span>, (icolor&gt;&gt;<span class="number">8</span>)&amp;<span class="number">255</span>, (icolor&gt;&gt;<span class="number">16</span>)&amp;<span class="number">255</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连通区域算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectedComponents</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用连通区域分离符合要求部分图像Mat标签</span></span><br><span class="line">    Mat labels;</span><br><span class="line">    <span class="type">int</span> num_objects = <span class="built_in">connectedComponents</span>(img, labels);</span><br><span class="line">    <span class="comment">// 检查检测到的目标数目</span></span><br><span class="line">    <span class="keyword">if</span>(num_objects&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No objects detected&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of objects detected: &quot;</span>&lt;&lt; num_objects<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建彩色目标的输出图像</span></span><br><span class="line">    Mat output=Mat::<span class="built_in">zeros</span>(img.rows, img.cols, CV_8UC3);</span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num_objects; i++)&#123;</span><br><span class="line">        Mat mask = labels==i;</span><br><span class="line">        output.<span class="built_in">setTo</span>(<span class="built_in">randomColor</span>(rng), mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连通区域算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectedComponentsStats</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连通区域统计信息</span></span><br><span class="line">    Mat labels, stats, centroids;</span><br><span class="line">    <span class="type">int</span> num_objects = <span class="built_in">connectedComponentsWithStats</span>(img, labels, stats, centroids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测物体数目判别</span></span><br><span class="line">    <span class="keyword">if</span>(num_objects&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No objects detedcted&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of objects detected: &quot;</span>&lt;&lt;num_objects<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建彩色对象的输出图像并显示区域</span></span><br><span class="line">    Mat output = Mat::<span class="built_in">zeros</span>(img.rows, img.cols, CV_8UC3);</span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num_objects; i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Object &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; with pos: &quot;</span>&lt;&lt;centroids.<span class="built_in">at</span>&lt;Point2d&gt;(i)</span><br><span class="line">                                         &lt;&lt;<span class="string">&quot; with area &quot;</span>&lt;&lt;stats.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i, CC_STAT_AREA)&lt;&lt;endl;</span><br><span class="line">        Mat mask = labels==i;</span><br><span class="line">        output.<span class="built_in">setTo</span>(<span class="built_in">randomColor</span>(rng), mask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用区域绘制文本</span></span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss&lt;&lt;<span class="string">&quot;area: &quot;</span>&lt;&lt;stats.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i, CC_STAT_AREA);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">putText</span>(output, ss.<span class="built_in">str</span>(), centroids.<span class="built_in">at</span>&lt;Point2d&gt;(i), FONT_HERSHEY_SIMPLEX, <span class="number">0.4</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Result&quot;</span>, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  边缘检测算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindContoursBasic</span><span class="params">(Mat img)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">    <span class="built_in">findContours</span>(img, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">    Mat output = Mat::<span class="built_in">zeros</span>(img.rows, img.cols, CV_8UC3);</span><br><span class="line">    <span class="comment">// 检查检测到的对象的数目</span></span><br><span class="line">    <span class="keyword">if</span>(contours.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No objects detected&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Number of objects detected: &quot;</span>&lt;&lt;contours.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;contours.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">drawContours</span>(output, contours, i, <span class="built_in">randomColor</span>(rng));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Contours&quot;</span>, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/industry.pgm&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">    Mat pattern = <span class="built_in">imread</span>(<span class="string">&quot;/home/shensir/Documents/MyPrograming/Cpp/Clions/data/light.pgm&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Back&quot;</span>, pattern);</span><br><span class="line"><span class="comment">//    Mat pattern = calculateLightPattern(img);</span></span><br><span class="line">    Mat img_no_light = <span class="built_in">removeLight</span>(img, pattern, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;removelight--minus&quot;</span>, img_no_light);</span><br><span class="line"></span><br><span class="line">    Mat img_thr = <span class="built_in">getBinary</span>(img_no_light,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    ConnectedComponents(img_thr);</span></span><br><span class="line">    <span class="built_in">ConnectedComponentsStats</span>(img_thr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FindContoursBasic</span>(img_thr);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Number of objects detected: 4<br>
Object 1 with pos: [160.203, 143.822] with area 2315<br>
Object 2 with pos: [263.535, 131.804] with area 1820<br>
Object 3 with pos: [52.7045, 143.926] with area 1171<br>
Object 4 with pos: [68.233, 202.819] with area 1618<br>
Number of objects detected: 4</p>
</blockquote>
<p><img src="http://blog-1252464519.costj.myqcloud.com/170518/Selection_051801.png" alt=""></p>
<h4 id="待改进的地方">待改进的地方</h4>
<p>在没有背景色图的时候，我们直接通过大尺寸核矩阵模糊化得到的效果很差，得到的objects大于50左右，后面自己加上了形态学的操作，降到了5个，但是还是多了一个。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣影评爬取</title>
    <url>/2017/03/02/%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>以爬取豆瓣影评为例，抽象简单的爬取流程。</p>
<p>环境与工具：</p>
<blockquote>
<p>Ubuntu16.04 64bit<br>
Pycharm<br>
Anaconda3<br>
bs4</p>
</blockquote>
<h5 id="流程图">流程图</h5>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/Spider/douban%20/1.png" alt=""></p>
<h5 id="源码">源码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个评论列表页面的网页数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">url</span>):</span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36&quot;</span>&#125;</span><br><span class="line">    data = requests.get(url, headers=headers).text</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取页面中影评标题及链接</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_data_bs</span>(<span class="params">data</span>):</span><br><span class="line">    title_data_d = &#123;&#125;</span><br><span class="line">    bsObj = BeautifulSoup(data, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    review_lists = bsObj.findAll(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;typeof&#x27;</span>:<span class="string">&quot;v:Review&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> review_lists:</span><br><span class="line">        title_data = item.find(<span class="string">&#x27;h3&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;title&#x27;</span>&#125;)</span><br><span class="line">        <span class="comment"># 这里多次使用replace可用正则表达式代替，这里省略，详情参考站内正则表达式python版的总结</span></span><br><span class="line">        title = title_data.get_text().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        title_href = title_data.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        title_data_d[title] = title_href</span><br><span class="line">    <span class="keyword">return</span> title_data_d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据评论标题链接抓取评论内容</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_comment_data</span>(<span class="params">comment_url</span>):</span><br><span class="line">    comment_data = get_data(comment_url)</span><br><span class="line">    bsObj = BeautifulSoup(comment_data, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(bsObj)</span></span><br><span class="line">    <span class="comment"># author data</span></span><br><span class="line">    p_name = bsObj.find(<span class="string">&#x27;header&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;main-hd&#x27;</span>&#125;).find(<span class="string">&#x27;a&#x27;</span>).find(<span class="string">&#x27;span&#x27;</span>).get_text()</span><br><span class="line">    p_url = bsObj.find(<span class="string">&#x27;header&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;main-hd&#x27;</span>&#125;).find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="comment"># comment data</span></span><br><span class="line">    c_date = bsObj.find(<span class="string">&#x27;span&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;main-meta&#x27;</span>&#125;).get_text()</span><br><span class="line">    <span class="comment"># c_rank提取中发现查看源码发现与检查元素不符合</span></span><br><span class="line">    <span class="comment"># 有些用户未评分</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        c_rank = bsObj.find(<span class="string">&#x27;span&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&quot;main-title-hide&quot;</span>&#125;).get_text()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        c_rank = <span class="literal">None</span></span><br><span class="line">    c_comment = bsObj.find(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;property&#x27;</span>: <span class="string">&#x27;v:description&#x27;</span>&#125;).get_text()</span><br><span class="line">    <span class="comment"># 有用，无用</span></span><br><span class="line">    useful = bsObj.find(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;main-panel-useful&#x27;</span>&#125;).find_all(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    y_use = useful[<span class="number">0</span>].get_text().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">5</span>]</span><br><span class="line">    n_use = useful[<span class="number">1</span>].get_text().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">5</span>]</span><br><span class="line">    comment_data = [p_name, p_url, c_date, c_comment, c_rank, y_use, n_use]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> comment_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_table</span>():</span><br><span class="line">    db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;密码不给看&quot;</span>, <span class="string">&quot;USpiderData&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;DROP TABLE IF EXISTS DouBan&quot;</span>)</span><br><span class="line">    <span class="comment"># p_name, p_url, c_date, c_data, c_rank, y_use, n_use</span></span><br><span class="line">    cursor.execute(<span class="string">&quot;CREATE TABLE DouBan(p_name VARCHAR(20), p_url VARCHAR(100), &quot;</span></span><br><span class="line">                   <span class="string">&quot;c_date VARCHAR (20), c_comment VARCHAR (20000), c_rank VARCHAR (5), &quot;</span></span><br><span class="line">                   <span class="string">&quot;y_use VARCHAR (10), n_use VARCHAR (10));&quot;</span>)  <span class="comment"># 创建表</span></span><br><span class="line">    db.commit()</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_mysql</span>(<span class="params">cursor, db, commemt_data</span>):</span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    sql = <span class="string">&#x27;INSERT INTO DouBan(p_name, p_url, c_date, c_comment, c_rank, y_use, n_use)VALUES(%s,%s,%s,%s,%s,%s,%s)&#x27;</span></span><br><span class="line">    <span class="comment"># cursor.execute(sql, (commemt_data[0], commemt_data[1], commemt_data[2], commemt_data[3], commemt_data[4], commemt_data[5], commemt_data[6]))</span></span><br><span class="line">    cursor.execute(sql, [commemt_data[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)])</span><br><span class="line">    <span class="comment"># 提交事务</span></span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="built_in">print</span>(commemt_data[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># except:</span></span><br><span class="line">    <span class="comment">#     print(&#x27;Save fail...&#x27;)</span></span><br><span class="line">    <span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_spider</span>(<span class="params">list_url</span>):</span><br><span class="line">    db = pymysql.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;密码不给看&quot;</span>, <span class="string">&quot;USpiderData&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    page_data = get_data(list_url)</span><br><span class="line">    <span class="comment"># https: // movie.douban.com/subject/26616436/reviews</span></span><br><span class="line">    titles_data = parse_data_bs(page_data)</span><br><span class="line">    <span class="comment"># print(titles_data)</span></span><br><span class="line">    <span class="keyword">for</span> comment_title, comment_url <span class="keyword">in</span> titles_data.items():</span><br><span class="line">        comment_data = get_comment_data(comment_url)</span><br><span class="line">        <span class="comment"># print(comment_data)</span></span><br><span class="line">        save_to_mysql(cursor, db, comment_data)</span><br><span class="line"></span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_all_list_urls</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;https://movie.douban.com/subject/1292052/reviews?start=%s&#x27;</span>%(v) <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4300</span>, <span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    create_table()</span><br><span class="line">    list_urls = get_all_list_urls()</span><br><span class="line">    error_link = []</span><br><span class="line">    <span class="keyword">for</span> list_url <span class="keyword">in</span> list_urls:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            main_spider(list_url)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            error_link.append(list_url)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(error_link) &gt; <span class="number">10</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;ERROR!!!&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年，我二十</title>
    <url>/2017/06/24/%E8%BF%99%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%88%91%E4%BA%8C%E5%8D%81/</url>
    <content><![CDATA[<p>      这一年，在今天，我刚好二十岁。<br>
      二十岁是每个人的黄金时代，是野蛮生长的年纪，是为之后披荆斩棘准备本钱的年纪。加油！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>进程池与线程池</title>
    <url>/2017/03/02/%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>一直不太明白进程与线程的具体实现，近日看到<a href="http://468636.kuaizhan.com/63/66/p4020482347ed56">这篇文章</a>，算是有了进一步的了解。</p>
<h6 id="关于线程池：">关于线程池：</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_future_result</span>(<span class="params">message</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># 创建一个最大可以容纳两个task的线程池</span></span><br><span class="line">future1 = pool.submit(return_future_result, (<span class="string">&#x27;hello&#x27;</span>))  <span class="comment"># 向线程池加一个task</span></span><br><span class="line">future2 = pool.submit(return_future_result, (<span class="string">&#x27;world&#x27;</span>))  <span class="comment"># 向线程池加一个task</span></span><br><span class="line"><span class="built_in">print</span>(future1.done())  <span class="comment"># 判断task1是否结束[sleeping...故线程未完成]</span></span><br><span class="line">time.sleep(<span class="number">3</span>)  <span class="comment"># 主线程sleep 3s使得task2得以完成</span></span><br><span class="line"><span class="built_in">print</span>(future2.done())  <span class="comment"># 判断task2是否结束</span></span><br><span class="line"><span class="comment"># 查看线程结果</span></span><br><span class="line"><span class="built_in">print</span>(future1.result())</span><br><span class="line"><span class="built_in">print</span>(future2.result())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>False<br>
True<br>
hello<br>
world</p>
</blockquote>
<p>可以看到当前程序(<a href="http://Pools.py">Pools.py</a>)有一个进程，三个线程被开启：<br>
UID PID PPID LWP C NLWP STIME TTY TIME CMD<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/1.png" alt=""></p>
<h6 id="关于进程池：">关于进程池：</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_future_result</span>(<span class="params">message</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line">pool = ProcessPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># 创建一个最大可以容纳两个task的进程池</span></span><br><span class="line">future1 = pool.submit(return_future_result, (<span class="string">&#x27;hello&#x27;</span>))  <span class="comment"># 向进程池加一个task</span></span><br><span class="line">future2 = pool.submit(return_future_result, (<span class="string">&#x27;world&#x27;</span>))  <span class="comment"># 向进程池加一个task</span></span><br><span class="line"><span class="built_in">print</span>(future1.done())  <span class="comment"># 判断task1是否结束</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(future2.done())  <span class="comment"># 判断task2是否结束</span></span><br><span class="line"><span class="comment"># 查看线程结果</span></span><br><span class="line"><span class="built_in">print</span>(future1.result())</span><br><span class="line"><span class="built_in">print</span>(future2.result())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出；</p>
<blockquote>
<p>False<br>
True<br>
hello<br>
world</p>
</blockquote>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/2.png" alt=""></p>
<h6 id="关于任务的提交：">关于任务的提交：</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">URLS = [<span class="string">&#x27;http://httpbin.org&#x27;</span>, <span class="string">&#x27; http://example.com/&#x27;</span>, <span class="string">&#x27;http://api.github.com/&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_url</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=<span class="number">60</span>) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通操作</span></span><br><span class="line"><span class="comment"># We can use a with statement t ensure threads are cleaned up promptly</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="built_in">print</span>(future_to_url)  <span class="comment"># 打印当前任务状态</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="comment"># print(future_to_url)  # 打印当前任务状态</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%r generated an exception:%s&#x27;</span>%(url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%r page is %d bytes&#x27;</span>%(url ,<span class="built_in">len</span>(data)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/3.png" alt=""><br>
这里我们通过submit提交了3个task，并且max_workers=3,所以在全部3个任务提交后，全是running状态， 如果max_workers大于3的话，同样都是running的。但是如果将max_workers设置的小于加入的任务数，那么</p>
<p>将会有任务进入pending状态。<br>
如设置max_workers=2, 可以看到最后的任务为pending状态。<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/4.png" alt=""></p>
<h6 id="Map的使用：">Map的使用：</h6>
<p>[实现的任务和上面时一样的]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">URLS = [<span class="string">&#x27;http://httpbin.org&#x27;</span>, <span class="string">&#x27; http://example.com/&#x27;</span>, <span class="string">&#x27;http://api.github.com/&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_url</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=<span class="number">60</span>) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Map</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="keyword">for</span> url, data <span class="keyword">in</span> <span class="built_in">zip</span>(URLS, executor.<span class="built_in">map</span>(load_url, URLS)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%r page os %d bytes&#x27;</span> % (url, <span class="built_in">len</span>(data)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="wait-使用：">wait 使用：</h6>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wait</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, as_completed</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_after_random_secs</span>(<span class="params">num</span>):</span><br><span class="line">    t = randint(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I will sleep:&#x27;</span>, <span class="built_in">str</span>(t), <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    sleep(t)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Return of &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = time.time()</span><br><span class="line">    pool = ThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        futures.append(pool.submit(return_after_random_secs, (x)))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(wait(futures))  <span class="comment"># 阻塞直到所有线程完成</span></span><br><span class="line">    <span class="comment"># print(wait(futures, timeout=None, return_when=&#x27;FIRST_COMPLETED&#x27;))</span></span><br><span class="line">    e = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;total time--&gt;&#x27;</span>, e-s)</span><br></pre></td></tr></table></figure>
<p><img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/5.png" alt=""></p>
<p>可以看到，在子线程未完成时，程序一直被阻塞，最后所有的任务都完成时，程序结束运行。<br>
如果将：</p>
<blockquote>
<p>print(wait(futures))</p>
</blockquote>
<p>改为：</p>
<blockquote>
<p>print(wait(futures, timeout=None, return_when=‘FIRST_COMPLETED’))</p>
</blockquote>
<p>那么，在有一个线程完成时，程序就结束运行：<br>
<img src="http://dataimage-1252464519.costj.myqcloud.com/images/threads/6.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>非它，是你</title>
    <url>/2018/01/05/%E9%9D%9E%E5%AE%83%EF%BC%8C%E6%98%AF%E4%BD%A0/</url>
    <content><![CDATA[<p>大部分时候，我们连自己是谁都是说不清楚的，更遑论说清楚其他的东西了。</p>
<p>早先看过一本书，书名为《遇见未知的自己》，算不得什么好书（有点类似心灵鸡汤那种，不推荐看）。但是里面讨论了一个有趣的问题，值得我们好好思考下——我是谁？看到这个问题，我们首先想到的答案大概就是自己的名字——我是xxx。显然这不是答案——如果有人和你一样叫xxx，那么你们岂不是成了一个人？同样的，用我们的职业，地址，身份等几乎所有的东西都不能作为这个问题的答案。一个看似荒谬，但也许有一定道理的答案就是——非它，我就是我。此中意味，值得我们去细细思量。</p>
<p>关于是谁的问题，也可以用弗洛伊德的想法来尝试解答。依弗所言，完整的人格有三部分组成——本我，自我和超我，而其中自我是人格的执行者。虽说自我在执行上占据主导，而本质上还是三者共存的局面，而他们之间也存在着其他千丝万缕的关系。所以，与其说不知道自己是谁，不如说不知道那个才是自己。</p>
<p>以上，我们必须要认识到一点，那就是，我们有很多事情是难以说清楚的。其实，就像上面讨论的问题一样，我们遇到的大部分的问题都是围绕两个字来的——选择，这也是这篇文章想要讨论的东西。</p>
<p>说人生是路真是个很好的比喻。路不总是平的，所以我们要翻山越岭；路不总是直的，所以我们在岔路口总要作出选择。考虑最简单的情况，即使每次只是在两者中选择一个，在10次选择后，也会有1024种不同的情况，在50次选择后就会有1125899906842624种情况，在100次选择后就有1267650600228229401496703205376种情况。所以，每一次的选择都显得至关重要。而随之而来的一个关键的问题就是如何作出选择。</p>
<p>大多数的时候，当我们面临选择的时候，一般是两者之间难以权衡时作出选择（很好决定的事情就与选择无关了…），从概率上讲，选择其种任何一种情况的概率是均等的，为1/2。所以，在刚刚作出选择后，我们总是没有绝对的把握说自己作出了绝对正确的选择，这点毋庸置疑。不过，在经过一段时间后，我们一般能从事情的发展中获得一定的反馈，从而明白自己做的决定是否是正确的，这也是显而易见的。但是，最重要的一点却容易被忽略——我们总是在做了太多错误的选择之后才找到何为正确。这样不对，这样也不对，这样或许可以，还是不行，也许这样，就是这样。为什么说这点是最重要的呢？因为每一次的选择都是有代价的，到达正确之前的错误选择越多，代价也随之上升。而在这漫长的选择过程中，毫无疑问，很多代价都是逐渐增加的，越来越刻骨铭心，越来越无法承受…因为，在这个过程中，可以出现的，可以消亡的东西，有太多太多。</p>
<p>每一个选择都会造就不同的自己，不同的人生。另，不要忽略一点，我们在作出选择的同时，所有人也在作出自己的选择，大环境也会随之变化，这种变化的情况，毫无疑问也是指数级的。以上，我们必须认识到，大部分时候，我们必须作出选择，在到达正确之前，代价与之伴随。</p>
<p>关于选择，有太多的故事。在《飘》里面，女主到达自己正确的选择花了多少年？又经历了多少事呢？又是谁，”昨夜西风凋碧树，独上高楼，望尽天涯路“， ”衣带渐宽终不悔，为伊消得人憔悴“， ”众里寻他千百度，蓦然回首，那人却在灯火阑珊处“。一般而言，到达正确，要经历的事情太多太多。</p>
<p>然而，或许存在另外一种可能。假如去挑一件首饰，好比一件玉镯。相比精挑细选，仔细排除不想要的，有没有这种可能呢？不仔细对比玉镯的材质，外观，工艺和款式等，直接选中那个，一眼看上就可以，然后戴上去也刚刚好的呢？</p>
<p>一直认为是存在这种可能的。不是”非它，是你“，而是”就是你“。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
